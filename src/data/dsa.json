{
  "dsaTopics": [
    {
      "id": "arrays-hashing",
      "title": "Arrays & Hashing",
      "description": "Array manipulation, hash tables, and frequency counting problems",
      "questions": [
        {
          "id": "ah_1",
          "title": "Contains Duplicate",
          "routeName": "contains_duplicate",
          "difficulty": "Easy",
          "leetcodeNumber": 217,
          "companies": ["Google", "Amazon", "Microsoft", "Apple"],
          "tags": ["Array", "Hash Table", "Sorting"],
          "description": "Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.",
          "detailedDescription": "Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.\n\nExample 1:\nInput: nums = [1,2,3,1]\nOutput: true\n\nExample 2:\nInput: nums = [1,2,3,4]\nOutput: false\n\nExample 3:\nInput: nums = [1,1,1,3,3,4,3,2,4,2]\nOutput: true\n\nConstraints:\n• 1 <= nums.length <= 10^5\n• -10^9 <= nums[i] <= 10^9",
          "approach": "Multiple approaches to solve this problem:\n\n1. **Hash Set**: Add elements to a set and check if element already exists.\n\n2. **Sorting**: Sort the array and check adjacent elements.\n\n3. **Length Comparison**: Convert to set and compare lengths.\n\n4. **Brute Force**: Check every pair (not recommended for large inputs).",
          "solution": "**Approach 1: Hash Set (Most Efficient)**\nUse a set to track seen elements and return true if duplicate found.\n\n**Approach 2: Length Comparison (Most Concise)**\nConvert array to set and compare lengths.\n\n**Approach 3: Sorting**\nSort array and check adjacent elements for duplicates.",
          "code": "# Approach 1: Hash Set (Most Efficient)\ndef containsDuplicate(nums):\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False\n\n# Approach 2: Length Comparison (Most Concise)\ndef containsDuplicate(nums):\n    return len(set(nums)) != len(nums)\n\n# Approach 3: Sorting\ndef containsDuplicate(nums):\n    nums.sort()\n    for i in range(1, len(nums)):\n        if nums[i] == nums[i-1]:\n            return True\n    return False\n\n# Test cases\ntest_cases = [\n    [1,2,3,1],\n    [1,2,3,4],\n    [1,1,1,3,3,4,3,2,4,2]\n]\n\nfor nums in test_cases:\n    result = containsDuplicate(nums)\n    print(f\"Input: {nums} -> Output: {result}\")",
          "timeComplexity": "• **Hash Set**: O(n) average case, O(n) worst case\n• **Length Comparison**: O(n) for set creation\n• **Sorting**: O(n log n) for sorting",
          "spaceComplexity": "• **Hash Set**: O(n) in worst case when no duplicates\n• **Length Comparison**: O(n) for set creation\n• **Sorting**: O(1) if sorting in-place, O(n) otherwise",
          "keyInsights": "• Hash set provides optimal time complexity for duplicate detection\n• Length comparison is the most concise solution\n• Early termination in hash set approach saves time when duplicates found early\n• This pattern is fundamental for many array problems\n• Consider space-time tradeoffs when choosing approach",
          "link": "https://leetcode.com/problems/contains-duplicate/"
        },
        {
          "id": "ah_2",
          "title": "Valid Anagram",
          "routeName": "valid_anagram",
          "difficulty": "Easy",
          "leetcodeNumber": 242,
          "companies": ["Facebook", "Amazon", "Netflix", "Bloomberg"],
          "tags": ["String", "Hash Table", "Sorting"],
          "description": "Given two strings s and t, return true if t is an anagram of s, and false otherwise.",
          "detailedDescription": "An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n\nExample 1:\nInput: s = \"anagram\", t = \"nagaram\"\nOutput: true\n\nExample 2:\nInput: s = \"rat\", t = \"car\"\nOutput: false\n\nConstraints:\n• 1 <= s.length, t.length <= 5 * 10^4\n• s and t consist of lowercase English letters",
          "approach": "Several approaches to solve this problem:\n\n1. **Sorting**: Sort both strings and compare if they are equal.\n\n2. **Hash Map/Counter**: Count frequency of each character in both strings and compare.\n\n3. **Array Counting**: Use array of size 26 for lowercase letters to count frequencies.\n\n4. **Character Cancellation**: Increment count for characters in first string, decrement for second string.",
          "solution": "**Approach 1: Sorting (Most Straightforward)**\nSort both strings and check if they are identical.\n\n**Approach 2: Character Frequency Count**\nCount character frequencies and compare.\n\n**Approach 3: Single Pass Counter**\nIncrement counter for first string, decrement for second string.",
          "code": "from collections import Counter\n\n# Approach 1: Sorting (Most Common)\ndef isAnagram(s, t):\n    return sorted(s) == sorted(t)\n\n# Approach 2: Counter (Using built-in)\ndef isAnagram(s, t):\n    return Counter(s) == Counter(t)\n\n# Approach 3: Manual Character Count\ndef isAnagram(s, t):\n    if len(s) != len(t):\n        return False\n    \n    char_count = {}\n    \n    # Count characters in s\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    # Subtract characters in t\n    for char in t:\n        if char not in char_count:\n            return False\n        char_count[char] -= 1\n        if char_count[char] == 0:\n            del char_count[char]\n    \n    return len(char_count) == 0\n\n# Approach 4: Array Counting (Most Efficient for lowercase letters)\ndef isAnagram(s, t):\n    if len(s) != len(t):\n        return False\n    \n    # Array for 26 lowercase letters\n    char_count = [0] * 26\n    \n    for i in range(len(s)):\n        char_count[ord(s[i]) - ord('a')] += 1\n        char_count[ord(t[i]) - ord('a')] -= 1\n    \n    return all(count == 0 for count in char_count)\n\n# Test cases\ntest_cases = [\n    (\"anagram\", \"nagaram\"),\n    (\"rat\", \"car\"),\n    (\"listen\", \"silent\")\n]\n\nfor s, t in test_cases:\n    result = isAnagram(s, t)\n    print(f\"'{s}' and '{t}': {result}\")",
          "timeComplexity": "• **Sorting**: O(n log n) where n is the length of the strings\n• **Counter/Hash Map**: O(n) to iterate through both strings\n• **Array Counting**: O(n) with better constants than hash map",
          "spaceComplexity": "• **Sorting**: O(1) if sorting in-place, O(n) otherwise\n• **Hash Map**: O(n) for storing character counts\n• **Array Counting**: O(1) since array size is fixed (26)",
          "keyInsights": "• Anagram problems involve character frequency analysis\n• Sorting provides simple but not most efficient solution\n• Array counting is most efficient for limited character sets\n• Early length check can save computation\n• This pattern applies to grouping anagrams and string permutation problems",
          "link": "https://leetcode.com/problems/valid-anagram/"
        },
        {
          "id": "ah_3",
          "title": "Two Sum",
          "routeName": "two_sum",
          "difficulty": "Easy",
          "leetcodeNumber": 1,
          "companies": ["Google", "Amazon", "Apple", "Microsoft", "Facebook"],
          "tags": ["Array", "Hash Table"],
          "description": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.",
          "detailedDescription": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\nYou can return the answer in any order.\n\nExample 1:\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n\nExample 2:\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\n\nExample 3:\nInput: nums = [3,3], target = 6\nOutput: [0,1]\n\nConstraints:\n• 2 <= nums.length <= 10^4\n• -10^9 <= nums[i] <= 10^9\n• -10^9 <= target <= 10^9\n• Only one valid answer exists",
          "approach": "Multiple approaches to solve this problem:\n\n1. **Hash Map (One Pass)**: Store complement and index as we iterate.\n\n2. **Hash Map (Two Pass)**: First pass to build hash map, second pass to find complement.\n\n3. **Brute Force**: Check all pairs (not recommended for large inputs).\n\n4. **Two Pointers**: Sort array first, then use two pointers (loses original indices).",
          "solution": "**Approach 1: Hash Map One Pass (Optimal)**\nUse hash map to store seen numbers and their indices, check for complement.\n\n**Approach 2: Brute Force**\nCheck all possible pairs until target sum is found.\n\n**Key Insight**: We need to find complement (target - current_number) in the array.",
          "code": "# Approach 1: Hash Map (One Pass) - Optimal\ndef twoSum(nums, target):\n    hashmap = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in hashmap:\n            return [hashmap[complement], i]\n        hashmap[num] = i\n    return []  # Should never reach here given constraints\n\n# Approach 2: Hash Map (Two Pass)\ndef twoSum(nums, target):\n    hashmap = {num: i for i, num in enumerate(nums)}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in hashmap and hashmap[complement] != i:\n            return [i, hashmap[complement]]\n    return []\n\n# Approach 3: Brute Force\ndef twoSum(nums, target):\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[i] + nums[j] == target:\n                return [i, j]\n    return []\n\n# Test cases\ntest_cases = [\n    ([2, 7, 11, 15], 9),\n    ([3, 2, 4], 6),\n    ([3, 3], 6)\n]\n\nfor nums, target in test_cases:\n    result = twoSum(nums, target)\n    print(f\"nums: {nums}, target: {target} -> indices: {result}\")",
          "timeComplexity": "• **Hash Map**: O(n) single pass through the array\n• **Brute Force**: O(n²) checking all pairs",
          "spaceComplexity": "• **Hash Map**: O(n) for storing up to n elements\n• **Brute Force**: O(1) only using variables",
          "keyInsights": "• Hash map trades space for time to achieve O(n) solution\n• The key insight is looking for complement (target - current)\n• One-pass solution is more efficient than two-pass\n• This pattern applies to many sum-based problems\n• Consider edge cases like duplicate numbers",
          "link": "https://leetcode.com/problems/two-sum/"
        },
        {
          "id": "ah_4",
          "title": "Group Anagrams",
          "routeName": "group_anagrams",
          "difficulty": "Medium",
          "leetcodeNumber": 49,
          "companies": ["Amazon", "Facebook", "Google", "Bloomberg"],
          "tags": ["Array", "Hash Table", "String", "Sorting"],
          "description": "Given an array of strings strs, group the anagrams together. You can return the answer in any order.",
          "detailedDescription": "Given an array of strings strs, group the anagrams together. You can return the answer in any order.\n\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n\nExample 1:\nInput: strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\nOutput: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\n\nExample 2:\nInput: strs = [\"\"]\nOutput: [[\"\"]]\n\nExample 3:\nInput: strs = [\"a\"]\nOutput: [[\"a\"]]\n\nConstraints:\n• 1 <= strs.length <= 10^4\n• 0 <= strs[i].length <= 100\n• strs[i] consists of lowercase English letters",
          "approach": "Several approaches to solve this problem:\n\n1. **Sorting Key**: Use sorted string as key in hash map.\n\n2. **Character Count Key**: Use character frequency tuple as key.\n\n3. **Prime Number Encoding**: Assign prime numbers to each character (mathematical approach).",
          "solution": "**Approach 1: Sorting as Key**\nGroup strings by their sorted version as the key.\n\n**Approach 2: Character Count as Key**\nUse character frequency as the grouping key.\n\n**Key Insight**: Anagrams have the same characters with same frequencies.",
          "code": "from collections import defaultdict\n\n# Approach 1: Sorting as Key (Most Common)\ndef groupAnagrams(strs):\n    anagram_groups = defaultdict(list)\n    \n    for s in strs:\n        # Use sorted string as key\n        key = tuple(sorted(s))\n        anagram_groups[key].append(s)\n    \n    return list(anagram_groups.values())\n\n# Approach 2: Character Count as Key\ndef groupAnagrams(strs):\n    anagram_groups = defaultdict(list)\n    \n    for s in strs:\n        # Count characters and use as key\n        char_count = [0] * 26\n        for char in s:\n            char_count[ord(char) - ord('a')] += 1\n        \n        key = tuple(char_count)\n        anagram_groups[key].append(s)\n    \n    return list(anagram_groups.values())\n\n# Approach 3: Using Counter (Alternative)\nfrom collections import Counter, defaultdict\n\ndef groupAnagrams(strs):\n    anagram_groups = defaultdict(list)\n    \n    for s in strs:\n        # Use character frequency as key\n        key = tuple(sorted(Counter(s).items()))\n        anagram_groups[key].append(s)\n    \n    return list(anagram_groups.values())\n\n# Most concise version\ndef groupAnagrams(strs):\n    groups = defaultdict(list)\n    for s in strs:\n        groups[tuple(sorted(s))].append(s)\n    return list(groups.values())\n\n# Test cases\ntest_cases = [\n    [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"],\n    [\"\"],\n    [\"a\"]\n]\n\nfor strs in test_cases:\n    result = groupAnagrams(strs)\n    print(f\"Input: {strs}\")\n    print(f\"Output: {result}\\n\")",
          "timeComplexity": "• **Sorting approach**: O(n * m log m) where n is number of strings and m is average string length\n• **Character count approach**: O(n * m) where n is number of strings and m is average string length",
          "spaceComplexity": "• Both approaches: O(n * m) for storing all strings in hash map groups",
          "keyInsights": "• Hash map with computed keys is perfect for grouping problems\n• Sorted string serves as canonical representation of anagram group\n• Character count array can be more efficient than sorting for long strings\n• defaultdict simplifies group creation logic\n• This pattern applies to any grouping problem with equivalence relation",
          "link": "https://leetcode.com/problems/group-anagrams/"
        },
        {
          "id": "ah_5",
          "title": "Top K Frequent Elements",
          "routeName": "top_k_frequent_elements",
          "difficulty": "Medium",
          "leetcodeNumber": 347,
          "companies": ["Amazon", "Google", "Facebook", "Yelp"],
          "tags": [
            "Array",
            "Hash Table",
            "Divide and Conquer",
            "Sorting",
            "Heap",
            "Bucket Sort",
            "Counting",
            "Quickselect"
          ],
          "description": "Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.",
          "detailedDescription": "Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.\n\nExample 1:\nInput: nums = [1,1,1,2,2,3], k = 2\nOutput: [1,2]\n\nExample 2:\nInput: nums = [1], k = 1\nOutput: [1]\n\nConstraints:\n• 1 <= nums.length <= 10^5\n• k is in the range [1, the number of unique elements in the array]\n• It is guaranteed that the answer is unique\n\nFollow up: Your algorithm's time complexity must be better than O(n log n), where n is the array's size.",
          "approach": "Several approaches to solve this problem:\n\n1. **Heap**: Use min-heap of size k to track top k frequent elements.\n\n2. **Bucket Sort**: Use frequency as bucket index for O(n) solution.\n\n3. **Sorting**: Count frequencies then sort by frequency.\n\n4. **Quick Select**: Use quick select on frequency array.",
          "solution": "**Approach 1: Min Heap (Most Common)**\nUse Counter to get frequencies, then heap to get top k.\n\n**Approach 2: Bucket Sort (Optimal)**\nUse frequency as bucket index for linear time solution.\n\n**Approach 3: Sorting (Simple but not optimal)**\nSort by frequency and take top k.",
          "code": "import heapq\nfrom collections import Counter\n\n# Approach 1: Heap (Most Common Solution)\ndef topKFrequent(nums, k):\n    # Count frequencies\n    count = Counter(nums)\n    \n    # Use heap to get k most frequent\n    return heapq.nlargest(k, count.keys(), key=count.get)\n\n# Approach 2: Bucket Sort (Optimal O(n))\ndef topKFrequent(nums, k):\n    count = Counter(nums)\n    \n    # Create buckets for each possible frequency\n    buckets = [[] for _ in range(len(nums) + 1)]\n    \n    # Put elements in buckets based on frequency\n    for num, freq in count.items():\n        buckets[freq].append(num)\n    \n    # Collect top k elements from highest frequency buckets\n    result = []\n    for i in range(len(buckets) - 1, 0, -1):\n        for num in buckets[i]:\n            result.append(num)\n            if len(result) == k:\n                return result\n    \n    return result\n\n# Approach 3: Sorting\ndef topKFrequent(nums, k):\n    count = Counter(nums)\n    \n    # Sort by frequency in descending order\n    sorted_items = sorted(count.items(), key=lambda x: x[1], reverse=True)\n    \n    # Return top k elements\n    return [item[0] for item in sorted_items[:k]]\n\n# Approach 4: Min Heap (Manual Implementation)\ndef topKFrequent(nums, k):\n    count = Counter(nums)\n    \n    heap = []\n    for num, freq in count.items():\n        heapq.heappush(heap, (freq, num))\n        if len(heap) > k:\n            heapq.heappop(heap)\n    \n    return [num for freq, num in heap]\n\n# Test cases\ntest_cases = [\n    ([1,1,1,2,2,3], 2),\n    ([1], 1),\n    ([1,2,3,4,5], 3)\n]\n\nfor nums, k in test_cases:\n    result = topKFrequent(nums, k)\n    print(f\"nums: {nums}, k: {k} -> result: {result}\")",
          "timeComplexity": "• **Heap**: O(n log k) where n is array length\n• **Bucket Sort**: O(n) linear time\n• **Sorting**: O(n log n) for sorting frequencies\n• **Quick Select**: O(n) average case",
          "spaceComplexity": "• All approaches: O(n) for frequency counting and result storage",
          "keyInsights": "• Counter is essential for frequency-based problems\n• Heap provides good balance between time and space complexity\n• Bucket sort achieves optimal O(n) time when frequency range is limited\n• The follow-up constraint eliminates simple sorting solutions\n• This pattern applies to \"top k\" problems with frequency requirements",
          "link": "https://leetcode.com/problems/top-k-frequent-elements/"
        },
        {
          "id": "ah_6",
          "title": "Product of Array Except Self",
          "routeName": "product_of_array_except_self",
          "difficulty": "Medium",
          "leetcodeNumber": 238,
          "companies": ["Amazon", "Apple", "Facebook", "Microsoft"],
          "tags": ["Array", "Prefix Sum"],
          "description": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].",
          "detailedDescription": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].\n\nThe algorithm must run in O(n) time and without using the division operation.\n\nExample 1:\nInput: nums = [1,2,3,4]\nOutput: [24,12,8,6]\n\nExample 2:\nInput: nums = [-1,1,0,-3,3]\nOutput: [0,0,9,0,0]\n\nConstraints:\n• 2 <= nums.length <= 10^5\n• -30 <= nums[i] <= 30\n• The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer\n\nFollow up: Can you solve the problem in O(1) extra space complexity?",
          "approach": "Several approaches to solve this problem:\n\n1. **Left and Right Arrays**: Create separate arrays for left and right products.\n\n2. **Single Array with Two Passes**: Use output array to store left products, then multiply with right products.\n\n3. **Division Method**: Calculate total product and divide (not allowed in constraints).\n\n4. **Optimized Space**: Use the output array itself to store intermediate results.",
          "solution": "**Approach 1: Two Arrays (Conceptually Clear)**\nCreate left and right product arrays, then multiply corresponding elements.\n\n**Approach 2: Single Array Two Passes (Space Optimized)**\nUse output array for left products first, then multiply with right products in second pass.\n\n**Key Insight**: Product except self = (product of all left elements) × (product of all right elements).",
          "code": "# Approach 1: Left and Right Arrays (Conceptual)\ndef productExceptSelf(nums):\n    n = len(nums)\n    \n    # Calculate left products\n    left = [1] * n\n    for i in range(1, n):\n        left[i] = left[i-1] * nums[i-1]\n    \n    # Calculate right products\n    right = [1] * n\n    for i in range(n-2, -1, -1):\n        right[i] = right[i+1] * nums[i+1]\n    \n    # Multiply left and right products\n    result = []\n    for i in range(n):\n        result.append(left[i] * right[i])\n    \n    return result\n\n# Approach 2: Optimized Single Array (Most Efficient)\ndef productExceptSelf(nums):\n    n = len(nums)\n    output = [1] * n\n    \n    # First pass: calculate left products\n    prefix = 1\n    for i in range(n):\n        output[i] = prefix\n        prefix *= nums[i]\n    \n    # Second pass: multiply with right products\n    postfix = 1\n    for i in range(n-1, -1, -1):\n        output[i] *= postfix\n        postfix *= nums[i]\n    \n    return output\n\n# Approach 3: More Readable Version\ndef productExceptSelf(nums):\n    n = len(nums)\n    result = [1] * n\n    \n    # Fill result with left products\n    for i in range(1, n):\n        result[i] = result[i-1] * nums[i-1]\n    \n    # Multiply with right products\n    right_product = 1\n    for i in range(n-1, -1, -1):\n        result[i] *= right_product\n        right_product *= nums[i]\n    \n    return result\n\n# Test cases\ntest_cases = [\n    [1,2,3,4],\n    [-1,1,0,-3,3],\n    [2,3,4,5]\n]\n\nfor nums in test_cases:\n    result = productExceptSelf(nums)\n    print(f\"Input: {nums}\")\n    print(f\"Output: {result}\\n\")",
          "timeComplexity": "O(n) - Two passes through the array, each taking O(n) time",
          "spaceComplexity": "O(1) extra space (not counting the output array which is required by the problem)",
          "keyInsights": "• The key insight is that product except self = left_product × right_product\n• Two-pass approach avoids division operation requirement\n• Using output array for intermediate storage achieves O(1) extra space\n• Prefix and postfix product patterns are common in array problems\n• This technique applies to many \"except self\" type problems",
          "link": "https://leetcode.com/problems/product-of-array-except-self/"
        },
        {
          "id": "ah_7",
          "title": "Valid Sudoku",
          "routeName": "valid_sudoku",
          "difficulty": "Medium",
          "leetcodeNumber": 36,
          "companies": ["Apple", "Amazon", "Google", "Microsoft"],
          "tags": ["Array", "Hash Table", "Matrix"],
          "description": "Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules.",
          "detailedDescription": "Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:\n\n1. Each row must contain the digits 1-9 without repetition.\n2. Each column must contain the digits 1-9 without repetition.\n3. Each of the nine 3 x 3 sub-boxes must contain the digits 1-9 without repetition.\n\nNote:\n• A Sudoku board (partially filled) could be valid but is not necessarily solvable.\n• Only the filled cells need to be validated according to the mentioned rules.\n\nExample 1:\nInput: board = \n[[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],\n [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],\n [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],\n [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],\n [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],\n [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],\n [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],\n [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],\n [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\nOutput: true\n\nConstraints:\n• board.length == 9\n• board[i].length == 9\n• board[i][j] is a digit 1-9 or '.'",
          "approach": "Several approaches to solve this problem:\n\n1. **Three Separate Checks**: Check rows, columns, and 3x3 boxes separately.\n\n2. **Single Pass with Sets**: Use sets to track seen numbers in one pass.\n\n3. **Hash Map Tracking**: Use hash maps to track numbers in rows, columns, and boxes.\n\n4. **Bit Manipulation**: Use bit masks to track seen numbers (advanced).",
          "solution": "**Approach 1: Single Pass with Sets (Most Efficient)**\nUse sets to track seen numbers in rows, columns, and 3x3 boxes in one pass.\n\n**Approach 2: Three Separate Checks (More Readable)**\nCheck each constraint separately with helper functions.\n\n**Key Insight**: For 3x3 boxes, use (row//3, col//3) to identify which box a cell belongs to.",
          "code": "# Approach 1: Single Pass with Sets (Most Efficient)\ndef isValidSudoku(board):\n    rows = [set() for _ in range(9)]\n    cols = [set() for _ in range(9)]\n    boxes = [set() for _ in range(9)]\n    \n    for i in range(9):\n        for j in range(9):\n            val = board[i][j]\n            if val == '.':\n                continue\n            \n            # Calculate box index\n            box_index = (i // 3) * 3 + j // 3\n            \n            # Check if val already exists in row, col, or box\n            if val in rows[i] or val in cols[j] or val in boxes[box_index]:\n                return False\n            \n            # Add val to respective sets\n            rows[i].add(val)\n            cols[j].add(val)\n            boxes[box_index].add(val)\n    \n    return True\n\n# Approach 2: Three Separate Checks (More Readable)\ndef isValidSudoku(board):\n    def is_valid_group(group):\n        group = [val for val in group if val != '.']\n        return len(group) == len(set(group))\n    \n    # Check rows\n    for row in board:\n        if not is_valid_group(row):\n            return False\n    \n    # Check columns\n    for col in range(9):\n        column = [board[row][col] for row in range(9)]\n        if not is_valid_group(column):\n            return False\n    \n    # Check 3x3 boxes\n    for box_row in range(0, 9, 3):\n        for box_col in range(0, 9, 3):\n            box = []\n            for i in range(box_row, box_row + 3):\n                for j in range(box_col, box_col + 3):\n                    box.append(board[i][j])\n            if not is_valid_group(box):\n                return False\n    \n    return True\n\n# Approach 3: Using defaultdict for cleaner code\nfrom collections import defaultdict\n\ndef isValidSudoku(board):\n    rows = defaultdict(set)\n    cols = defaultdict(set)\n    boxes = defaultdict(set)\n    \n    for i in range(9):\n        for j in range(9):\n            val = board[i][j]\n            if val == '.':\n                continue\n            \n            box_id = (i // 3, j // 3)\n            \n            if val in rows[i] or val in cols[j] or val in boxes[box_id]:\n                return False\n            \n            rows[i].add(val)\n            cols[j].add(val)\n            boxes[box_id].add(val)\n    \n    return True\n\n# Test case\nboard = [\n    [\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],\n    [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],\n    [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],\n    [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],\n    [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],\n    [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],\n    [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],\n    [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],\n    [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]\n]\n\nresult = isValidSudoku(board)\nprint(f\"Is valid Sudoku: {result}\")",
          "timeComplexity": "O(1) - Since the board is always 9x9, we iterate through a constant 81 cells",
          "spaceComplexity": "O(1) - We use a constant amount of extra space (9 sets for rows, 9 for columns, 9 for boxes)",
          "keyInsights": "• Single pass with sets is more efficient than multiple separate checks\n• Box index calculation: (row//3) * 3 + col//3 maps 2D position to box number\n• Using sets for duplicate detection is the most natural approach\n• Sudoku validation is a classic application of constraint checking\n• This pattern applies to other grid-based constraint satisfaction problems",
          "link": "https://leetcode.com/problems/valid-sudoku/"
        },
        {
          "id": "ah_8",
          "title": "Encode and Decode Strings",
          "routeName": "encode_and_decode_strings",
          "difficulty": "Medium",
          "leetcodeNumber": 271,
          "companies": ["Google", "Facebook", "Amazon", "Microsoft"],
          "tags": ["Array", "String", "Design"],
          "description": "Design an algorithm to encode a list of strings to a string and decode it back.",
          "detailedDescription": "Design an algorithm to encode a list of strings to a string and decode it back.\n\nThe machine does not know the size of each individual string nor the overall size of the list of strings.\n\nNote: The string may contain any possible characters out of 256 valid ASCII characters. Your algorithm should be generalized enough to work on any possible characters.\n\nExample 1:\nInput: dummy_input = [\"Hello\",\"World\"]\nOutput: [\"Hello\",\"World\"]\nExplanation:\nMachine 1:\nCodec encoder = new Codec();\nString msg = encoder.encode(strs);\nMachine 1 ---msg---> Machine 2\n\nMachine 2:\nCodec decoder = new Codec();\nList<String> strs = decoder.decode(msg);\n\nExample 2:\nInput: dummy_input = [\"\"]\nOutput: [\"\"]\n\nConstraints:\n• 1 <= strs.length <= 200\n• 0 <= strs[i].length <= 200\n• strs[i] contains any possible characters out of 256 valid ASCII characters",
          "approach": "Several approaches to solve this problem:\n\n1. **Length Prefix**: Prefix each string with its length and a delimiter.\n\n2. **Escape Character**: Use escape sequences for special characters.\n\n3. **Fixed-Length Headers**: Use fixed-width length headers.\n\n4. **Base64 Encoding**: Encode strings to avoid delimiter conflicts.",
          "solution": "**Approach 1: Length Prefix (Most Robust)**\nPrefix each string with 'length:' to avoid delimiter conflicts.\n\n**Approach 2: Escape Character**\nUse escape sequences but can be complex with multiple special characters.\n\n**Key Insight**: Need to handle any possible character including delimiters used in encoding.",
          "code": "# Approach 1: Length Prefix (Most Common and Robust)\nclass Codec:\n    def encode(self, strs):\n        \"\"\"Encodes a list of strings to a single string.\"\"\"\n        encoded = \"\"\n        for s in strs:\n            # Format: \"length:string\"\n            encoded += str(len(s)) + \":\" + s\n        return encoded\n    \n    def decode(self, s):\n        \"\"\"Decodes a single string to a list of strings.\"\"\"\n        decoded = []\n        i = 0\n        \n        while i < len(s):\n            # Find the colon that separates length from string\n            colon_index = s.find(':', i)\n            \n            # Extract length\n            length = int(s[i:colon_index])\n            \n            # Extract string of that length\n            start = colon_index + 1\n            string = s[start:start + length]\n            decoded.append(string)\n            \n            # Move to next string\n            i = start + length\n        \n        return decoded\n\n# Approach 2: More Explicit Length Prefix\nclass Codec2:\n    def encode(self, strs):\n        encoded = \"\"\n        for s in strs:\n            # Use # as delimiter after length\n            encoded += str(len(s)) + \"#\" + s\n        return encoded\n    \n    def decode(self, s):\n        decoded = []\n        i = 0\n        \n        while i < len(s):\n            # Find delimiter\n            delimiter_index = s.find('#', i)\n            \n            # Extract length\n            length = int(s[i:delimiter_index])\n            \n            # Extract string\n            start = delimiter_index + 1\n            string = s[start:start + length]\n            decoded.append(string)\n            \n            # Move pointer\n            i = start + length\n        \n        return decoded\n\n# Approach 3: Using join/split with escape (Less Robust)\nclass Codec3:\n    def encode(self, strs):\n        # Replace delimiter in strings and join\n        return '|'.join(s.replace('|', '||') for s in strs)\n    \n    def decode(self, s):\n        # This approach has edge cases and is not recommended\n        # for production use due to complexity in handling escapes\n        decoded = []\n        current = \"\"\n        i = 0\n        \n        while i < len(s):\n            if s[i] == '|':\n                if i + 1 < len(s) and s[i + 1] == '|':\n                    current += '|'\n                    i += 2\n                else:\n                    decoded.append(current)\n                    current = \"\"\n                    i += 1\n            else:\n                current += s[i]\n                i += 1\n        \n        decoded.append(current)\n        return decoded\n\n# Test the codec\ncodec = Codec()\n\ntest_cases = [\n    [\"Hello\", \"World\"],\n    [\"\"],\n    [\"a\", \"b\", \"c\"],\n    [\"Hello:World\", \"Test#String\"],\n    [\"\"]\n]\n\nfor strs in test_cases:\n    encoded = codec.encode(strs)\n    decoded = codec.decode(encoded)\n    print(f\"Original: {strs}\")\n    print(f\"Encoded: {repr(encoded)}\")\n    print(f\"Decoded: {decoded}\")\n    print(f\"Success: {strs == decoded}\\n\")",
          "timeComplexity": "• **Encode**: O(n) where n is total length of all strings\n• **Decode**: O(n) for parsing the encoded string",
          "spaceComplexity": "O(n) for storing the encoded string and decoded list",
          "keyInsights": "• Length prefix approach handles any character including potential delimiters\n• Avoid using characters from input as delimiters to prevent conflicts\n• The colon approach is elegant because we know the format: length:content\n• This pattern is used in network protocols and serialization\n• Consider edge cases like empty strings and strings containing delimiter characters",
          "link": "https://leetcode.com/problems/encode-and-decode-strings/"
        },
        {
          "id": "ah_9",
          "title": "Longest Consecutive Sequence",
          "routeName": "longest_consecutive_sequence",
          "difficulty": "Medium",
          "leetcodeNumber": 128,
          "companies": ["Google", "Facebook", "Amazon", "Bloomberg"],
          "tags": ["Array", "Hash Table", "Union Find"],
          "description": "Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.",
          "detailedDescription": "Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.\n\nYou must write an algorithm that runs in O(n) time.\n\nExample 1:\nInput: nums = [100,4,200,1,3,2]\nOutput: 4\nExplanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.\n\nExample 2:\nInput: nums = [0,3,7,2,5,8,4,6,0,1]\nOutput: 9\n\nConstraints:\n• 0 <= nums.length <= 10^5\n• -10^9 <= nums[i] <= 10^9",
          "approach": "Several approaches to solve this problem:\n\n1. **Hash Set**: Convert to set and check for sequence starts.\n\n2. **Sorting**: Sort array and find longest consecutive sequence (O(n log n)).\n\n3. **Union Find**: Use union-find data structure.\n\n4. **Hash Map**: Track sequence lengths dynamically.",
          "solution": "**Approach 1: Hash Set with Sequence Start Detection (Optimal)**\nUse set for O(1) lookup and only start counting from sequence beginnings.\n\n**Approach 2: Sorting (Simple but not O(n))**\nSort array and iterate to find longest consecutive sequence.\n\n**Key Insight**: Only start counting from the beginning of a sequence (when num-1 is not in set).",
          "code": "# Approach 1: Hash Set (Optimal O(n))\ndef longestConsecutive(nums):\n    if not nums:\n        return 0\n    \n    num_set = set(nums)\n    longest_streak = 0\n    \n    for num in num_set:\n        # Check if this is the start of a sequence\n        if num - 1 not in num_set:\n            current_num = num\n            current_streak = 1\n            \n            # Count consecutive numbers\n            while current_num + 1 in num_set:\n                current_num += 1\n                current_streak += 1\n            \n            # Update longest streak\n            longest_streak = max(longest_streak, current_streak)\n    \n    return longest_streak\n\n# Approach 2: Sorting (O(n log n))\ndef longestConsecutive(nums):\n    if not nums:\n        return 0\n    \n    nums.sort()\n    longest_streak = 1\n    current_streak = 1\n    \n    for i in range(1, len(nums)):\n        # Skip duplicates\n        if nums[i] == nums[i-1]:\n            continue\n        \n        if nums[i] == nums[i-1] + 1:\n            current_streak += 1\n        else:\n            longest_streak = max(longest_streak, current_streak)\n            current_streak = 1\n    \n    return max(longest_streak, current_streak)\n\n# Approach 3: Hash Map (Dynamic Programming style)\ndef longestConsecutive(nums):\n    if not nums:\n        return 0\n    \n    num_to_length = {}\n    max_length = 0\n    \n    for num in nums:\n        if num in num_to_length:\n            continue\n        \n        # Get lengths of adjacent sequences\n        left_length = num_to_length.get(num - 1, 0)\n        right_length = num_to_length.get(num + 1, 0)\n        \n        # Calculate new sequence length\n        new_length = left_length + right_length + 1\n        \n        # Update the map\n        num_to_length[num] = new_length\n        \n        # Update endpoints of the sequence\n        num_to_length[num - left_length] = new_length\n        num_to_length[num + right_length] = new_length\n        \n        max_length = max(max_length, new_length)\n    \n    return max_length\n\n# Most concise version\ndef longestConsecutive(nums):\n    num_set = set(nums)\n    longest = 0\n    \n    for num in num_set:\n        if num - 1 not in num_set:  # Start of sequence\n            length = 1\n            while num + length in num_set:\n                length += 1\n            longest = max(longest, length)\n    \n    return longest\n\n# Test cases\ntest_cases = [\n    [100,4,200,1,3,2],\n    [0,3,7,2,5,8,4,6,0,1],\n    [1,2,0,1],\n    [],\n    [1]\n]\n\nfor nums in test_cases:\n    result = longestConsecutive(nums)\n    print(f\"Input: {nums}\")\n    print(f\"Longest consecutive sequence length: {result}\\n\")",
          "timeComplexity": "• **Hash Set**: O(n) - Each number is visited at most twice\n• **Sorting**: O(n log n) for sorting\n• **Hash Map**: O(n) average case",
          "spaceComplexity": "• **Hash Set**: O(n) for storing all numbers\n• **Sorting**: O(1) if sorting in-place\n• **Hash Map**: O(n) for the map",
          "keyInsights": "• The key optimization is only starting sequence counting from sequence beginnings\n• Converting to set enables O(1) lookup which is crucial for O(n) solution\n• Checking 'num - 1 not in set' ensures we don't double-count sequences\n• This problem demonstrates the power of hash sets for sequence problems\n• The pattern of 'finding sequence starts' applies to many consecutive element problems",
          "link": "https://leetcode.com/problems/longest-consecutive-sequence/"
        }
      ]
    },
    {
      "id": "two-pointers",
      "title": "Two Pointers",
      "description": "Two pointer technique for array and string problems",
      "questions": [
        {
          "id": "tp_1",
          "title": "Valid Palindrome",
          "routeName": "valid_palindrome",
          "difficulty": "Easy",
          "leetcodeNumber": 125,
          "companies": ["Facebook", "Microsoft", "Apple", "Amazon"],
          "tags": ["String", "Two Pointers"],
          "description": "A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward.",
          "detailedDescription": "A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.\n\nGiven a string s, return true if it is a palindrome, or false otherwise.\n\nExample 1:\nInput: s = \"A man, a plan, a canal: Panama\"\nOutput: true\nExplanation: \"amanaplanacanalpanama\" is a palindrome.\n\nExample 2:\nInput: s = \"race a car\"\nOutput: false\nExplanation: \"raceacar\" is not a palindrome.\n\nExample 3:\nInput: s = \" \"\nOutput: true\nExplanation: s is an empty string \"\" after removing non-alphanumeric characters.\n\nConstraints:\n• 1 <= s.length <= 2 * 10^5\n• s consists only of printable ASCII characters",
          "approach": "Multiple approaches to solve this problem:\n\n1. **Two Pointers with On-the-fly Cleaning**: Skip non-alphanumeric characters while comparing.\n\n2. **Two Pointers with Preprocessing**: Clean the string first, then use two pointers.\n\n3. **Reverse and Compare**: Clean the string, reverse it, and compare with original.\n\n4. **Recursive**: Clean the string and use recursion to check palindrome property.",
          "solution": "**Approach 1: Two Pointers with On-the-fly Processing (Optimal)**\nUse two pointers and skip invalid characters during comparison.\n\n**Approach 2: Two Pointers with Preprocessing**\nFirst clean the string by removing non-alphanumeric characters and converting to lowercase.\n\n**Key Insight**: Two pointers technique allows us to check palindrome in O(1) extra space.",
          "code": "# Approach 1: Two Pointers with On-the-fly Processing (Most Efficient)\ndef isPalindrome(s):\n    left, right = 0, len(s) - 1\n    \n    while left < right:\n        # Skip non-alphanumeric characters from left\n        while left < right and not s[left].isalnum():\n            left += 1\n        \n        # Skip non-alphanumeric characters from right\n        while left < right and not s[right].isalnum():\n            right -= 1\n        \n        # Compare characters (case-insensitive)\n        if s[left].lower() != s[right].lower():\n            return False\n        \n        left += 1\n        right -= 1\n    \n    return True\n\n# Approach 2: Two Pointers with Preprocessing\ndef isPalindrome(s):\n    # Clean the string: keep only alphanumeric and convert to lowercase\n    cleaned = ''.join(char.lower() for char in s if char.isalnum())\n    \n    # Two pointers approach\n    left, right = 0, len(cleaned) - 1\n    \n    while left < right:\n        if cleaned[left] != cleaned[right]:\n            return False\n        left += 1\n        right -= 1\n    \n    return True\n\n# Approach 3: Using Regular Expressions\nimport re\n\ndef isPalindrome(s):\n    # Remove non-alphanumeric characters and convert to lowercase\n    cleaned = re.sub(r'[^a-zA-Z0-9]', '', s).lower()\n    return cleaned == cleaned[::-1]\n\n# Approach 4: Functional Programming Style\ndef isPalindrome(s):\n    chars = [char.lower() for char in s if char.isalnum()]\n    return chars == chars[::-1]\n\n# Test cases\ntest_cases = [\n    \"A man, a plan, a canal: Panama\",\n    \"race a car\",\n    \" \",\n    \"Madam\",\n    \"No 'x' in Nixon\"\n]\n\nfor test in test_cases:\n    result = isPalindrome(test)\n    print(f\"'{test}' -> {result}\")",
          "timeComplexity": "• **On-the-fly approach**: O(n) single pass through the string\n• **Preprocessing approach**: O(n) for cleaning + O(n) for checking = O(n)\n• **Regex approach**: O(n) for regex processing + O(n) for comparison = O(n)",
          "spaceComplexity": "• **On-the-fly approach**: O(1) only using two pointers\n• **Preprocessing approach**: O(n) for storing the cleaned string\n• **Regex approach**: O(n) for storing cleaned string\n• **Functional approach**: O(n) for storing the character list",
          "keyInsights": "• Two pointers technique is ideal for palindrome problems\n• On-the-fly processing saves memory by avoiding string preprocessing\n• Case-insensitive comparison requires careful handling\n• The pattern of skipping invalid characters while maintaining two pointers is reusable\n• Consider memory constraints when choosing between preprocessing vs on-the-fly approaches",
          "link": "https://leetcode.com/problems/valid-palindrome/"
        },
        {
          "id": "tp_2",
          "title": "Two Sum II - Input Array Is Sorted",
          "routeName": "two_sum_ii_input_array_is_sorted",
          "difficulty": "Medium",
          "leetcodeNumber": 167,
          "companies": ["Amazon", "Google", "Microsoft", "Facebook"],
          "tags": ["Array", "Two Pointers", "Binary Search"],
          "description": "Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number.",
          "detailedDescription": "Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 <= index1 < index2 <= numbers.length.\n\nReturn the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2.\n\nThe tests are generated such that there is exactly one solution. You may not use the same element twice.\n\nYour solution must use only constant extra space.\n\nExample 1:\nInput: numbers = [2,7,11,15], target = 9\nOutput: [1,2]\nExplanation: The sum of 2 and 7 is 9. Therefore, index1 = 1, index2 = 2. We return [1, 2].\n\nExample 2:\nInput: numbers = [2,3,4], target = 6\nOutput: [1,3]\nExplanation: The sum of 2 and 4 is 6. Therefore, index1 = 1, index2 = 3. We return [1, 3].\n\nExample 3:\nInput: numbers = [-1,0], target = -1\nOutput: [1,2]\nExplanation: The sum of -1 and 0 is -1. Therefore, index1 = 1, index2 = 2. We return [1, 2].\n\nConstraints:\n• 2 <= numbers.length <= 3 * 10^4\n• -1000 <= numbers[i] <= 1000\n• numbers is sorted in non-decreasing order\n• -1000 <= target <= 1000\n• The tests are generated such that there is exactly one solution",
          "approach": "Multiple approaches to solve this problem:\n\n1. **Two Pointers**: Use left and right pointers, move based on sum comparison with target.\n\n2. **Binary Search**: For each element, binary search for the complement.\n\n3. **Hash Map**: Store elements in hash map (but violates O(1) space constraint).\n\n4. **Brute Force**: Check all pairs (not efficient for large inputs).",
          "solution": "**Approach 1: Two Pointers (Optimal)**\nLeverage the sorted property with two pointers from both ends.\n\n**Approach 2: Binary Search**\nFor each element, binary search for target - element.\n\n**Key Insight**: Sorted array allows us to use two pointers technique efficiently.",
          "code": "# Approach 1: Two Pointers (Optimal)\ndef twoSum(numbers, target):\n    left, right = 0, len(numbers) - 1\n    \n    while left < right:\n        current_sum = numbers[left] + numbers[right]\n        \n        if current_sum == target:\n            return [left + 1, right + 1]  # Convert to 1-indexed\n        elif current_sum < target:\n            left += 1  # Need larger sum\n        else:\n            right -= 1  # Need smaller sum\n    \n    return []  # Should never reach here given constraints\n\n# Approach 2: Binary Search\ndef twoSum(numbers, target):\n    def binary_search(nums, target, start):\n        left, right = start, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1\n    \n    for i in range(len(numbers) - 1):\n        complement = target - numbers[i]\n        complement_index = binary_search(numbers, complement, i + 1)\n        \n        if complement_index != -1:\n            return [i + 1, complement_index + 1]\n    \n    return []\n\n# Approach 3: Hash Map (Violates space constraint but shows alternative)\ndef twoSum(numbers, target):\n    num_to_index = {}\n    \n    for i, num in enumerate(numbers):\n        complement = target - num\n        if complement in num_to_index:\n            return [num_to_index[complement] + 1, i + 1]\n        num_to_index[num] = i\n    \n    return []\n\n# Most concise two pointers solution\ndef twoSum(numbers, target):\n    l, r = 0, len(numbers) - 1\n    while l < r:\n        s = numbers[l] + numbers[r]\n        if s == target:\n            return [l + 1, r + 1]\n        elif s < target:\n            l += 1\n        else:\n            r -= 1\n\n# Test cases\ntest_cases = [\n    ([2, 7, 11, 15], 9),\n    ([2, 3, 4], 6),\n    ([-1, 0], -1),\n    ([1, 2, 3, 4, 4, 9, 56, 90], 8)\n]\n\nfor numbers, target in test_cases:\n    result = twoSum(numbers, target)\n    print(f\"numbers: {numbers}, target: {target} -> indices: {result}\")",
          "timeComplexity": "• **Two Pointers**: O(n) single pass through the array\n• **Binary Search**: O(n log n) - O(n) iterations, each with O(log n) binary search\n• **Hash Map**: O(n) but uses O(n) extra space",
          "spaceComplexity": "• **Two Pointers**: O(1) only using two pointers\n• **Binary Search**: O(1) only using variables\n• **Hash Map**: O(n) for storing elements",
          "keyInsights": "• Sorted array property enables efficient two pointers approach\n• Two pointers technique reduces time complexity from O(n²) brute force to O(n)\n• Moving pointers based on sum comparison is the key insight\n• This pattern applies to many sorted array problems\n• Remember to convert to 1-indexed output as required",
          "link": "https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/"
        },
        {
          "id": "tp_3",
          "title": "3Sum",
          "routeName": "three_sum",
          "difficulty": "Medium",
          "leetcodeNumber": 15,
          "companies": ["Facebook", "Amazon", "Google", "Microsoft"],
          "tags": ["Array", "Two Pointers", "Sorting"],
          "description": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.",
          "detailedDescription": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\n\nNotice that the solution set must not contain duplicate triplets.\n\nExample 1:\nInput: nums = [-1,0,1,2,-1,-4]\nOutput: [[-1,-1,2],[-1,0,1]]\nExplanation: \nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.\nThe distinct triplets are [-1,0,1] and [-1,-1,2].\n\nExample 2:\nInput: nums = [0,1,1]\nOutput: []\nExplanation: The only possible triplet does not sum up to 0.\n\nExample 3:\nInput: nums = [0,0,0]\nOutput: [[0,0,0]]\nExplanation: The only possible triplet sums up to 0.\n\nConstraints:\n• 3 <= nums.length <= 3000\n• -10^5 <= nums[i] <= 10^5",
          "approach": "Multiple approaches to solve this problem:\n\n1. **Sort + Two Pointers**: Sort array, fix first element, use two pointers for remaining two.\n\n2. **Brute Force**: Check all possible triplets (O(n³) - not efficient).\n\n3. **Hash Set**: Use set to track seen pairs for each fixed element.\n\n4. **No Sort Approach**: Use hash map but handling duplicates becomes complex.",
          "solution": "**Approach 1: Sort + Two Pointers (Standard Solution)**\nSort array, iterate through first element, use two pointers for the rest.\n\n**Key Insights**: \n1. Sorting helps avoid duplicates and enables two pointers\n2. Skip duplicate first elements\n3. Skip duplicate pairs in two pointers section",
          "code": "# Approach 1: Sort + Two Pointers (Standard Solution)\ndef threeSum(nums):\n    nums.sort()\n    result = []\n    \n    for i in range(len(nums) - 2):\n        # Skip duplicate first elements\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n        \n        left, right = i + 1, len(nums) - 1\n        \n        while left < right:\n            current_sum = nums[i] + nums[left] + nums[right]\n            \n            if current_sum == 0:\n                result.append([nums[i], nums[left], nums[right]])\n                \n                # Skip duplicates for left pointer\n                while left < right and nums[left] == nums[left + 1]:\n                    left += 1\n                \n                # Skip duplicates for right pointer\n                while left < right and nums[right] == nums[right - 1]:\n                    right -= 1\n                \n                left += 1\n                right -= 1\n            \n            elif current_sum < 0:\n                left += 1  # Need larger sum\n            else:\n                right -= 1  # Need smaller sum\n    \n    return result\n\n# Approach 2: More Readable Version\ndef threeSum(nums):\n    nums.sort()\n    triplets = []\n    \n    for i in range(len(nums)):\n        # Skip duplicate first elements\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n        \n        # Use two pointers for remaining elements\n        target = -nums[i]\n        left, right = i + 1, len(nums) - 1\n        \n        while left < right:\n            two_sum = nums[left] + nums[right]\n            \n            if two_sum == target:\n                triplets.append([nums[i], nums[left], nums[right]])\n                \n                # Move both pointers and skip duplicates\n                left += 1\n                right -= 1\n                \n                while left < right and nums[left] == nums[left - 1]:\n                    left += 1\n                while left < right and nums[right] == nums[right + 1]:\n                    right -= 1\n            \n            elif two_sum < target:\n                left += 1\n            else:\n                right -= 1\n    \n    return triplets\n\n# Approach 3: Using Hash Set (Less Efficient)\ndef threeSum(nums):\n    nums.sort()\n    result = set()\n    \n    for i in range(len(nums) - 2):\n        seen = set()\n        for j in range(i + 1, len(nums)):\n            complement = -(nums[i] + nums[j])\n            if complement in seen:\n                triplet = tuple(sorted([nums[i], nums[j], complement]))\n                result.add(triplet)\n            seen.add(nums[j])\n    \n    return [list(triplet) for triplet in result]\n\n# Most concise version\ndef threeSum(nums):\n    nums.sort()\n    res = []\n    for i in range(len(nums)):\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n        l, r = i + 1, len(nums) - 1\n        while l < r:\n            s = nums[i] + nums[l] + nums[r]\n            if s == 0:\n                res.append([nums[i], nums[l], nums[r]])\n                while l < r and nums[l] == nums[l + 1]:\n                    l += 1\n                while l < r and nums[r] == nums[r - 1]:\n                    r -= 1\n                l += 1\n                r -= 1\n            elif s < 0:\n                l += 1\n            else:\n                r -= 1\n    return res\n\n# Test cases\ntest_cases = [\n    [-1, 0, 1, 2, -1, -4],\n    [0, 1, 1],\n    [0, 0, 0],\n    [-2, 0, 1, 1, 2]\n]\n\nfor nums in test_cases:\n    result = threeSum(nums)\n    print(f\"Input: {nums}\")\n    print(f\"Output: {result}\\n\")",
          "timeComplexity": "O(n²) where n is the length of the array. Sorting takes O(n log n), and the main loop with two pointers takes O(n²).",
          "spaceComplexity": "O(1) if we don't count the output array. The sorting is typically done in-place.",
          "keyInsights": "• Sorting is crucial for avoiding duplicates and enabling two pointers\n• The pattern is: fix one element, use two pointers for the remaining two\n• Careful duplicate handling at multiple levels: first element and both pointers\n• This extends the two pointers pattern from 2Sum to 3Sum\n• Can be generalized to kSum problems using recursion",
          "link": "https://leetcode.com/problems/3sum/"
        },
        {
          "id": "tp_4",
          "title": "Container With Most Water",
          "routeName": "container_with_most_water",
          "difficulty": "Medium",
          "leetcodeNumber": 11,
          "companies": ["Facebook", "Amazon", "Google", "Microsoft"],
          "tags": ["Array", "Two Pointers", "Greedy"],
          "description": "You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).",
          "detailedDescription": "You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).\n\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\n\nReturn the maximum amount of water a container can store.\n\nNotice that you may not slant the container.\n\nExample 1:\nInput: height = [1,8,6,2,5,4,8,3,7]\nOutput: 49\nExplanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.\n\nExample 2:\nInput: height = [1,1]\nOutput: 1\n\nConstraints:\n• n == height.length\n• 2 <= n <= 3 * 10^4\n• 0 <= height[i] <= 3 * 10^4",
          "approach": "Multiple approaches to solve this problem:\n\n1. **Two Pointers (Greedy)**: Start from both ends, move the pointer with smaller height.\n\n2. **Brute Force**: Try all possible pairs of lines (O(n²) - not efficient).\n\n3. **Dynamic Programming**: Not applicable here as we need global optimum.\n\nThe key insight is that moving the shorter line gives us the best chance to find a larger area.",
          "solution": "**Approach 1: Two Pointers (Optimal)**\nStart with widest possible container, then move the shorter line inward.\n\n**Approach 2: Brute Force**\nCheck all possible pairs to find maximum area.\n\n**Key Insight**: Always move the pointer with the smaller height because the container's height is limited by the shorter line.",
          "code": "# Approach 1: Two Pointers (Optimal)\ndef maxArea(height):\n    left, right = 0, len(height) - 1\n    max_water = 0\n    \n    while left < right:\n        # Calculate current area\n        width = right - left\n        current_height = min(height[left], height[right])\n        current_area = width * current_height\n        \n        # Update maximum area\n        max_water = max(max_water, current_area)\n        \n        # Move the pointer with smaller height\n        if height[left] < height[right]:\n            left += 1\n        else:\n            right -= 1\n    \n    return max_water\n\n# More concise version\ndef maxArea(height):\n    l, r, max_area = 0, len(height) - 1, 0\n    \n    while l < r:\n        # Calculate area and update maximum\n        max_area = max(max_area, min(height[l], height[r]) * (r - l))\n        \n        # Move pointer with smaller height\n        if height[l] < height[r]:\n            l += 1\n        else:\n            r -= 1\n    \n    return max_area\n\n# Approach 2: Brute Force (For Understanding)\ndef maxArea(height):\n    max_water = 0\n    n = len(height)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            width = j - i\n            container_height = min(height[i], height[j])\n            area = width * container_height\n            max_water = max(max_water, area)\n    \n    return max_water\n\n# Approach 3: Two Pointers with Detailed Logic\ndef maxArea(height):\n    left, right = 0, len(height) - 1\n    max_area = 0\n    \n    while left < right:\n        # The area is determined by the shorter line\n        left_height, right_height = height[left], height[right]\n        width = right - left\n        \n        if left_height < right_height:\n            area = left_height * width\n            left += 1  # Move left pointer since it's the limiting factor\n        else:\n            area = right_height * width\n            right -= 1  # Move right pointer since it's the limiting factor\n        \n        max_area = max(max_area, area)\n    \n    return max_area\n\n# Alternative implementation with early termination optimization\ndef maxArea(height):\n    left, right = 0, len(height) - 1\n    max_area = 0\n    \n    while left < right:\n        width = right - left\n        \n        if height[left] < height[right]:\n            area = height[left] * width\n            left += 1\n        else:\n            area = height[right] * width\n            right -= 1\n        \n        max_area = max(max_area, area)\n        \n        # Early termination: if remaining width * max possible height \n        # cannot beat current max, we can stop\n        if width <= max_area // max(height):\n            break\n    \n    return max_area\n\n# Test cases\ntest_cases = [\n    [1, 8, 6, 2, 5, 4, 8, 3, 7],\n    [1, 1],\n    [4, 3, 2, 1, 4],\n    [1, 2, 1]\n]\n\nfor heights in test_cases:\n    result = maxArea(heights)\n    print(f\"Input: {heights}\")\n    print(f\"Max water: {result}\\n\")",
          "timeComplexity": "• **Two Pointers**: O(n) single pass through the array\n• **Brute Force**: O(n²) checking all possible pairs",
          "spaceComplexity": "O(1) only using a few variables for both approaches",
          "keyInsights": "• The key insight is that the container's height is always limited by the shorter line\n• Moving the taller line inward won't increase the area (width decreases, height stays same)\n• Moving the shorter line gives a chance to find a taller line and increase area\n• This is a greedy approach that works because we explore all potentially optimal solutions\n• The two pointers technique reduces time complexity from O(n²) to O(n)",
          "link": "https://leetcode.com/problems/container-with-most-water/"
        },
        {
          "id": "tp_5",
          "title": "Trapping Rain Water",
          "routeName": "trapping_rain_water",
          "difficulty": "Hard",
          "leetcodeNumber": 42,
          "companies": ["Google", "Amazon", "Facebook", "Microsoft"],
          "tags": [
            "Array",
            "Two Pointers",
            "Dynamic Programming",
            "Stack",
            "Monotonic Stack"
          ],
          "description": "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.",
          "detailedDescription": "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.\n\nExample 1:\nInput: height = [0,1,0,2,1,0,1,3,2,1,2,1]\nOutput: 6\nExplanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.\n\nExample 2:\nInput: height = [4,2,0,3,2,5]\nOutput: 9\n\nConstraints:\n• n == height.length\n• 1 <= n <= 2 * 10^4\n• 0 <= height[i] <= 3 * 10^4",
          "approach": "Multiple approaches to solve this problem:\n\n1. **Two Pointers**: Track max heights from both sides, move pointer with smaller max.\n\n2. **Dynamic Programming**: Pre-compute left and right max arrays.\n\n3. **Stack**: Use monotonic stack to find trapped water.\n\n4. **Brute Force**: For each position, find max left and right heights.",
          "solution": "**Approach 1: Two Pointers (Optimal Space)**\nUse two pointers with left_max and right_max tracking.\n\n**Approach 2: Dynamic Programming (Easier to Understand)**\nPre-compute max heights on left and right for each position.\n\n**Key Insight**: Water at position i = min(max_left[i], max_right[i]) - height[i]",
          "code": "# Approach 1: Two Pointers (Optimal - O(1) Space)\ndef trap(height):\n    if not height or len(height) < 3:\n        return 0\n    \n    left, right = 0, len(height) - 1\n    left_max = right_max = 0\n    water = 0\n    \n    while left < right:\n        if height[left] < height[right]:\n            if height[left] >= left_max:\n                left_max = height[left]\n            else:\n                water += left_max - height[left]\n            left += 1\n        else:\n            if height[right] >= right_max:\n                right_max = height[right]\n            else:\n                water += right_max - height[right]\n            right -= 1\n    \n    return water\n\n# Approach 2: Dynamic Programming (Easier to Understand)\ndef trap(height):\n    if not height:\n        return 0\n    \n    n = len(height)\n    \n    # Compute left max for each position\n    left_max = [0] * n\n    left_max[0] = height[0]\n    for i in range(1, n):\n        left_max[i] = max(left_max[i-1], height[i])\n    \n    # Compute right max for each position\n    right_max = [0] * n\n    right_max[n-1] = height[n-1]\n    for i in range(n-2, -1, -1):\n        right_max[i] = max(right_max[i+1], height[i])\n    \n    # Calculate trapped water\n    water = 0\n    for i in range(n):\n        water_level = min(left_max[i], right_max[i])\n        if water_level > height[i]:\n            water += water_level - height[i]\n    \n    return water\n\n# Approach 3: Using Stack (Alternative Solution)\ndef trap(height):\n    stack = []\n    water = 0\n    \n    for i, h in enumerate(height):\n        while stack and height[stack[-1]] < h:\n            bottom = stack.pop()\n            if not stack:\n                break\n            \n            width = i - stack[-1] - 1\n            bounded_height = min(height[stack[-1]], h) - height[bottom]\n            water += width * bounded_height\n        \n        stack.append(i)\n    \n    return water\n\n# Approach 4: Brute Force (For Understanding)\ndef trap(height):\n    n = len(height)\n    water = 0\n    \n    for i in range(1, n - 1):  # Skip first and last positions\n        # Find max height on the left\n        left_max = max(height[:i+1])\n        \n        # Find max height on the right\n        right_max = max(height[i:])\n        \n        # Water level at position i\n        water_level = min(left_max, right_max)\n        \n        # Add trapped water if any\n        if water_level > height[i]:\n            water += water_level - height[i]\n    \n    return water\n\n# Most concise two pointers solution\ndef trap(height):\n    left, right = 0, len(height) - 1\n    left_max = right_max = water = 0\n    \n    while left < right:\n        if height[left] < height[right]:\n            if height[left] >= left_max:\n                left_max = height[left]\n            else:\n                water += left_max - height[left]\n            left += 1\n        else:\n            if height[right] >= right_max:\n                right_max = height[right]\n            else:\n                water += right_max - height[right]\n            right -= 1\n    \n    return water\n\n# Test cases\ntest_cases = [\n    [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1],\n    [4, 2, 0, 3, 2, 5],\n    [3, 0, 2, 0, 4],\n    []\n]\n\nfor heights in test_cases:\n    result = trap(heights)\n    print(f\"Input: {heights}\")\n    print(f\"Trapped water: {result}\\n\")",
          "timeComplexity": "• **Two Pointers**: O(n) single pass through the array\n• **Dynamic Programming**: O(n) with three passes\n• **Stack**: O(n) each element pushed and popped at most once\n• **Brute Force**: O(n²) for each position, scan left and right",
          "spaceComplexity": "• **Two Pointers**: O(1) only using a few variables\n• **Dynamic Programming**: O(n) for left_max and right_max arrays\n• **Stack**: O(n) for the stack in worst case\n• **Brute Force**: O(1) only using variables",
          "keyInsights": "• Water level at any position is determined by the minimum of max heights on left and right\n• Two pointers approach optimizes space by avoiding pre-computation of max arrays\n• The key insight is that we can process from both ends simultaneously\n• When left height < right height, we can safely calculate water at left position\n• This problem combines multiple algorithmic techniques: two pointers, DP, and stack",
          "link": "https://leetcode.com/problems/trapping-rain-water/"
        }
      ]
    },
    {
      "id": "sliding-window",
      "title": "Sliding Window",
      "description": "Sliding window technique for subarray and substring problems",
      "questions": [
        {
          "id": "sw_1",
          "title": "Best Time to Buy and Sell Stock",
          "routeName": "best_time_to_buy_and_sell_stock",
          "difficulty": "Easy",
          "leetcodeNumber": 121,
          "companies": ["Amazon", "Microsoft", "Facebook", "Apple"],
          "tags": ["Array", "Dynamic Programming"],
          "description": "You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.",
          "detailedDescription": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\n\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\n\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.\n\nExample 1:\nInput: prices = [7,1,5,3,6,4]\nOutput: 5\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\n\nExample 2:\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: In this case, no transactions are done and the max profit = 0.\n\nConstraints:\n• 1 <= prices.length <= 10^5\n• 0 <= prices[i] <= 10^4",
          "approach": "Multiple approaches to solve this problem:\n\n1. **One Pass (Sliding Window)**: Track minimum price seen so far and maximum profit.\n\n2. **Brute Force**: Check all possible buy-sell combinations (O(n²) - not efficient).\n\n3. **Dynamic Programming**: Define states for holding and not holding stock.\n\n4. **Kadane's Algorithm Variant**: Transform to maximum subarray problem.",
          "solution": "**Approach 1: One Pass (Optimal)**\nTrack the minimum price encountered and calculate profit at each step.\n\n**Approach 2: Kadane's Algorithm**\nTransform the problem into finding maximum subarray sum of price differences.\n\n**Key Insight**: At each day, we either buy (if current price is minimum so far) or sell (if profit is maximum so far).",
          "code": "# Approach 1: One Pass - Sliding Window (Most Efficient)\ndef maxProfit(prices):\n    min_price = float('inf')\n    max_profit = 0\n    \n    for price in prices:\n        # Update minimum price seen so far\n        min_price = min(min_price, price)\n        \n        # Calculate profit if we sell at current price\n        current_profit = price - min_price\n        \n        # Update maximum profit\n        max_profit = max(max_profit, current_profit)\n    \n    return max_profit\n\n# Approach 2: More Explicit Version\ndef maxProfit(prices):\n    if not prices or len(prices) < 2:\n        return 0\n    \n    min_price = prices[0]\n    max_profit = 0\n    \n    for i in range(1, len(prices)):\n        # If current price is lower, update min_price\n        if prices[i] < min_price:\n            min_price = prices[i]\n        else:\n            # Calculate profit and update max_profit\n            profit = prices[i] - min_price\n            max_profit = max(max_profit, profit)\n    \n    return max_profit\n\n# Approach 3: Kadane's Algorithm Variant\ndef maxProfit(prices):\n    max_profit = 0\n    min_price = float('inf')\n    \n    for price in prices:\n        min_price = min(min_price, price)\n        max_profit = max(max_profit, price - min_price)\n    \n    return max_profit\n\n# Approach 4: Dynamic Programming\ndef maxProfit(prices):\n    if not prices:\n        return 0\n    \n    # hold[i] = max profit on day i when holding stock\n    # sold[i] = max profit on day i when not holding stock\n    hold = -prices[0]  # Buy on first day\n    sold = 0           # No stock on first day\n    \n    for i in range(1, len(prices)):\n        hold = max(hold, -prices[i])  # Buy today or keep previous\n        sold = max(sold, hold + prices[i])  # Sell today or keep previous\n    \n    return sold\n\n# Approach 5: Brute Force (For Understanding)\ndef maxProfit(prices):\n    max_profit = 0\n    \n    for i in range(len(prices)):\n        for j in range(i + 1, len(prices)):\n            profit = prices[j] - prices[i]\n            max_profit = max(max_profit, profit)\n    \n    return max_profit\n\n# Test cases\ntest_cases = [\n    [7, 1, 5, 3, 6, 4],\n    [7, 6, 4, 3, 1],\n    [1, 2, 3, 4, 5],\n    [5],\n    []\n]\n\nfor prices in test_cases:\n    result = maxProfit(prices)\n    print(f\"Prices: {prices} -> Max Profit: {result}\")",
          "timeComplexity": "• **One Pass**: O(n) single pass through the array\n• **Dynamic Programming**: O(n) single pass\n• **Brute Force**: O(n²) checking all pairs",
          "spaceComplexity": "• **One Pass**: O(1) only using two variables\n• **Dynamic Programming**: O(1) using constant space\n• **Brute Force**: O(1) only using variables",
          "keyInsights": "• The key insight is that we need to track the minimum price seen so far\n• At each price, calculate the profit if we sell at that price\n• This is essentially a sliding window where we expand the right boundary and shrink from left when beneficial\n• The problem can be transformed into finding maximum subarray sum\n• Only one transaction is allowed, making the solution simpler than multiple transactions",
          "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock/"
        },
        {
          "id": "sw_2",
          "title": "Longest Substring Without Repeating Characters",
          "routeName": "longest_substring_without_repeating_characters",
          "difficulty": "Medium",
          "leetcodeNumber": 3,
          "companies": ["Amazon", "Facebook", "Google", "Microsoft"],
          "tags": ["Hash Table", "String", "Sliding Window"],
          "description": "Given a string s, find the length of the longest substring without repeating characters.",
          "detailedDescription": "Given a string s, find the length of the longest substring without repeating characters.\n\nExample 1:\nInput: s = \"abcabcbb\"\nOutput: 3\nExplanation: The answer is \"abc\", with the length of 3.\n\nExample 2:\nInput: s = \"bbbbb\"\nOutput: 1\nExplanation: The answer is \"b\", with the length of 1.\n\nExample 3:\nInput: s = \"pwwkew\"\nOutput: 3\nExplanation: The answer is \"wke\", with the length of 3.\nNotice that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\n\nConstraints:\n• 0 <= s.length <= 5 * 10^4\n• s consists of English letters, digits, symbols and spaces.",
          "approach": "Multiple approaches to solve this problem:\n\n1. **Sliding Window with Hash Map**: Use two pointers and hash map to track character positions.\n\n2. **Sliding Window with Set**: Use set to track characters in current window.\n\n3. **Brute Force**: Check all possible substrings (O(n³) - not efficient).\n\n4. **Optimized Sliding Window**: Jump directly to the next valid position when duplicate found.",
          "solution": "**Approach 1: Sliding Window with Hash Map (Optimal)**\nUse hash map to store character positions and jump start pointer efficiently.\n\n**Approach 2: Sliding Window with Set**\nUse set to track characters and shrink window when duplicate found.\n\n**Key Insight**: Maintain a sliding window and expand/shrink based on character uniqueness.",
          "code": "# Approach 1: Sliding Window with Hash Map (Most Efficient)\ndef lengthOfLongestSubstring(s):\n    char_map = {}  # char -> last seen index\n    start = 0\n    max_length = 0\n    \n    for end, char in enumerate(s):\n        # If character is in current window, move start\n        if char in char_map and char_map[char] >= start:\n            start = char_map[char] + 1\n        \n        # Update character position\n        char_map[char] = end\n        \n        # Update max length\n        max_length = max(max_length, end - start + 1)\n    \n    return max_length\n\n# Approach 2: Sliding Window with Set\ndef lengthOfLongestSubstring(s):\n    char_set = set()\n    start = 0\n    max_length = 0\n    \n    for end in range(len(s)):\n        # Shrink window until no duplicate\n        while s[end] in char_set:\n            char_set.remove(s[start])\n            start += 1\n        \n        # Add current character\n        char_set.add(s[end])\n        \n        # Update max length\n        max_length = max(max_length, end - start + 1)\n    \n    return max_length\n\n# Approach 3: More Explicit Sliding Window\ndef lengthOfLongestSubstring(s):\n    if not s:\n        return 0\n    \n    seen = {}\n    left = 0\n    max_len = 0\n    \n    for right in range(len(s)):\n        char = s[right]\n        \n        # If character seen before and within current window\n        if char in seen and seen[char] >= left:\n            left = seen[char] + 1\n        \n        seen[char] = right\n        max_len = max(max_len, right - left + 1)\n    \n    return max_len\n\n# Approach 4: Using collections.defaultdict\nfrom collections import defaultdict\n\ndef lengthOfLongestSubstring(s):\n    char_count = defaultdict(int)\n    left = 0\n    max_length = 0\n    \n    for right in range(len(s)):\n        char_count[s[right]] += 1\n        \n        # Shrink window if we have duplicates\n        while char_count[s[right]] > 1:\n            char_count[s[left]] -= 1\n            if char_count[s[left]] == 0:\n                del char_count[s[left]]\n            left += 1\n        \n        max_length = max(max_length, right - left + 1)\n    \n    return max_length\n\n# Approach 5: Brute Force (For Understanding)\ndef lengthOfLongestSubstring(s):\n    def has_duplicate(substr):\n        return len(set(substr)) != len(substr)\n    \n    n = len(s)\n    max_length = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            substr = s[i:j]\n            if not has_duplicate(substr):\n                max_length = max(max_length, len(substr))\n    \n    return max_length\n\n# Test cases\ntest_cases = [\n    \"abcabcbb\",\n    \"bbbbb\",\n    \"pwwkew\",\n    \"\",\n    \"au\",\n    \"dvdf\"\n]\n\nfor s in test_cases:\n    result = lengthOfLongestSubstring(s)\n    print(f\"Input: '{s}' -> Length: {result}\")",
          "timeComplexity": "• **Sliding Window with Hash Map**: O(n) each character visited at most twice\n• **Sliding Window with Set**: O(n) amortized, O(2n) worst case\n• **Brute Force**: O(n³) checking all substrings",
          "spaceComplexity": "• **Hash Map approach**: O(min(m, n)) where m is character set size\n• **Set approach**: O(min(m, n)) for the set\n• **Brute Force**: O(min(m, n)) for duplicate checking",
          "keyInsights": "• Sliding window technique is perfect for contiguous subarray/substring problems\n• Hash map optimization allows jumping directly to next valid position\n• The key is maintaining a window of unique characters\n• Two pointers represent the current window boundaries\n• This pattern applies to many substring optimization problems",
          "link": "https://leetcode.com/problems/longest-substring-without-repeating-characters/"
        },
        {
          "id": "sw_3",
          "title": "Longest Repeating Character Replacement",
          "routeName": "longest_repeating_character_replacement",
          "difficulty": "Medium",
          "leetcodeNumber": 424,
          "companies": ["Google", "Amazon", "Microsoft", "Facebook"],
          "tags": ["Hash Table", "String", "Sliding Window"],
          "description": "You are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English letter. You can perform this operation at most k times.",
          "detailedDescription": "You are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English letter. You can perform this operation at most k times.\n\nReturn the length of the longest substring containing the same letter you can get after performing the above operations.\n\nExample 1:\nInput: s = \"ABAB\", k = 2\nOutput: 4\nExplanation: Replace the two 'A's with two 'B's or vice versa.\n\nExample 2:\nInput: s = \"AABABBA\", k = 1\nOutput: 4\nExplanation: Replace the one 'A' in the middle with 'B' and form \"AABBBBA\".\nThe substring \"BBBB\" has the longest repeating letters, which is 4.\n\nConstraints:\n• 1 <= s.length <= 10^5\n• s consists of only uppercase English letters.\n• 0 <= k <= s.length",
          "approach": "Multiple approaches to solve this problem:\n\n1. **Sliding Window with Character Count**: Track character frequencies and maintain valid window.\n\n2. **Sliding Window with Max Count Optimization**: Track the maximum frequency character.\n\n3. **Brute Force**: Check all possible substrings (O(n²) - not efficient).",
          "solution": "**Approach 1: Sliding Window with Character Count**\nMaintain a window where (window_size - max_frequency) <= k.\n\n**Approach 2: Optimized Sliding Window**\nTrack maximum frequency to avoid recalculating each time.\n\n**Key Insight**: A window is valid if we can change at most k characters to make all characters the same.",
          "code": "# Approach 1: Sliding Window with Character Count (Most Efficient)\ndef characterReplacement(s, k):\n    count = {}  # character frequency in current window\n    left = 0\n    max_length = 0\n    max_count = 0  # maximum frequency of any character in current window\n    \n    for right in range(len(s)):\n        # Add current character to window\n        count[s[right]] = count.get(s[right], 0) + 1\n        max_count = max(max_count, count[s[right]])\n        \n        # Check if current window is valid\n        # Window is valid if: window_size - max_frequency <= k\n        window_size = right - left + 1\n        if window_size - max_count > k:\n            # Shrink window from left\n            count[s[left]] -= 1\n            left += 1\n        \n        # Update maximum length\n        max_length = max(max_length, right - left + 1)\n    \n    return max_length\n\n# Approach 2: More Explicit Version\ndef characterReplacement(s, k):\n    char_count = {}\n    left = 0\n    max_len = 0\n    \n    for right in range(len(s)):\n        # Expand window by including s[right]\n        char_count[s[right]] = char_count.get(s[right], 0) + 1\n        \n        # Find the maximum frequency in current window\n        max_freq = max(char_count.values())\n        \n        # Current window size\n        window_size = right - left + 1\n        \n        # If we need to change more than k characters, shrink window\n        if window_size - max_freq > k:\n            char_count[s[left]] -= 1\n            if char_count[s[left]] == 0:\n                del char_count[s[left]]\n            left += 1\n        \n        # Update maximum length\n        max_len = max(max_len, right - left + 1)\n    \n    return max_len\n\n# Approach 3: Using collections.defaultdict\nfrom collections import defaultdict\n\ndef characterReplacement(s, k):\n    count = defaultdict(int)\n    left = 0\n    max_count = 0\n    result = 0\n    \n    for right in range(len(s)):\n        count[s[right]] += 1\n        max_count = max(max_count, count[s[right]])\n        \n        # If current window is invalid, shrink it\n        while (right - left + 1) - max_count > k:\n            count[s[left]] -= 1\n            left += 1\n            # Note: We don't update max_count here for efficiency\n            # It's still correct because max_count will only affect\n            # the window size, and we'll get the right answer\n        \n        result = max(result, right - left + 1)\n    \n    return result\n\n# Approach 4: Brute Force (For Understanding)\ndef characterReplacement(s, k):\n    def can_make_same(substr, k):\n        char_count = {}\n        for char in substr:\n            char_count[char] = char_count.get(char, 0) + 1\n        \n        max_freq = max(char_count.values())\n        return len(substr) - max_freq <= k\n    \n    max_length = 0\n    n = len(s)\n    \n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            substr = s[i:j]\n            if can_make_same(substr, k):\n                max_length = max(max_length, len(substr))\n    \n    return max_length\n\n# Optimized version with early max_count tracking\ndef characterReplacement(s, k):\n    count = {}\n    left = max_count = max_len = 0\n    \n    for right in range(len(s)):\n        count[s[right]] = count.get(s[right], 0) + 1\n        max_count = max(max_count, count[s[right]])\n        \n        if (right - left + 1) - max_count > k:\n            count[s[left]] -= 1\n            left += 1\n        \n        max_len = max(max_len, right - left + 1)\n    \n    return max_len\n\n# Test cases\ntest_cases = [\n    (\"ABAB\", 2),\n    (\"AABABBA\", 1),\n    (\"AAAA\", 2),\n    (\"ABCDE\", 1),\n    (\"KRSCDCSONAJNHLBMDQGIFCPEKPOHQIHLTDIQGEKLRLCQNBOHNDQGHJPNDQPERNFSSSRDEQLFPCCCARFMDLHADJADAGNNSBNCJQOF\", 4)\n]\n\nfor s, k in test_cases:\n    result = characterReplacement(s, k)\n    print(f\"String: '{s}', k: {k} -> Max Length: {result}\")",
          "timeComplexity": "O(n) where n is the length of the string. Each character is visited at most twice (once by right pointer, once by left pointer).",
          "spaceComplexity": "O(1) since we're dealing with at most 26 uppercase English letters, the hash map size is constant.",
          "keyInsights": "• The key insight is that a window is valid if (window_size - max_frequency) <= k\n• We don't need to recalculate max_count when shrinking window for efficiency\n• Sliding window technique helps maintain the longest valid substring\n• The max_count optimization prevents us from recalculating the maximum frequency every time\n• This problem demonstrates how sliding window can handle constraint-based optimization",
          "link": "https://leetcode.com/problems/longest-repeating-character-replacement/"
        },
        {
          "id": "sw_4",
          "title": "Permutation in String",
          "routeName": "permutation_in_string",
          "difficulty": "Medium",
          "leetcodeNumber": 567,
          "companies": ["Microsoft", "Facebook", "Amazon", "Google"],
          "tags": ["Hash Table", "Two Pointers", "String", "Sliding Window"],
          "description": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.",
          "detailedDescription": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.\n\nExample 1:\nInput: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: true\nExplanation: s2 contains one permutation of s1 (\"ba\").\n\nExample 2:\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: false\n\nConstraints:\n• 1 <= s1.length, s2.length <= 10^4\n• s1 and s2 consist of lowercase English letters.",
          "approach": "Multiple approaches to solve this problem:\n\n1. **Sliding Window with Counter**: Use sliding window of s1 length and compare character counts.\n\n2. **Sliding Window with Hash Map**: Maintain character frequencies in current window.\n\n3. **Sorting**: Sort s1 and check if any substring of s2 with same length has same sorted characters.\n\n4. **Brute Force**: Generate all permutations of s1 and check if any exists in s2.",
          "solution": "**Approach 1: Sliding Window with Counter (Optimal)**\nMaintain a sliding window of s1's length and compare character frequencies.\n\n**Approach 2: Hash Map Sliding Window**\nTrack character counts and adjust window dynamically.\n\n**Key Insight**: Two strings are permutations if they have the same character frequencies.",
          "code": "# Approach 1: Sliding Window with Counter (Most Efficient)\nfrom collections import Counter\n\ndef checkInclusion(s1, s2):\n    if len(s1) > len(s2):\n        return False\n    \n    s1_count = Counter(s1)\n    window_size = len(s1)\n    \n    # Initialize window\n    window_count = Counter(s2[:window_size])\n    \n    # Check first window\n    if s1_count == window_count:\n        return True\n    \n    # Slide the window\n    for i in range(window_size, len(s2)):\n        # Add new character\n        window_count[s2[i]] += 1\n        \n        # Remove old character\n        left_char = s2[i - window_size]\n        window_count[left_char] -= 1\n        if window_count[left_char] == 0:\n            del window_count[left_char]\n        \n        # Check if current window matches\n        if s1_count == window_count:\n            return True\n    \n    return False\n\n# Approach 2: Sliding Window with Manual Counter\ndef checkInclusion(s1, s2):\n    if len(s1) > len(s2):\n        return False\n    \n    # Count characters in s1\n    s1_count = {}\n    for char in s1:\n        s1_count[char] = s1_count.get(char, 0) + 1\n    \n    window_size = len(s1)\n    window_count = {}\n    left = 0\n    \n    for right in range(len(s2)):\n        # Add character to window\n        char = s2[right]\n        window_count[char] = window_count.get(char, 0) + 1\n        \n        # Maintain window size\n        if right - left + 1 > window_size:\n            left_char = s2[left]\n            window_count[left_char] -= 1\n            if window_count[left_char] == 0:\n                del window_count[left_char]\n            left += 1\n        \n        # Check if window matches s1\n        if window_count == s1_count:\n            return True\n    \n    return False\n\n# Approach 3: Using Array for Character Counting (For lowercase letters only)\ndef checkInclusion(s1, s2):\n    if len(s1) > len(s2):\n        return False\n    \n    # Character count arrays\n    s1_count = [0] * 26\n    window_count = [0] * 26\n    \n    # Count characters in s1\n    for char in s1:\n        s1_count[ord(char) - ord('a')] += 1\n    \n    window_size = len(s1)\n    \n    # Process first window\n    for i in range(window_size):\n        window_count[ord(s2[i]) - ord('a')] += 1\n    \n    # Check first window\n    if s1_count == window_count:\n        return True\n    \n    # Slide the window\n    for i in range(window_size, len(s2)):\n        # Add new character\n        window_count[ord(s2[i]) - ord('a')] += 1\n        \n        # Remove old character\n        window_count[ord(s2[i - window_size]) - ord('a')] -= 1\n        \n        # Check current window\n        if s1_count == window_count:\n            return True\n    \n    return False\n\n# Approach 4: Sorting Approach\ndef checkInclusion(s1, s2):\n    if len(s1) > len(s2):\n        return False\n    \n    s1_sorted = ''.join(sorted(s1))\n    window_size = len(s1)\n    \n    for i in range(len(s2) - window_size + 1):\n        window = s2[i:i + window_size]\n        if ''.join(sorted(window)) == s1_sorted:\n            return True\n    \n    return False\n\n# Approach 5: Optimized with matches count\ndef checkInclusion(s1, s2):\n    if len(s1) > len(s2):\n        return False\n    \n    s1_count = Counter(s1)\n    window_count = Counter()\n    \n    left = 0\n    required = len(s1_count)\n    formed = 0\n    \n    for right in range(len(s2)):\n        char = s2[right]\n        window_count[char] += 1\n        \n        if char in s1_count and window_count[char] == s1_count[char]:\n            formed += 1\n        \n        # Maintain window size\n        while right - left + 1 > len(s1):\n            char = s2[left]\n            if char in s1_count and window_count[char] == s1_count[char]:\n                formed -= 1\n            window_count[char] -= 1\n            if window_count[char] == 0:\n                del window_count[char]\n            left += 1\n        \n        if formed == required and right - left + 1 == len(s1):\n            return True\n    \n    return False\n\n# Test cases\ntest_cases = [\n    (\"ab\", \"eidbaooo\"),\n    (\"ab\", \"eidboaoo\"),\n    (\"adc\", \"dcda\"),\n    (\"hello\", \"ooolleoooleh\"),\n    (\"abc\", \"bbbca\")\n]\n\nfor s1, s2 in test_cases:\n    result = checkInclusion(s1, s2)\n    print(f\"s1: '{s1}', s2: '{s2}' -> {result}\")",
          "timeComplexity": "• **Sliding Window**: O(|s1| + |s2|) single pass through s2 with constant time operations\n• **Sorting Approach**: O(|s1| * log|s1| * (|s2| - |s1|)) sorting each window\n• **Array Counting**: O(|s1| + |s2|) with O(1) comparison for each window",
          "spaceComplexity": "• **Counter/Hash Map**: O(|s1|) for storing character frequencies\n• **Array Counting**: O(1) since we only need arrays of size 26\n• **Sorting**: O(|s1|) for sorted strings",
          "keyInsights": "• Two strings are permutations if they have identical character frequencies\n• Sliding window of fixed size |s1| is perfect for this problem\n• Counter comparison in Python is efficient for this use case\n• Array-based counting is more space-efficient for known character sets\n• The key optimization is maintaining window size and sliding efficiently",
          "link": "https://leetcode.com/problems/permutation-in-string/"
        },
        {
          "id": "sw_5",
          "title": "Minimum Window Substring",
          "routeName": "minimum_window_substring",
          "difficulty": "Hard",
          "leetcodeNumber": 76,
          "companies": ["Facebook", "Amazon", "Google", "Microsoft"],
          "tags": ["Hash Table", "String", "Sliding Window"],
          "description": "Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window.",
          "detailedDescription": "Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such window in s that covers all characters in t, return the empty string \"\".\n\nNote that If there is such a window, it is guaranteed that there will always be only one unique minimum window in s.\n\nExample 1:\nInput: s = \"ADOBECODEBANC\", t = \"ABC\"\nOutput: \"BANC\"\nExplanation: The minimum window substring \"BANC\" includes 'A', 'B', and 'C' from string t.\n\nExample 2:\nInput: s = \"a\", t = \"a\"\nOutput: \"a\"\nExplanation: The entire string s is the minimum window.\n\nExample 3:\nInput: s = \"a\", t = \"aa\"\nOutput: \"\"\nExplanation: Both 'a's from t must be included in the window.\nSince the largest window of s only has one 'a', return empty string.\n\nConstraints:\n• m == s.length\n• n == t.length\n• 1 <= m, n <= 10^5\n• s and t consist of uppercase and lowercase English letters.",
          "approach": "Multiple approaches to solve this problem:\n\n1. **Sliding Window with Two Pointers**: Expand right to include all characters, then shrink from left.\n\n2. **Sliding Window with Counter**: Track required and formed character counts.\n\n3. **Brute Force**: Check all possible substrings (O(n³) - not efficient).",
          "solution": "**Approach 1: Sliding Window with Two Pointers**\nExpand window until all characters are included, then try to shrink from left.\n\n**Approach 2: Optimized with Character Tracking**\nTrack how many unique characters from t are satisfied in current window.\n\n**Key Insight**: Use expandable-shrinkable sliding window pattern.",
          "code": "# Approach 1: Sliding Window with Counter (Most Efficient)\nfrom collections import Counter\n\ndef minWindow(s, t):\n    if not s or not t or len(s) < len(t):\n        return \"\"\n    \n    # Character frequency in t\n    required = Counter(t)\n    required_count = len(required)\n    \n    # Sliding window variables\n    left = right = 0\n    formed = 0  # Number of unique chars in window with desired frequency\n    \n    # Window character frequency\n    window_counts = {}\n    \n    # Result\n    min_len = float('inf')\n    min_left = 0\n    \n    while right < len(s):\n        # Add character from right to window\n        char = s[right]\n        window_counts[char] = window_counts.get(char, 0) + 1\n        \n        # Check if frequency matches required frequency\n        if char in required and window_counts[char] == required[char]:\n            formed += 1\n        \n        # Try to shrink window from left\n        while left <= right and formed == required_count:\n            char = s[left]\n            \n            # Update result if this window is smaller\n            if right - left + 1 < min_len:\n                min_len = right - left + 1\n                min_left = left\n            \n            # Remove leftmost character\n            window_counts[char] -= 1\n            if char in required and window_counts[char] < required[char]:\n                formed -= 1\n            \n            left += 1\n        \n        right += 1\n    \n    return \"\" if min_len == float('inf') else s[min_left:min_left + min_len]\n\n# Approach 2: Alternative Implementation\ndef minWindow(s, t):\n    from collections import defaultdict\n    \n    if not s or not t:\n        return \"\"\n    \n    # Dictionary to keep count of all unique characters in t\n    dict_t = defaultdict(int)\n    for char in t:\n        dict_t[char] += 1\n    \n    required = len(dict_t)\n    left = right = 0\n    formed = 0\n    window_counts = defaultdict(int)\n    \n    # ans list: (window length, left, right)\n    ans = float('inf'), None, None\n    \n    while right < len(s):\n        # Add one character from the right to the window\n        character = s[right]\n        window_counts[character] += 1\n        \n        # If the frequency of the current character added equals to the\n        # desired count in t then increment the formed count by 1\n        if character in dict_t and window_counts[character] == dict_t[character]:\n            formed += 1\n        \n        # Try to contract the window till it ceases to be 'desirable'\n        while left <= right and formed == required:\n            character = s[left]\n            \n            # Save the smallest window until now\n            if right - left + 1 < ans[0]:\n                ans = (right - left + 1, left, right)\n            \n            # The character at the left pointer is no longer part of the window\n            window_counts[character] -= 1\n            if character in dict_t and window_counts[character] < dict_t[character]:\n                formed -= 1\n            \n            # Move the left pointer ahead for the next iteration\n            left += 1\n        \n        # Keep expanding the window by moving right pointer\n        right += 1\n    \n    return \"\" if ans[0] == float('inf') else s[ans[1]:ans[2] + 1]\n\n# Approach 3: Simplified Version\ndef minWindow(s, t):\n    if len(s) < len(t):\n        return \"\"\n    \n    need = Counter(t)\n    missing = len(t)\n    left = start = end = 0\n    \n    for right, char in enumerate(s):\n        # Expand window\n        if need[char] > 0:\n            missing -= 1\n        need[char] -= 1\n        \n        # Contract window\n        while missing == 0:\n            if end == 0 or right - left + 1 < end - start + 1:\n                start, end = left, right + 1\n            \n            need[s[left]] += 1\n            if need[s[left]] > 0:\n                missing += 1\n            left += 1\n    \n    return s[start:end]\n\n# Approach 4: Brute Force (For Understanding)\ndef minWindow(s, t):\n    def contains_all(window, target):\n        target_count = Counter(target)\n        window_count = Counter(window)\n        \n        for char, count in target_count.items():\n            if window_count[char] < count:\n                return False\n        return True\n    \n    min_window = \"\"\n    min_len = float('inf')\n    \n    for i in range(len(s)):\n        for j in range(i + len(t), len(s) + 1):\n            window = s[i:j]\n            if contains_all(window, t) and len(window) < min_len:\n                min_len = len(window)\n                min_window = window\n    \n    return min_window\n\n# Test cases\ntest_cases = [\n    (\"ADOBECODEBANC\", \"ABC\"),\n    (\"a\", \"a\"),\n    (\"a\", \"aa\"),\n    (\"ab\", \"b\"),\n    (\"bba\", \"ab\")\n]\n\nfor s, t in test_cases:\n    result = minWindow(s, t)\n    print(f\"s: '{s}', t: '{t}' -> Minimum window: '{result}'\")",
          "timeComplexity": "O(|s| + |t|) where each character in s and t is visited at most twice (once by right pointer, once by left pointer).",
          "spaceComplexity": "O(|s| + |t|) for the hash maps storing character frequencies. In the worst case, we might store all unique characters from both strings.",
          "keyInsights": "• Use expandable-shrinkable sliding window: expand to include all characters, then shrink to find minimum\n• Track 'formed' count to know when window contains all required characters\n• The key insight is that we only shrink when we have a valid window\n• Counter/hash map comparison is essential for checking character requirements\n• This pattern applies to many substring problems with character constraints",
          "link": "https://leetcode.com/problems/minimum-window-substring/"
        },
        {
          "id": "sw_6",
          "title": "Sliding Window Maximum",
          "routeName": "sliding_window_maximum",
          "difficulty": "Hard",
          "leetcodeNumber": 239,
          "companies": ["Amazon", "Google", "Facebook", "Microsoft"],
          "tags": [
            "Array",
            "Queue",
            "Sliding Window",
            "Heap",
            "Monotonic Queue"
          ],
          "description": "You are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right.",
          "detailedDescription": "You are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.\n\nReturn the max sliding window.\n\nExample 1:\nInput: nums = [1,3,-1,-3,5,3,6,7], k = 3\nOutput: [3,3,5,5,6,7]\nExplanation: \nWindow position                Max\n---------------               -----\n[1  3  -1] -3  5  3  6  7       3\n 1 [3  -1  -3] 5  3  6  7       3\n 1  3 [-1  -3  5] 3  6  7       5\n 1  3  -1 [-3  5  3] 6  7       5\n 1  3  -1  -3 [5  3  6] 7       6\n 1  3  -1  -3  5 [3  6  7]      7\n\nExample 2:\nInput: nums = [1], k = 1\nOutput: [1]\n\nConstraints:\n• 1 <= nums.length <= 10^5\n• -10^4 <= nums[i] <= 10^4\n• 1 <= k <= nums.length",
          "approach": "Multiple approaches to solve this problem:\n\n1. **Monotonic Deque**: Use deque to maintain elements in decreasing order.\n\n2. **Max Heap**: Use priority queue to track maximum elements.\n\n3. **Brute Force**: For each window, find maximum (O(nk) - not efficient).\n\n4. **Segment Tree**: Build segment tree for range maximum queries.",
          "solution": "**Approach 1: Monotonic Deque (Optimal)**\nMaintain a deque with indices in decreasing order of their values.\n\n**Approach 2: Max Heap**\nUse heap to track maximum, but need to handle stale elements.\n\n**Key Insight**: Monotonic deque ensures the front always contains the maximum of current window.",
          "code": "# Approach 1: Monotonic Deque (Most Efficient)\nfrom collections import deque\n\ndef maxSlidingWindow(nums, k):\n    if not nums or k <= 0:\n        return []\n    \n    dq = deque()  # Store indices\n    result = []\n    \n    for i in range(len(nums)):\n        # Remove indices that are out of current window\n        while dq and dq[0] <= i - k:\n            dq.popleft()\n        \n        # Remove indices whose corresponding values are smaller than nums[i]\n        while dq and nums[dq[-1]] < nums[i]:\n            dq.pop()\n        \n        # Add current index\n        dq.append(i)\n        \n        # Add maximum of current window to result\n        if i >= k - 1:\n            result.append(nums[dq[0]])\n    \n    return result\n\n# Approach 2: Using Max Heap\nimport heapq\n\ndef maxSlidingWindow(nums, k):\n    if not nums or k <= 0:\n        return []\n    \n    # Max heap (negate values for max heap behavior)\n    heap = []\n    result = []\n    \n    for i in range(len(nums)):\n        # Add current element to heap\n        heapq.heappush(heap, (-nums[i], i))\n        \n        # Remove elements outside current window\n        while heap and heap[0][1] <= i - k:\n            heapq.heappop(heap)\n        \n        # Add maximum of current window to result\n        if i >= k - 1:\n            result.append(-heap[0][0])\n    \n    return result\n\n# Approach 3: Brute Force (For Understanding)\ndef maxSlidingWindow(nums, k):\n    if not nums or k <= 0:\n        return []\n    \n    result = []\n    \n    for i in range(len(nums) - k + 1):\n        window_max = max(nums[i:i+k])\n        result.append(window_max)\n    \n    return result\n\n# Approach 4: Optimized Deque with Clean Logic\ndef maxSlidingWindow(nums, k):\n    dq = deque()\n    result = []\n    \n    for i, num in enumerate(nums):\n        # Remove elements outside window\n        if dq and dq[0] == i - k:\n            dq.popleft()\n        \n        # Maintain decreasing order in deque\n        while dq and nums[dq[-1]] <= num:\n            dq.pop()\n        \n        dq.append(i)\n        \n        # Add to result when window is complete\n        if i >= k - 1:\n            result.append(nums[dq[0]])\n    \n    return result\n\n# Approach 5: Using Segment Tree (Advanced)\nclass SegmentTree:\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.arr = arr\n        self.build(1, 0, self.n - 1)\n    \n    def build(self, v, tl, tr):\n        if tl == tr:\n            self.tree[v] = self.arr[tl]\n        else:\n            tm = (tl + tr) // 2\n            self.build(2*v, tl, tm)\n            self.build(2*v+1, tm+1, tr)\n            self.tree[v] = max(self.tree[2*v], self.tree[2*v+1])\n    \n    def query(self, v, tl, tr, l, r):\n        if l > r:\n            return float('-inf')\n        if l == tl and r == tr:\n            return self.tree[v]\n        tm = (tl + tr) // 2\n        return max(\n            self.query(2*v, tl, tm, l, min(r, tm)),\n            self.query(2*v+1, tm+1, tr, max(l, tm+1), r)\n        )\n    \n    def range_max(self, l, r):\n        return self.query(1, 0, self.n - 1, l, r)\n\ndef maxSlidingWindow(nums, k):\n    if not nums or k <= 0:\n        return []\n    \n    st = SegmentTree(nums)\n    result = []\n    \n    for i in range(len(nums) - k + 1):\n        result.append(st.range_max(i, i + k - 1))\n    \n    return result\n\n# Test cases\ntest_cases = [\n    ([1, 3, -1, -3, 5, 3, 6, 7], 3),\n    ([1], 1),\n    ([1, -1], 1),\n    ([9, 11], 2),\n    ([4, -2, -3, 11, 2, -1, 4, 5], 4)\n]\n\nfor nums, k in test_cases:\n    result = maxSlidingWindow(nums, k)\n    print(f\"nums: {nums}, k: {k} -> {result}\")",
          "timeComplexity": "• **Monotonic Deque**: O(n) each element is added and removed at most once\n• **Max Heap**: O(n log n) heap operations for n elements\n• **Brute Force**: O(nk) finding max in each window\n• **Segment Tree**: O(n log n) for build + O(n log n) for queries",
          "spaceComplexity": "• **Monotonic Deque**: O(k) deque can store at most k elements\n• **Max Heap**: O(n) heap can grow to size n\n• **Brute Force**: O(1) only using variables\n• **Segment Tree**: O(n) for the tree structure",
          "keyInsights": "• Monotonic deque maintains elements in decreasing order for O(1) maximum access\n• The front of deque always contains the index of maximum element in current window\n• Remove indices outside current window and smaller elements to maintain monotonic property\n• This technique is powerful for sliding window problems requiring range queries\n• Deque operations ensure each element is processed at most twice (added once, removed once)",
          "link": "https://leetcode.com/problems/sliding-window-maximum/"
        }
      ]
    },
    {
      "id": "stack",
      "title": "Stack",
      "description": "Stack data structure and its applications in solving algorithmic problems",
      "questions": [
        {
          "id": "st_1",
          "title": "Valid Parentheses",
          "routeName": "valid_parentheses",
          "difficulty": "Easy",
          "leetcodeNumber": 20,
          "companies": ["Amazon", "Google", "Facebook", "Microsoft"],
          "tags": ["String", "Stack"],
          "description": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.",
          "detailedDescription": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n\nAn input string is valid if:\n1. Open brackets must be closed by the same type of brackets.\n2. Open brackets must be closed in the correct order.\n3. Every close bracket has a corresponding open bracket of the same type.\n\nExample 1:\nInput: s = \"()\"\nOutput: true\n\nExample 2:\nInput: s = \"()[]{}\"\nOutput: true\n\nExample 3:\nInput: s = \"(]\"\nOutput: false\n\nConstraints:\n• 1 <= s.length <= 10^4\n• s consists of parentheses only '()[]{}'.",
          "approach": "Multiple approaches to solve this problem:\n\n1. **Stack with Mapping**: Use stack and hash map for bracket matching.\n\n2. **Stack with Conditional Logic**: Use if-else conditions for bracket types.\n\n3. **Counter Method**: Count open and close brackets (limited to single bracket type).\n\n4. **Replace Method**: Repeatedly replace valid pairs until none left.",
          "solution": "**Approach 1: Stack with Hash Map (Most Elegant)**\nUse hash map to store bracket mappings and stack for tracking.\n\n**Approach 2: Stack with Conditional Logic**\nUse explicit conditions for each bracket type.\n\n**Key Insight**: Stack is perfect for matching nested structures like parentheses.",
          "code": "# Approach 1: Stack with Hash Map (Most Elegant)\ndef isValid(s):\n    stack = []\n    mapping = {')': '(', ']': '[', '}': '{'}\n    \n    for char in s:\n        if char in mapping:  # Closing bracket\n            top_element = stack.pop() if stack else '#'\n            if mapping[char] != top_element:\n                return False\n        else:  # Opening bracket\n            stack.append(char)\n    \n    return not stack\n\n# Approach 2: Stack with Conditional Logic\ndef isValid(s):\n    stack = []\n    \n    for char in s:\n        if char in '([{':\n            stack.append(char)\n        elif char in ')]}':\n            if not stack:\n                return False\n            \n            top = stack.pop()\n            if (char == ')' and top != '(' or\n                char == ']' and top != '[' or\n                char == '}' and top != '{'):\n                return False\n    \n    return len(stack) == 0\n\n# Approach 3: More Explicit Version\ndef isValid(s):\n    stack = []\n    pairs = {'(': ')', '[': ']', '{': '}'}\n    \n    for char in s:\n        if char in pairs:  # Opening bracket\n            stack.append(char)\n        else:  # Closing bracket\n            if not stack or pairs[stack.pop()] != char:\n                return False\n    \n    return not stack\n\n# Approach 4: Using Dictionary for Both Directions\ndef isValid(s):\n    stack = []\n    brackets = {\n        '(': ')', '[': ']', '{': '}',\n        ')': '(', ']': '[', '}': '{'\n    }\n    opening = set('([{')\n    \n    for char in s:\n        if char in opening:\n            stack.append(char)\n        else:\n            if not stack or stack.pop() != brackets[char]:\n                return False\n    \n    return not stack\n\n# Approach 5: Replace Method (Alternative but Less Efficient)\ndef isValid(s):\n    while '()' in s or '[]' in s or '{}' in s:\n        s = s.replace('()', '').replace('[]', '').replace('{}', '')\n    return s == ''\n\n# Approach 6: Counter Method (Only for Single Bracket Type)\ndef isValid(s):\n    # This only works if s contains only one type of bracket\n    if len(set(s)) > 2:\n        return False  # More than one bracket type\n    \n    count = 0\n    for char in s:\n        if char in '([{':\n            count += 1\n        else:\n            count -= 1\n            if count < 0:  # More closing than opening\n                return False\n    \n    return count == 0\n\n# Test cases\ntest_cases = [\n    \"()\",\n    \"()[]{}\",\n    \"(]\",\n    \"([)]\",\n    \"{[]}\",\n    \"\",\n    \"(((\",\n    \")))\"\n]\n\nfor test in test_cases:\n    result = isValid(test)\n    print(f\"'{test}' -> {result}\")",
          "timeComplexity": "• **Stack approaches**: O(n) single pass through the string\n• **Replace method**: O(n²) in worst case due to multiple string replacements",
          "spaceComplexity": "• **Stack approaches**: O(n) in worst case when all characters are opening brackets\n• **Replace method**: O(n) for string operations",
          "keyInsights": "• Stack is the natural data structure for matching nested structures\n• Hash map mapping makes the code cleaner and more maintainable\n• The key insight is that every closing bracket must match the most recent unmatched opening bracket\n• This pattern applies to many nested structure problems\n• Early termination when stack is empty but we encounter closing bracket optimizes performance",
          "link": "https://leetcode.com/problems/valid-parentheses/"
        },
        {
          "id": "st_2",
          "title": "Min Stack",
          "routeName": "min_stack",
          "difficulty": "Medium",
          "leetcodeNumber": 155,
          "companies": ["Amazon", "Google", "Bloomberg", "Microsoft"],
          "tags": ["Stack", "Design"],
          "description": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.",
          "detailedDescription": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\n\nImplement the MinStack class:\n• MinStack() initializes the stack object.\n• void push(int val) pushes the element val onto the stack.\n• void pop() removes the element on the top of the stack.\n• int top() gets the top element of the stack.\n• int getMin() retrieves the minimum element in the stack.\n\nYou must implement a solution with O(1) time complexity for each function.\n\nExample 1:\nInput\n[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"]\n[[],[-2],[0],[-3],[],[],[],[]]\n\nOutput\n[null,null,null,null,-3,null,0,-2]\n\nExplanation\nMinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.getMin(); // return -3\nminStack.pop();\nminStack.top();    // return 0\nminStack.getMin(); // return -2\n\nConstraints:\n• -2^31 <= val <= 2^31 - 1\n• Methods pop, top and getMin operations will always be called on non-empty stacks.\n• At most 3 * 10^4 calls will be made to push, pop, top, and getMin.",
          "approach": "Multiple approaches to solve this problem:\n\n1. **Two Stacks**: Use one stack for values, another for minimums.\n\n2. **Stack with Pairs**: Store (value, min_so_far) pairs in single stack.\n\n3. **Single Stack with Min Tracking**: Store differences and track minimum separately.\n\n4. **Linked List**: Use linked list with min tracking at each node.",
          "solution": "**Approach 1: Stack with Pairs (Most Intuitive)**\nStore (value, current_minimum) pairs in the stack.\n\n**Approach 2: Two Stacks**\nMaintain separate stacks for values and minimums.\n\n**Key Insight**: Track minimum at each level to enable O(1) access after pop operations.",
          "code": "# Approach 1: Stack with Pairs (Most Intuitive)\nclass MinStack:\n    def __init__(self):\n        self.stack = []\n    \n    def push(self, val):\n        # Store (value, min_value_at_this_level)\n        if not self.stack:\n            self.stack.append((val, val))\n        else:\n            current_min = min(val, self.stack[-1][1])\n            self.stack.append((val, current_min))\n    \n    def pop(self):\n        self.stack.pop()\n    \n    def top(self):\n        return self.stack[-1][0]\n    \n    def getMin(self):\n        return self.stack[-1][1]\n\n# Approach 2: Two Stacks\nclass MinStack:\n    def __init__(self):\n        self.stack = []\n        self.min_stack = []\n    \n    def push(self, val):\n        self.stack.append(val)\n        \n        # Only push to min_stack if it's empty or val is <= current min\n        if not self.min_stack or val <= self.min_stack[-1]:\n            self.min_stack.append(val)\n    \n    def pop(self):\n        if self.stack:\n            popped = self.stack.pop()\n            # Only pop from min_stack if popped value was the minimum\n            if popped == self.min_stack[-1]:\n                self.min_stack.pop()\n    \n    def top(self):\n        return self.stack[-1]\n    \n    def getMin(self):\n        return self.min_stack[-1]\n\n# Approach 3: Single Stack with Difference Tracking\nclass MinStack:\n    def __init__(self):\n        self.stack = []\n        self.min_val = None\n    \n    def push(self, val):\n        if not self.stack:\n            self.stack.append(0)\n            self.min_val = val\n        else:\n            # Store difference from minimum\n            self.stack.append(val - self.min_val)\n            if val < self.min_val:\n                self.min_val = val\n    \n    def pop(self):\n        if self.stack:\n            popped = self.stack.pop()\n            if popped < 0:\n                # Restore previous minimum\n                self.min_val = self.min_val - popped\n    \n    def top(self):\n        top_diff = self.stack[-1]\n        if top_diff < 0:\n            return self.min_val\n        else:\n            return self.min_val + top_diff\n    \n    def getMin(self):\n        return self.min_val\n\n# Approach 4: Linked List Implementation\nclass ListNode:\n    def __init__(self, val, min_val, next_node=None):\n        self.val = val\n        self.min = min_val\n        self.next = next_node\n\nclass MinStack:\n    def __init__(self):\n        self.head = None\n    \n    def push(self, val):\n        if self.head is None:\n            self.head = ListNode(val, val)\n        else:\n            min_val = min(val, self.head.min)\n            self.head = ListNode(val, min_val, self.head)\n    \n    def pop(self):\n        self.head = self.head.next\n    \n    def top(self):\n        return self.head.val\n    \n    def getMin(self):\n        return self.head.min\n\n# Approach 5: Using Python List with Min Tracking\nclass MinStack:\n    def __init__(self):\n        self.data = []\n    \n    def push(self, val):\n        if not self.data:\n            self.data.append([val, val])\n        else:\n            self.data.append([val, min(val, self.data[-1][1])])\n    \n    def pop(self):\n        self.data.pop()\n    \n    def top(self):\n        return self.data[-1][0]\n    \n    def getMin(self):\n        return self.data[-1][1]\n\n# Usage example and testing\ndef test_min_stack():\n    # Test with Approach 1\n    min_stack = MinStack()\n    \n    min_stack.push(-2)\n    min_stack.push(0)\n    min_stack.push(-3)\n    \n    print(f\"getMin(): {min_stack.getMin()}\")  # -3\n    min_stack.pop()\n    print(f\"top(): {min_stack.top()}\")        # 0\n    print(f\"getMin(): {min_stack.getMin()}\")  # -2\n    \n    # Additional test cases\n    min_stack.push(-1)\n    print(f\"getMin(): {min_stack.getMin()}\")  # -2\n    print(f\"top(): {min_stack.top()}\")        # -1\n\ntest_min_stack()",
          "timeComplexity": "• **All operations**: O(1) constant time for push, pop, top, and getMin\n• **All approaches**: Maintain O(1) time complexity requirement",
          "spaceComplexity": "• **Stack with pairs**: O(n) storing value and min for each element\n• **Two stacks**: O(n) in worst case, O(1) amortized for min_stack\n• **Difference tracking**: O(n) for stack, O(1) additional space\n• **Linked list**: O(n) for nodes with min tracking",
          "keyInsights": "• The key insight is to track minimum at each stack level to handle pop operations\n• Storing pairs (value, min) is the most intuitive approach\n• Two stacks approach optimizes space by only storing mins when necessary\n• Difference tracking is space-efficient but more complex to implement\n• This pattern applies to other stack problems requiring auxiliary information",
          "link": "https://leetcode.com/problems/min-stack/"
        },
        {
          "id": "st_3",
          "title": "Evaluate Reverse Polish Notation",
          "routeName": "evaluate_reverse_polish_notation",
          "difficulty": "Medium",
          "leetcodeNumber": 150,
          "companies": ["Amazon", "Google", "Facebook", "LinkedIn"],
          "tags": ["Array", "Math", "Stack"],
          "description": "You are given an array of strings tokens that represents an arithmetic expression in Reverse Polish Notation.",
          "detailedDescription": "You are given an array of strings tokens that represents an arithmetic expression in Reverse Polish Notation.\n\nEvaluate the expression. Return an integer that represents the value of the expression.\n\nNote that:\n• The valid operators are '+', '-', '*', and '/'.\n• Each operand may be an integer or another expression.\n• The division between two integers always truncates toward zero.\n• There will not be any division by zero.\n• The input represents a valid arithmetic expression in a reverse polish notation.\n• The answer and all the intermediate calculations can be represented in a 32-bit integer.\n\nExample 1:\nInput: tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"]\nOutput: 9\nExplanation: ((2 + 1) * 3) = 9\n\nExample 2:\nInput: tokens = [\"4\",\"13\",\"5\",\"/\",\"+\"]\nOutput: 6\nExplanation: (4 + (13 / 5)) = 6\n\nExample 3:\nInput: tokens = [\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"]\nOutput: 22\nExplanation: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5 = 22\n\nConstraints:\n• 1 <= tokens.length <= 10^4\n• tokens[i] is either an operator: \"+\", \"-\", \"*\", or \"/\", or an integer in the range [-200, 200].",
          "approach": "Multiple approaches to solve this problem:\n\n1. **Stack with Operator Set**: Use stack and check if token is operator.\n\n2. **Stack with Try-Except**: Try to convert to int, handle operators in except.\n\n3. **Stack with Dictionary**: Use dictionary to map operators to functions.\n\n4. **Recursive Approach**: Recursively evaluate sub-expressions.",
          "solution": "**Approach 1: Stack with Operator Set (Most Common)**\nUse stack and predefined set of operators for evaluation.\n\n**Approach 2: Stack with Dictionary Mapping**\nMap operators to lambda functions for cleaner code.\n\n**Key Insight**: RPN evaluation naturally fits stack operations - operands go in, operators pop and compute.",
          "code": "# Approach 1: Stack with Operator Set (Most Efficient)\ndef evalRPN(tokens):\n    stack = []\n    operators = {'+', '-', '*', '/'}\n    \n    for token in tokens:\n        if token in operators:\n            # Pop two operands (order matters for - and /)\n            b = stack.pop()\n            a = stack.pop()\n            \n            if token == '+':\n                result = a + b\n            elif token == '-':\n                result = a - b\n            elif token == '*':\n                result = a * b\n            else:  # token == '/'\n                # Truncate toward zero\n                result = int(a / b)\n            \n            stack.append(result)\n        else:\n            # Token is a number\n            stack.append(int(token))\n    \n    return stack[0]\n\n# Approach 2: Stack with Dictionary Mapping\ndef evalRPN(tokens):\n    stack = []\n    \n    operations = {\n        '+': lambda a, b: a + b,\n        '-': lambda a, b: a - b,\n        '*': lambda a, b: a * b,\n        '/': lambda a, b: int(a / b)  # Truncate toward zero\n    }\n    \n    for token in tokens:\n        if token in operations:\n            b = stack.pop()\n            a = stack.pop()\n            result = operations[token](a, b)\n            stack.append(result)\n        else:\n            stack.append(int(token))\n    \n    return stack[0]\n\n# Approach 3: Using Try-Except\ndef evalRPN(tokens):\n    stack = []\n    \n    for token in tokens:\n        try:\n            # Try to convert to integer\n            num = int(token)\n            stack.append(num)\n        except ValueError:\n            # Token is an operator\n            b = stack.pop()\n            a = stack.pop()\n            \n            if token == '+':\n                stack.append(a + b)\n            elif token == '-':\n                stack.append(a - b)\n            elif token == '*':\n                stack.append(a * b)\n            elif token == '/':\n                stack.append(int(a / b))\n    \n    return stack[0]\n\n# Approach 4: More Explicit Division Handling\ndef evalRPN(tokens):\n    stack = []\n    \n    for token in tokens:\n        if token not in '+-*/':\n            stack.append(int(token))\n        else:\n            b, a = stack.pop(), stack.pop()\n            \n            if token == '+':\n                stack.append(a + b)\n            elif token == '-':\n                stack.append(a - b)\n            elif token == '*':\n                stack.append(a * b)\n            elif token == '/':\n                # Handle division with proper truncation\n                if a * b < 0 and a % b != 0:\n                    stack.append(a // b + 1)\n                else:\n                    stack.append(a // b)\n    \n    return stack[0]\n\n# Approach 5: Using operator module\nimport operator\n\ndef evalRPN(tokens):\n    stack = []\n    \n    ops = {\n        '+': operator.add,\n        '-': operator.sub,\n        '*': operator.mul,\n        '/': lambda a, b: int(operator.truediv(a, b))\n    }\n    \n    for token in tokens:\n        if token in ops:\n            b = stack.pop()\n            a = stack.pop()\n            stack.append(ops[token](a, b))\n        else:\n            stack.append(int(token))\n    \n    return stack[0]\n\n# Approach 6: Recursive Solution (Alternative)\ndef evalRPN(tokens):\n    def evaluate():\n        token = tokens.pop()\n        \n        if token in '+-*/':\n            b = evaluate()\n            a = evaluate()\n            \n            if token == '+':\n                return a + b\n            elif token == '-':\n                return a - b\n            elif token == '*':\n                return a * b\n            else:  # token == '/'\n                return int(a / b)\n        else:\n            return int(token)\n    \n    # Reverse tokens for proper order in recursion\n    tokens.reverse()\n    return evaluate()\n\n# Test cases\ntest_cases = [\n    [\"2\", \"1\", \"+\", \"3\", \"*\"],\n    [\"4\", \"13\", \"5\", \"/\", \"+\"],\n    [\"10\", \"6\", \"9\", \"3\", \"+\", \"-11\", \"*\", \"/\", \"*\", \"17\", \"+\", \"5\", \"+\"],\n    [\"18\"],\n    [\"-3\", \"4\", \"+\"]\n]\n\nfor tokens in test_cases:\n    result = evalRPN(tokens.copy())  # Use copy to preserve original\n    print(f\"tokens: {tokens} -> result: {result}\")",
          "timeComplexity": "O(n) where n is the number of tokens. Each token is processed exactly once.",
          "spaceComplexity": "O(n) in worst case when all tokens are operands, stack grows to size n.",
          "keyInsights": "• RPN evaluation is a perfect application of stack data structure\n• Each operator pops two operands and pushes one result back\n• Order matters when popping operands for non-commutative operations (- and /)\n• Python's division truncation toward zero requires int(a/b) not a//b for negative results\n• The final result is the only element left in the stack",
          "link": "https://leetcode.com/problems/evaluate-reverse-polish-notation/"
        },
        {
          "id": "st_4",
          "title": "Generate Parentheses",
          "routeName": "generate_parentheses",
          "difficulty": "Medium",
          "leetcodeNumber": 22,
          "companies": ["Google", "Amazon", "Facebook", "Microsoft"],
          "tags": ["String", "Dynamic Programming", "Backtracking"],
          "description": "Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.",
          "detailedDescription": "Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\n\nExample 1:\nInput: n = 3\nOutput: [\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\n\nExample 2:\nInput: n = 1\nOutput: [\"()\"]\n\nConstraints:\n• 1 <= n <= 8",
          "approach": "Multiple approaches to solve this problem:\n\n1. **Backtracking**: Build strings by adding '(' and ')' with constraints.\n\n2. **Dynamic Programming**: Build solutions from smaller subproblems.\n\n3. **BFS**: Use queue to generate all valid combinations level by level.\n\n4. **Recursive with Memoization**: Cache results for repeated subproblems.",
          "solution": "**Approach 1: Backtracking (Most Common)**\nRecursively build valid parentheses by tracking open and close counts.\n\n**Approach 2: Dynamic Programming**\nBuild solutions for n from solutions of smaller values.\n\n**Key Insight**: At any point, we can add '(' if we haven't used all n, and ')' if it won't make string invalid.",
          "code": "# Approach 1: Backtracking (Most Efficient)\ndef generateParenthesis(n):\n    result = []\n    \n    def backtrack(current_string, open_count, close_count):\n        # Base case: we've used all n pairs\n        if len(current_string) == 2 * n:\n            result.append(current_string)\n            return\n        \n        # Add opening parenthesis if we haven't used all n\n        if open_count < n:\n            backtrack(current_string + '(', open_count + 1, close_count)\n        \n        # Add closing parenthesis if it won't make string invalid\n        if close_count < open_count:\n            backtrack(current_string + ')', open_count, close_count + 1)\n    \n    backtrack('', 0, 0)\n    return result\n\n# Approach 2: Backtracking with Different Parameters\ndef generateParenthesis(n):\n    result = []\n    \n    def generate(s='', left=0, right=0):\n        if len(s) == 2 * n:\n            result.append(s)\n            return\n        \n        if left < n:\n            generate(s + '(', left + 1, right)\n        \n        if right < left:\n            generate(s + ')', left, right + 1)\n    \n    generate()\n    return result\n\n# Approach 3: Dynamic Programming\ndef generateParenthesis(n):\n    if n == 0:\n        return ['']\n    \n    dp = [[] for _ in range(n + 1)]\n    dp[0] = ['']\n    \n    for i in range(1, n + 1):\n        for j in range(i):\n            # For each way to split i pairs:\n            # j pairs inside first parentheses, (i-1-j) pairs after\n            for left in dp[j]:\n                for right in dp[i - 1 - j]:\n                    dp[i].append('(' + left + ')' + right)\n    \n    return dp[n]\n\n# Approach 4: BFS Approach\nfrom collections import deque\n\ndef generateParenthesis(n):\n    if n == 0:\n        return ['']\n    \n    queue = deque([('', 0, 0)])  # (current_string, open_count, close_count)\n    result = []\n    \n    while queue:\n        current, open_count, close_count = queue.popleft()\n        \n        if len(current) == 2 * n:\n            result.append(current)\n            continue\n        \n        # Add opening parenthesis\n        if open_count < n:\n            queue.append((current + '(', open_count + 1, close_count))\n        \n        # Add closing parenthesis\n        if close_count < open_count:\n            queue.append((current + ')', open_count, close_count + 1))\n    \n    return result\n\n# Approach 5: Recursive with Memoization\ndef generateParenthesis(n):\n    memo = {}\n    \n    def generate(remaining_open, remaining_close):\n        if remaining_open == 0 and remaining_close == 0:\n            return ['']\n        \n        if (remaining_open, remaining_close) in memo:\n            return memo[(remaining_open, remaining_close)]\n        \n        result = []\n        \n        # Add opening parenthesis\n        if remaining_open > 0:\n            for s in generate(remaining_open - 1, remaining_close):\n                result.append('(' + s)\n        \n        # Add closing parenthesis\n        if remaining_close > remaining_open:\n            for s in generate(remaining_open, remaining_close - 1):\n                result.append(')' + s)\n        \n        memo[(remaining_open, remaining_close)] = result\n        return result\n    \n    return generate(n, n)\n\n# Approach 6: Iterative with Stack\ndef generateParenthesis(n):\n    stack = [('', 0, 0)]  # (current_string, open_count, close_count)\n    result = []\n    \n    while stack:\n        current, open_count, close_count = stack.pop()\n        \n        if len(current) == 2 * n:\n            result.append(current)\n            continue\n        \n        # Add closing parenthesis first (due to stack LIFO)\n        if close_count < open_count:\n            stack.append((current + ')', open_count, close_count + 1))\n        \n        # Add opening parenthesis\n        if open_count < n:\n            stack.append((current + '(', open_count + 1, close_count))\n    \n    return result\n\n# Approach 7: Mathematical Approach using Catalan Numbers\ndef generateParenthesis(n):\n    if n == 0:\n        return ['']\n    \n    result = []\n    \n    for i in range(n):\n        # Split into i pairs inside first parentheses, n-1-i pairs outside\n        for left in generateParenthesis(i):\n            for right in generateParenthesis(n - 1 - i):\n                result.append('(' + left + ')' + right)\n    \n    return result\n\n# Test cases\ntest_cases = [1, 2, 3, 4]\n\nfor n in test_cases:\n    result = generateParenthesis(n)\n    print(f\"n = {n}:\")\n    for combo in result:\n        print(f\"  {combo}\")\n    print(f\"Total combinations: {len(result)}\\n\")",
          "timeComplexity": "• **Backtracking**: O(4^n / √n) which is the nth Catalan number\n• **Dynamic Programming**: O(4^n / √n) same complexity but with different constant factors\n• **BFS**: O(4^n / √n) same as backtracking but with queue overhead",
          "spaceComplexity": "• **Backtracking**: O(4^n / √n) for the result list + O(n) for recursion stack\n• **Dynamic Programming**: O(4^n / √n) for storing all intermediate results\n• **Memoization**: O(4^n / √n) for memoization table plus recursion stack",
          "keyInsights": "• This problem generates the nth Catalan number of combinations\n• Backtracking with constraints (open_count < n, close_count < open_count) ensures validity\n• Dynamic programming approach shows the recursive structure of the problem\n• The key insight is that at any position we can only add '(' or ')' based on current counts\n• This pattern applies to many constraint-based string generation problems",
          "link": "https://leetcode.com/problems/generate-parentheses/"
        },
        {
          "id": "st_5",
          "title": "Daily Temperatures",
          "routeName": "daily_temperatures",
          "difficulty": "Medium",
          "leetcodeNumber": 739,
          "companies": ["Amazon", "Google", "Facebook", "Microsoft"],
          "tags": ["Array", "Stack", "Monotonic Stack"],
          "description": "Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature.",
          "detailedDescription": "Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0.\n\nExample 1:\nInput: temperatures = [73,74,75,71,69,72,76,73]\nOutput: [1,1,4,2,1,1,0,0]\n\nExample 2:\nInput: temperatures = [30,40,50,60]\nOutput: [1,1,1,0]\n\nExample 3:\nInput: temperatures = [30,60,90]\nOutput: [1,1,0]\n\nConstraints:\n• 1 <= temperatures.length <= 10^5\n• 30 <= temperatures[i] <= 100",
          "approach": "Multiple approaches to solve this problem:\n\n1. **Monotonic Stack**: Use stack to store indices of decreasing temperatures.\n\n2. **Brute Force**: For each day, search forward for warmer temperature.\n\n3. **Backward Iteration**: Iterate backward and use precomputed results.\n\n4. **Hash Map with Stacks**: Group by temperature and use stacks for each.",
          "solution": "**Approach 1: Monotonic Stack (Optimal)**\nUse stack to maintain indices in decreasing order of temperatures.\n\n**Approach 2: Brute Force**\nFor each temperature, linearly search for next warmer day.\n\n**Key Insight**: Monotonic stack helps find the next greater element efficiently.",
          "code": "# Approach 1: Monotonic Stack (Most Efficient)\ndef dailyTemperatures(temperatures):\n    stack = []  # Store indices\n    result = [0] * len(temperatures)\n    \n    for i, temp in enumerate(temperatures):\n        # While current temp is warmer than temps at indices in stack\n        while stack and temperatures[stack[-1]] < temp:\n            prev_index = stack.pop()\n            result[prev_index] = i - prev_index\n        \n        stack.append(i)\n    \n    return result\n\n# Approach 2: Brute Force (Less Efficient)\ndef dailyTemperatures(temperatures):\n    result = [0] * len(temperatures)\n    \n    for i in range(len(temperatures)):\n        for j in range(i + 1, len(temperatures)):\n            if temperatures[j] > temperatures[i]:\n                result[i] = j - i\n                break\n    \n    return result\n\n# Approach 3: Backward Iteration with Optimization\ndef dailyTemperatures(temperatures):\n    n = len(temperatures)\n    result = [0] * n\n    \n    for i in range(n - 2, -1, -1):\n        j = i + 1\n        \n        # Use previously computed results to skip ahead\n        while j < n and temperatures[j] <= temperatures[i]:\n            if result[j] == 0:\n                j = n  # No warmer day exists\n            else:\n                j += result[j]\n        \n        if j < n:\n            result[i] = j - i\n    \n    return result\n\n# Approach 4: Stack with Explicit Temperature Checking\ndef dailyTemperatures(temperatures):\n    stack = []\n    answer = [0] * len(temperatures)\n    \n    for current_day, current_temp in enumerate(temperatures):\n        # Pop from stack while current temp is warmer\n        while stack and current_temp > temperatures[stack[-1]]:\n            prev_day = stack.pop()\n            answer[prev_day] = current_day - prev_day\n        \n        # Add current day to stack\n        stack.append(current_day)\n    \n    return answer\n\n# Approach 5: Using Deque (Alternative)\nfrom collections import deque\n\ndef dailyTemperatures(temperatures):\n    stack = deque()\n    result = [0] * len(temperatures)\n    \n    for i, temp in enumerate(temperatures):\n        while stack and temperatures[stack[-1]] < temp:\n            idx = stack.pop()\n            result[idx] = i - idx\n        stack.append(i)\n    \n    return result\n\n# Approach 6: Hash Map Approach (Less Efficient)\ndef dailyTemperatures(temperatures):\n    result = [0] * len(temperatures)\n    temp_to_indices = {}\n    \n    for i, temp in enumerate(temperatures):\n        # Check all lower temperatures and update their results\n        for t in range(30, temp):  # Temperature range constraint\n            if t in temp_to_indices:\n                while temp_to_indices[t]:\n                    idx = temp_to_indices[t].pop(0)\n                    if result[idx] == 0:  # Not yet found\n                        result[idx] = i - idx\n        \n        # Add current temperature and index\n        if temp not in temp_to_indices:\n            temp_to_indices[temp] = []\n        temp_to_indices[temp].append(i)\n    \n    return result\n\n# Optimized version with early termination\ndef dailyTemperatures(temperatures):\n    stack = []\n    result = [0] * len(temperatures)\n    \n    for i in range(len(temperatures)):\n        # Process all temperatures that are cooler than current\n        while stack and temperatures[i] > temperatures[stack[-1]]:\n            prev_idx = stack.pop()\n            result[prev_idx] = i - prev_idx\n        \n        stack.append(i)\n    \n    # Remaining elements in stack have no warmer future day (already 0)\n    return result\n\n# Test cases\ntest_cases = [\n    [73, 74, 75, 71, 69, 72, 76, 73],\n    [30, 40, 50, 60],\n    [30, 60, 90],\n    [89, 62, 70, 58, 47, 47, 46, 76, 100, 70]\n]\n\nfor temps in test_cases:\n    result = dailyTemperatures(temps)\n    print(f\"Temperatures: {temps}\")\n    print(f\"Days to wait: {result}\\n\")",
          "timeComplexity": "• **Monotonic Stack**: O(n) each element is pushed and popped at most once\n• **Brute Force**: O(n²) for each element, check all following elements\n• **Backward Iteration**: O(n) amortized, but can be O(n²) worst case",
          "spaceComplexity": "• **Monotonic Stack**: O(n) for the stack in worst case (decreasing sequence)\n• **Brute Force**: O(1) only using constant extra space\n• **All approaches**: O(n) for the result array",
          "keyInsights": "• Monotonic stack is perfect for 'next greater element' type problems\n• Stack stores indices in decreasing order of their temperatures\n• When we find a warmer temperature, it resolves all cooler temperatures in the stack\n• This pattern applies to many problems involving finding next/previous greater/smaller elements\n• The key insight is that we don't need to check all previous elements, only those that haven't found their answer yet",
          "link": "https://leetcode.com/problems/daily-temperatures/"
        },
        {
          "id": "st_6",
          "title": "Car Fleet",
          "routeName": "car_fleet",
          "difficulty": "Medium",
          "leetcodeNumber": 853,
          "companies": ["Amazon", "Google", "Apple", "Tesla"],
          "tags": ["Array", "Stack", "Sorting", "Monotonic Stack"],
          "description": "There are n cars going to the same destination along a one-lane road. The destination is target miles away.",
          "detailedDescription": "There are n cars going to the same destination along a one-lane road. The destination is target miles away.\n\nYou are given two integer arrays position and speed, both of length n, where position[i] is the position of the ith car and speed[i] is the speed of the ith car (in miles per hour).\n\nA car can never pass another car, but it can catch up and drive bumper to bumper at the same speed.\n\nThe faster car will slow down to match the slower car's speed. The distance between these two cars is ignored (i.e., they are assumed to have the same position).\n\nA car fleet is formed by cars that drive bumper to bumper at the same speed. Note that a single car is also a car fleet.\n\nReturn the number of car fleets that will arrive at the destination.\n\nExample 1:\nInput: target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]\nOutput: 3\nExplanation:\n- The cars starting at 10 (speed 2) and 8 (speed 4) become a fleet, meeting each other at 12. The fleet forms at the target.\n- The car starting at 0 (speed 1) is a fleet by itself.\n- The cars starting at 5 (speed 1) and 3 (speed 3) become a fleet, meeting each other at 6. The fleet moves at speed 1 until it reaches the target.\n\nExample 2:\nInput: target = 10, position = [3], speed = [3]\nOutput: 1\nExplanation: There is only one car, hence there is only one fleet.\n\nExample 3:\nInput: target = 100, position = [0,2,4], speed = [4,2,1]\nOutput: 1\nExplanation:\n- The cars starting at 0 (speed 4) and 2 (speed 2) become a fleet, meeting each other at 4. The fleet moves at speed 2.\n- Then, the fleet (speed 2) and the car starting at 4 (speed 1) become a fleet, meeting each other at 6. The fleet moves at speed 1 until it reaches the target.\n\nConstraints:\n• n == position.length == speed.length\n• 1 <= n <= 10^5\n• 0 < target <= 10^6\n• 0 <= position[i] < target\n• All the values of position are unique.\n• 0 < speed[i] <= 10^6",
          "approach": "Multiple approaches to solve this problem:\n\n1. **Stack with Time Calculation**: Calculate time to reach target, use stack to track fleets.\n\n2. **Sorting with Fleet Tracking**: Sort by position and track fleet formation.\n\n3. **Greedy Approach**: Process cars from right to left, counting independent fleets.\n\n4. **Simulation**: Simulate the movement until all cars reach target.",
          "solution": "**Approach 1: Stack with Time Calculation (Most Common)**\nCalculate time for each car to reach target, use stack to merge fleets.\n\n**Approach 2: Greedy with Fleet Counting**\nSort cars by position and count fleets by comparing arrival times.\n\n**Key Insight**: Cars behind can only catch up if they have a shorter time to target.",
          "code": "# Approach 1: Stack with Time Calculation (Most Efficient)\ndef carFleet(target, position, speed):\n    # Pair positions with speeds and sort by position\n    cars = sorted(zip(position, speed))\n    \n    # Calculate time to reach target for each car\n    times = [(target - pos) / spd for pos, spd in cars]\n    \n    # Use stack to track fleet formation\n    stack = []\n    \n    # Process cars from right to left (closest to target first)\n    for time in reversed(times):\n        # If current car takes longer to reach target than the car ahead,\n        # it forms a new fleet\n        if not stack or time > stack[-1]:\n            stack.append(time)\n        # Otherwise, it catches up and joins the fleet ahead\n    \n    return len(stack)\n\n# Approach 2: Greedy without Stack\ndef carFleet(target, position, speed):\n    cars = sorted(zip(position, speed))\n    times = [(target - pos) / spd for pos, spd in cars]\n    \n    fleets = 0\n    current_time = 0\n    \n    # Process from rightmost car (closest to target)\n    for time in reversed(times):\n        if time > current_time:\n            fleets += 1\n            current_time = time\n    \n    return fleets\n\n# Approach 3: More Explicit Implementation\ndef carFleet(target, position, speed):\n    if not position:\n        return 0\n    \n    # Create list of (position, time_to_target)\n    cars = []\n    for i in range(len(position)):\n        time_to_target = (target - position[i]) / speed[i]\n        cars.append((position[i], time_to_target))\n    \n    # Sort by position (descending, closest to target first)\n    cars.sort(reverse=True)\n    \n    fleets = 0\n    prev_time = 0\n    \n    for pos, time in cars:\n        # If this car takes longer than previous, it starts a new fleet\n        if time > prev_time:\n            fleets += 1\n            prev_time = time\n    \n    return fleets\n\n# Approach 4: Using Stack with Detailed Logic\ndef carFleet(target, position, speed):\n    # Edge case\n    if not position:\n        return 0\n    \n    # Combine and sort by position\n    cars = list(zip(position, speed))\n    cars.sort()\n    \n    stack = []\n    \n    for pos, spd in cars:\n        # Calculate time to reach target\n        time = (target - pos) / spd\n        \n        # If stack is empty or current car is slower than the fleet ahead\n        if not stack or time > stack[-1]:\n            stack.append(time)\n        # Else, current car catches up with the fleet ahead\n    \n    return len(stack)\n\n# Approach 5: Simulation Approach (Less Efficient)\ndef carFleet(target, position, speed):\n    cars = list(zip(position, speed))\n    cars.sort()\n    \n    fleets = []\n    \n    for pos, spd in cars:\n        time = (target - pos) / spd\n        \n        # Check if this car can catch up with any existing fleet\n        caught_up = False\n        for i, fleet_time in enumerate(fleets):\n            if time <= fleet_time:\n                caught_up = True\n                break\n        \n        if not caught_up:\n            fleets.append(time)\n    \n    return len(fleets)\n\n# Approach 6: Dictionary-based Grouping\ndef carFleet(target, position, speed):\n    from collections import defaultdict\n    \n    # Group cars by their arrival time\n    time_groups = defaultdict(list)\n    \n    for pos, spd in zip(position, speed):\n        time = (target - pos) / spd\n        time_groups[time].append(pos)\n    \n    # Sort times in descending order\n    sorted_times = sorted(time_groups.keys(), reverse=True)\n    \n    fleets = 0\n    last_time = float('inf')\n    \n    for time in sorted_times:\n        if time < last_time:\n            fleets += 1\n            last_time = time\n    \n    return fleets\n\n# Test cases\ntest_cases = [\n    (12, [10, 8, 0, 5, 3], [2, 4, 1, 1, 3]),\n    (10, [3], [3]),\n    (100, [0, 2, 4], [4, 2, 1]),\n    (10, [6, 8], [3, 2]),\n    (13, [10, 2, 5, 7, 4, 6, 11], [7, 5, 10, 5, 9, 4, 1])\n]\n\nfor target, positions, speeds in test_cases:\n    result = carFleet(target, positions, speeds)\n    print(f\"Target: {target}, Positions: {positions}, Speeds: {speeds}\")\n    print(f\"Number of fleets: {result}\\n\")",
          "timeComplexity": "• **Stack approach**: O(n log n) for sorting + O(n) for processing = O(n log n)\n• **All approaches**: Dominated by sorting step which is O(n log n)",
          "spaceComplexity": "• **Stack approach**: O(n) for storing cars and times\n• **Greedy approach**: O(n) for storing car data\n• **All approaches**: O(n) space complexity",
          "keyInsights": "• Key insight: cars can only catch up if they have shorter time to reach target\n• Sorting by position is crucial to process cars in correct order\n• Stack naturally handles fleet merging - slower cars join faster fleets ahead\n• A car forms a new fleet only if it takes longer to reach target than the car/fleet ahead\n• This problem demonstrates how stack can model real-world scenarios with constraints",
          "link": "https://leetcode.com/problems/car-fleet/"
        },
        {
          "id": "st_7",
          "title": "Largest Rectangle in Histogram",
          "routeName": "largest_rectangle_in_histogram",
          "difficulty": "Hard",
          "leetcodeNumber": 84,
          "companies": ["Google", "Amazon", "Facebook", "Microsoft"],
          "tags": ["Array", "Stack", "Monotonic Stack"],
          "description": "Given an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.",
          "detailedDescription": "Given an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.\n\nExample 1:\nInput: heights = [2,1,5,6,2,3]\nOutput: 10\nExplanation: The above is a histogram where width of each bar is 1.\nThe largest rectangle is shown in the red area, which has an area = 10 units.\n\nExample 2:\nInput: heights = [2,4]\nOutput: 4\n\nConstraints:\n• 1 <= heights.length <= 10^5\n• 0 <= heights[i] <= 10^4",
          "approach": "Multiple approaches to solve this problem:\n\n1. **Monotonic Stack**: Use stack to find left and right boundaries for each bar.\n\n2. **Stack with Sentinel**: Add sentinel value to handle remaining stack elements.\n\n3. **Divide and Conquer**: Recursively find maximum in left and right subarrays.\n\n4. **Brute Force**: For each bar, find maximum rectangle with that bar as height.",
          "solution": "**Approach 1: Monotonic Stack (Optimal)**\nUse stack to maintain increasing heights and calculate area when popping.\n\n**Approach 2: Stack with Left/Right Arrays**\nPrecompute left and right boundaries for each bar.\n\n**Key Insight**: For each bar, find the maximum rectangle with that bar as the shortest bar.",
          "code": "# Approach 1: Monotonic Stack (Most Efficient)\ndef largestRectangleArea(heights):\n    stack = []\n    max_area = 0\n    \n    for i, height in enumerate(heights + [0]):  # Add sentinel\n        # While current height is smaller than stack top\n        while stack and heights[stack[-1]] > height:\n            h = heights[stack.pop()]  # Height of rectangle\n            \n            # Width calculation\n            w = i if not stack else i - stack[-1] - 1\n            \n            max_area = max(max_area, h * w)\n        \n        stack.append(i)\n    \n    return max_area\n\n# Approach 2: Stack without Sentinel\ndef largestRectangleArea(heights):\n    stack = []\n    max_area = 0\n    index = 0\n    \n    while index < len(heights):\n        # If current bar is higher than stack top, push it\n        if not stack or heights[index] >= heights[stack[-1]]:\n            stack.append(index)\n            index += 1\n        else:\n            # Pop the top and calculate area\n            top = stack.pop()\n            area = (heights[top] * \n                   ((index - stack[-1] - 1) if stack else index))\n            max_area = max(max_area, area)\n    \n    # Pop remaining bars from stack\n    while stack:\n        top = stack.pop()\n        area = (heights[top] * \n               ((index - stack[-1] - 1) if stack else index))\n        max_area = max(max_area, area)\n    \n    return max_area\n\n# Approach 3: Precompute Left and Right Boundaries\ndef largestRectangleArea(heights):\n    n = len(heights)\n    left = [0] * n   # left[i] = index of first bar to left with height < heights[i]\n    right = [0] * n  # right[i] = index of first bar to right with height < heights[i]\n    \n    # Fill left array\n    left[0] = -1\n    for i in range(1, n):\n        j = i - 1\n        while j >= 0 and heights[j] >= heights[i]:\n            j = left[j]\n        left[i] = j\n    \n    # Fill right array\n    right[n - 1] = n\n    for i in range(n - 2, -1, -1):\n        j = i + 1\n        while j < n and heights[j] >= heights[i]:\n            j = right[j]\n        right[i] = j\n    \n    # Calculate maximum area\n    max_area = 0\n    for i in range(n):\n        width = right[i] - left[i] - 1\n        area = heights[i] * width\n        max_area = max(max_area, area)\n    \n    return max_area\n\n# Approach 4: Divide and Conquer\ndef largestRectangleArea(heights):\n    def divide_conquer(left, right):\n        if left > right:\n            return 0\n        \n        # Find minimum height index in range\n        min_index = left\n        for i in range(left, right + 1):\n            if heights[i] < heights[min_index]:\n                min_index = i\n        \n        # Maximum area is max of:\n        # 1. Rectangle with min height spanning entire range\n        # 2. Max rectangle in left subarray\n        # 3. Max rectangle in right subarray\n        return max(\n            heights[min_index] * (right - left + 1),\n            divide_conquer(left, min_index - 1),\n            divide_conquer(min_index + 1, right)\n        )\n    \n    return divide_conquer(0, len(heights) - 1)\n\n# Approach 5: Brute Force (For Understanding)\ndef largestRectangleArea(heights):\n    max_area = 0\n    \n    for i in range(len(heights)):\n        min_height = heights[i]\n        for j in range(i, len(heights)):\n            min_height = min(min_height, heights[j])\n            width = j - i + 1\n            area = min_height * width\n            max_area = max(max_area, area)\n    \n    return max_area\n\n# Approach 6: Stack with Clear Logic\ndef largestRectangleArea(heights):\n    stack = [-1]  # Start with sentinel\n    max_area = 0\n    \n    for i in range(len(heights)):\n        # Maintain increasing stack\n        while stack[-1] != -1 and heights[stack[-1]] >= heights[i]:\n            height = heights[stack.pop()]\n            width = i - stack[-1] - 1\n            max_area = max(max_area, height * width)\n        \n        stack.append(i)\n    \n    # Process remaining elements\n    while stack[-1] != -1:\n        height = heights[stack.pop()]\n        width = len(heights) - stack[-1] - 1\n        max_area = max(max_area, height * width)\n    \n    return max_area\n\n# Approach 7: Using Deque\nfrom collections import deque\n\ndef largestRectangleArea(heights):\n    stack = deque()\n    max_area = 0\n    \n    for i, h in enumerate(heights + [0]):\n        while stack and heights[stack[-1]] > h:\n            height = heights[stack.pop()]\n            width = i if not stack else i - stack[-1] - 1\n            max_area = max(max_area, height * width)\n        stack.append(i)\n    \n    return max_area\n\n# Test cases\ntest_cases = [\n    [2, 1, 5, 6, 2, 3],\n    [2, 4],\n    [1, 1, 1, 1],\n    [2, 1, 2],\n    [5, 4, 1, 2],\n    [1],\n    [0, 0, 0]\n]\n\nfor heights in test_cases:\n    result = largestRectangleArea(heights)\n    print(f\"Heights: {heights} -> Largest area: {result}\")",
          "timeComplexity": "• **Monotonic Stack**: O(n) each element is pushed and popped at most once\n• **Precompute boundaries**: O(n) amortized for left/right array computation\n• **Divide and Conquer**: O(n log n) average, O(n²) worst case\n• **Brute Force**: O(n²) checking all possible rectangles",
          "spaceComplexity": "• **Monotonic Stack**: O(n) for the stack in worst case\n• **Precompute boundaries**: O(n) for left and right arrays\n• **Divide and Conquer**: O(log n) for recursion stack\n• **Brute Force**: O(1) only using variables",
          "keyInsights": "• Monotonic stack is perfect for finding nearest smaller/larger elements\n• For each bar, we want to find the maximum rectangle with that bar as the shortest\n• Stack maintains increasing heights; when we pop, we found the rectangle boundary\n• Adding sentinel value (0) at the end ensures all bars are processed\n• This is a classic application of monotonic stack for geometric problems",
          "link": "https://leetcode.com/problems/largest-rectangle-in-histogram/"
        }
      ]
    },
    {
      "id": "binary-search",
      "title": "Binary Search",
      "description": "Binary search algorithm and its applications in sorted data structures",
      "questions": [
        {
          "id": "bs_1",
          "title": "Binary Search",
          "routeName": "binary_search",
          "difficulty": "Easy",
          "leetcodeNumber": 704,
          "companies": ["Amazon", "Google", "Microsoft", "Facebook"],
          "tags": ["Array", "Binary Search"],
          "description": "Standard binary search in a sorted array to find a target index.",
          "detailedDescription": "Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.\n\nYou must write an algorithm with O(log n) runtime complexity.\n\nExample 1:\nInput: nums = [-1,0,3,5,9,12], target = 9\nOutput: 4\nExplanation: 9 exists in nums and its index is 4\n\nExample 2:\nInput: nums = [-1,0,3,5,9,12], target = 2\nOutput: -1\nExplanation: 2 does not exist in nums so return -1\n\nConstraints:\n• 1 <= nums.length <= 10^4\n• -10^4 < nums[i], target < 10^4\n• All the integers in nums are unique.\n• nums is sorted in ascending order.",
          "approach": "Standard binary search algorithm implementation using two pointers to narrow down the search space by half in each iteration.",
          "solution": "Use left and right pointers to maintain search boundaries, calculate mid point, and compare with target to decide which half to search next.",
          "code": "def binarySearch(nums, target):\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\n# Test cases\ntest_cases = [\n    ([-1,0,3,5,9,12], 9),\n    ([-1,0,3,5,9,12], 2),\n    ([5], 5),\n    ([1,2,3,4,5], 3)\n]\n\nfor nums, target in test_cases:\n    result = binarySearch(nums, target)\n    print(f\"nums: {nums}, target: {target} -> index: {result}\")",
          "timeComplexity": "O(log n) where n is the length of the array",
          "spaceComplexity": "O(1) constant space complexity",
          "keyInsights": "• Binary search reduces search space by half each iteration\n• Works only on sorted arrays\n• Template: left <= right, mid = (left + right) // 2\n• Foundation for many advanced search problems",
          "link": "https://leetcode.com/problems/binary-search/"
        },
        {
          "id": "bs_2",
          "title": "Search a 2D Matrix",
          "routeName": "search_2d_matrix",
          "difficulty": "Medium",
          "leetcodeNumber": 74,
          "companies": ["Amazon", "Google", "Microsoft", "Facebook"],
          "tags": ["Array", "Binary Search", "Matrix"],
          "description": "Search target in a 2D sorted matrix by binary search treating it as a 1D array.",
          "detailedDescription": "You are given an m x n integer matrix matrix with the following two properties:\n• Each row is sorted in non-decreasing order.\n• The first integer of each row is greater than the last integer of the previous row.\n\nGiven an integer target, return true if target is in matrix or false otherwise.\n\nYou must write a solution in O(log(m * n)) time complexity.\n\nExample 1:\nInput: matrix = [[1,4,7,11],[2,5,8,12],[3,6,9,16],[10,13,14,17]], target = 5\nOutput: true\n\nExample 2:\nInput: matrix = [[1,4,7,11],[2,5,8,12],[3,6,9,16],[10,13,14,17]], target = 13\nOutput: false\n\nConstraints:\n• m == matrix.length\n• n == matrix[i].length\n• 1 <= m, n <= 100\n• -10^4 <= matrix[i][j], target <= 10^4",
          "approach": "Treat the 2D matrix as a flattened 1D array and apply binary search with index conversion.",
          "solution": "Use binary search on virtual 1D array indices, converting to 2D coordinates using division and modulo operations.",
          "code": "def searchMatrix(matrix, target):\n    if not matrix or not matrix[0]:\n        return False\n    rows, cols = len(matrix), len(matrix[0])\n    left, right = 0, rows * cols - 1\n    while left <= right:\n        mid = (left + right) // 2\n        mid_val = matrix[mid // cols][mid % cols]\n        if mid_val == target:\n            return True\n        elif mid_val < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return False\n\n# Test cases\ntest_cases = [\n    ([[1,4,7,11],[2,5,8,12],[3,6,9,16],[10,13,14,17]], 5),\n    ([[1,4,7,11],[2,5,8,12],[3,6,9,16],[10,13,14,17]], 13),\n    ([[1]], 1),\n    ([[1,3,5,7],[10,11,16,20],[23,30,34,60]], 3)\n]\n\nfor matrix, target in test_cases:\n    result = searchMatrix(matrix, target)\n    print(f\"target: {target} -> found: {result}\")",
          "timeComplexity": "O(log(m * n)) where m is number of rows and n is number of columns",
          "spaceComplexity": "O(1) constant space complexity",
          "keyInsights": "• Convert 2D coordinates to 1D: index = row * cols + col\n• Convert 1D index to 2D: row = index // cols, col = index % cols\n• Maintains O(log mn) complexity by treating matrix as sorted array\n• Key insight: sorted rows + first element property = globally sorted",
          "link": "https://leetcode.com/problems/search-a-2d-matrix/"
        },
        {
          "id": "bs_3",
          "title": "Koko Eating Bananas",
          "routeName": "koko_eating_bananas",
          "difficulty": "Medium",
          "leetcodeNumber": 875,
          "companies": ["Amazon", "Google", "Microsoft", "Facebook"],
          "tags": ["Array", "Binary Search"],
          "description": "Find minimum eating speed to finish piles of bananas within H hours using binary search on speed.",
          "detailedDescription": "Koko loves to eat bananas. There are n piles of bananas, the ith pile has piles[i] bananas. The guards have gone and will come back in h hours.\n\nKoko can decide her bananas-per-hour eating speed of k. Each hour, she chooses some pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, she eats all of them for that hour and will not eat any more bananas during that hour.\n\nKoko likes to eat slowly but wants to finish eating all the bananas before the guards come back.\n\nReturn the minimum integer k such that she can eat all the bananas within h hours.\n\nExample 1:\nInput: piles = [3,6,7,11], h = 8\nOutput: 4\n\nExample 2:\nInput: piles = [30,11,23,4,20], h = 5\nOutput: 30\n\nExample 3:\nInput: piles = [30,11,23,4,20], h = 6\nOutput: 23\n\nConstraints:\n• 1 <= piles.length <= 10^4\n• piles.length <= h <= 10^9\n• 1 <= piles[i] <= 10^9",
          "approach": "Binary search on the eating speed k. For each speed, check if Koko can finish all bananas within h hours.",
          "solution": "Search space is from 1 to max(piles). For each mid speed, calculate total hours needed and adjust search range.",
          "code": "def minEatingSpeed(piles, H):\n    def canEat(speed):\n        return sum((pile-1)//speed + 1 for pile in piles) <= H\n    left, right = 1, max(piles)\n    while left < right:\n        mid = (left + right) // 2\n        if canEat(mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\n# Test cases\ntest_cases = [\n    ([3,6,7,11], 8),\n    ([30,11,23,4,20], 5),\n    ([30,11,23,4,20], 6),\n    ([312884470], 312884469)\n]\n\nfor piles, h in test_cases:\n    result = minEatingSpeed(piles, h)\n    print(f\"piles: {piles}, h: {h} -> min speed: {result}\")",
          "timeComplexity": "O(n * log(max(piles))) where n is number of piles",
          "spaceComplexity": "O(1) constant space complexity",
          "keyInsights": "• Binary search on answer space (eating speed) not input array\n• Helper function checks feasibility of a given speed\n• Ceiling division: (pile-1)//speed + 1 = ceil(pile/speed)\n• Pattern: binary search on continuous answer space with validation function",
          "link": "https://leetcode.com/problems/koko-eating-bananas/"
        },
        {
          "id": "bs_4",
          "title": "Find Minimum in Rotated Sorted Array",
          "routeName": "find_minimum_rotated_array",
          "difficulty": "Medium",
          "leetcodeNumber": 153,
          "companies": ["Amazon", "Google", "Microsoft", "Facebook"],
          "tags": ["Array", "Binary Search"],
          "description": "Find the minimum element in a rotated sorted array using binary search.",
          "detailedDescription": "Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:\n• [4,5,6,7,0,1,2] if it was rotated 4 times.\n• [0,1,2,4,5,6,7] if it was rotated 7 times.\n\nNotice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]].\n\nGiven the sorted rotated array nums of unique elements, return the minimum element of this array.\n\nYou must write an algorithm that runs in O(log n) time.\n\nExample 1:\nInput: nums = [3,4,5,1,2]\nOutput: 1\nExplanation: The original array was [1,2,3,4,5] rotated 3 times.\n\nExample 2:\nInput: nums = [4,5,6,7,0,1,2]\nOutput: 0\nExplanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.\n\nExample 3:\nInput: nums = [11,13,15,17]\nOutput: 11\nExplanation: The original array was [11,13,15,17] and it was rotated 4 times.\n\nConstraints:\n• n == nums.length\n• 1 <= n <= 5000\n• -5000 <= nums[i] <= 5000\n• All the integers of nums are unique.\n• nums is sorted and rotated between 1 and n times.",
          "approach": "Binary search by comparing mid element with rightmost element to determine which half contains the minimum.",
          "solution": "If nums[mid] > nums[right], minimum is in right half. Otherwise, minimum is in left half (including mid).",
          "code": "def findMin(nums):\n    left, right = 0, len(nums) - 1\n    while left < right:\n        mid = (left + right) // 2\n        if nums[mid] > nums[right]:\n            left = mid + 1\n        else:\n            right = mid\n    return nums[left]\n\n# Test cases\ntest_cases = [\n    [3,4,5,1,2],\n    [4,5,6,7,0,1,2],\n    [11,13,15,17],\n    [1],\n    [2,1]\n]\n\nfor nums in test_cases:\n    result = findMin(nums)\n    print(f\"nums: {nums} -> minimum: {result}\")",
          "timeComplexity": "O(log n) where n is the length of the array",
          "spaceComplexity": "O(1) constant space complexity",
          "keyInsights": "• Compare mid with right element (not left) to handle rotation\n• If nums[mid] > nums[right]: rotation point is in right half\n• Otherwise: minimum is in left half (including mid)\n• Template for rotated array problems",
          "link": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/"
        },
        {
          "id": "bs_5",
          "title": "Search in Rotated Sorted Array",
          "routeName": "search_rotated_array",
          "difficulty": "Medium",
          "leetcodeNumber": 33,
          "companies": ["Amazon", "Google", "Microsoft", "Facebook"],
          "tags": ["Array", "Binary Search"],
          "description": "Search target in rotated sorted array using modified binary search.",
          "detailedDescription": "There is an integer array nums sorted in ascending order (with distinct values).\n\nPrior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].\n\nGiven the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.\n\nYou must write an algorithm with O(log n) runtime complexity.\n\nExample 1:\nInput: nums = [4,5,6,7,0,1,2], target = 0\nOutput: 4\n\nExample 2:\nInput: nums = [4,5,6,7,0,1,2], target = 3\nOutput: -1\n\nExample 3:\nInput: nums = [1], target = 0\nOutput: -1\n\nConstraints:\n• 1 <= nums.length <= 5000\n• -10^4 <= nums[i] <= 10^4\n• All values of nums are unique.\n• nums is an ascending array that is possibly rotated.\n• -10^4 <= target <= 10^4",
          "approach": "Modified binary search that identifies which half is sorted and checks if target lies in that sorted half.",
          "solution": "At each step, determine which half is sorted by comparing nums[left] with nums[mid], then check if target is in that sorted range.",
          "code": "def search(nums, target):\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        if nums[left] <= nums[mid]:\n            if nums[left] <= target < nums[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        else:\n            if nums[mid] < target <= nums[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n    return -1\n\n# Test cases\ntest_cases = [\n    ([4,5,6,7,0,1,2], 0),\n    ([4,5,6,7,0,1,2], 3),\n    ([1], 0),\n    ([1,3], 3)\n]\n\nfor nums, target in test_cases:\n    result = search(nums, target)\n    print(f\"nums: {nums}, target: {target} -> index: {result}\")",
          "timeComplexity": "O(log n) where n is the length of the array",
          "spaceComplexity": "O(1) constant space complexity",
          "keyInsights": "• One half is always sorted in rotated array\n• Compare nums[left] <= nums[mid] to identify sorted left half\n• Check if target lies within the sorted half's range\n• Essential pattern for rotated array search problems",
          "link": "https://leetcode.com/problems/search-in-rotated-sorted-array/"
        },
        {
          "id": "bs_6",
          "title": "Time Based Key-Value Store",
          "routeName": "time_based_key_value_store",
          "difficulty": "Medium",
          "leetcodeNumber": 981,
          "companies": ["Amazon", "Google", "Microsoft", "Uber"],
          "tags": ["Hash Table", "String", "Binary Search", "Design"],
          "description": "Design key-value store allowing get(key, timestamp) returning value at latest timestamp <= given timestamp. Uses binary search on timestamp list.",
          "detailedDescription": "Design a time-based key-value data structure that can store multiple values for the same key at different time stamps and retrieve the key's value at a certain timestamp.\n\nImplement the TimeMap class:\n• TimeMap() Initializes the object of the data structure.\n• void set(String key, String value, int timestamp) Stores the key with the value at the given time timestamp.\n• String get(String key, int timestamp) Returns a value such that set was called previously, with timestamp_prev <= timestamp. If there are multiple such values, it returns the value associated with the largest timestamp_prev. If there are no values, it returns \"\".\n\nExample 1:\nInput\n[\"TimeMap\", \"set\", \"get\", \"get\", \"set\", \"get\", \"get\"]\n[[], [\"foo\", \"bar\", 1], [\"foo\", 1], [\"foo\", 3], [\"foo\", \"bar2\", 4], [\"foo\", 4], [\"foo\", 5]]\nOutput\n[null, null, \"bar\", \"bar\", null, \"bar2\", \"bar2\"]\n\nExplanation\nTimeMap timeMap = new TimeMap();\ntimeMap.set(\"foo\", \"bar\", 1);  // store the key \"foo\" and value \"bar\" along with timestamp = 1.\ntimeMap.get(\"foo\", 1);         // return \"bar\"\ntimeMap.get(\"foo\", 3);         // return \"bar\", since there is no value corresponding to foo at timestamp 3 and timestamp 2, then the only value is at timestamp 1 is \"bar\".\ntimeMap.set(\"foo\", \"bar2\", 4); // store the key \"foo\" and value \"bar2\" along with timestamp = 4.\ntimeMap.get(\"foo\", 4);         // return \"bar2\"\ntimeMap.get(\"foo\", 5);         // return \"bar2\"\n\nConstraints:\n• 1 <= key.length, value.length <= 100\n• key and value consist of lowercase English letters and digits.\n• 1 <= timestamp <= 10^7\n• All the timestamps timestamp of set are strictly increasing.\n• At most 2 * 10^5 calls will be made to set and get.",
          "approach": "Use hash map to store lists of (timestamp, value) pairs for each key. Binary search to find the latest timestamp <= given timestamp.",
          "solution": "Store data in defaultdict(list) and use bisect for binary search on timestamps with proper boundary handling.",
          "code": "import collections\nimport bisect\n\nclass TimeMap:\n    def __init__(self):\n        self.store = collections.defaultdict(list)\n\n    def set(self, key, value, timestamp):\n        self.store[key].append((timestamp, value))\n\n    def get(self, key, timestamp):\n        items = self.store[key]\n        i = bisect.bisect(items, (timestamp, chr(127)))\n        return items[i-1][1] if i else \"\"\n\n# Test cases\ntimeMap = TimeMap()\ntimeMap.set(\"foo\", \"bar\", 1)\nprint(timeMap.get(\"foo\", 1))  # \"bar\"\nprint(timeMap.get(\"foo\", 3))  # \"bar\"\ntimeMap.set(\"foo\", \"bar2\", 4)\nprint(timeMap.get(\"foo\", 4))  # \"bar2\"\nprint(timeMap.get(\"foo\", 5))  # \"bar2\"",
          "timeComplexity": "• set: O(1) append to list\n• get: O(log n) binary search where n is number of timestamps for the key",
          "spaceComplexity": "O(n) where n is total number of set operations",
          "keyInsights": "• Use bisect with sentinel value chr(127) for proper boundary handling\n• Timestamps are strictly increasing, so no need to sort\n• Binary search finds insertion point, we want the element just before\n• Design pattern: hash map + binary search for time-based queries",
          "link": "https://leetcode.com/problems/time-based-key-value-store/"
        },
        {
          "id": "bs_7",
          "title": "Median of Two Sorted Arrays",
          "routeName": "median_two_sorted_arrays",
          "difficulty": "Hard",
          "leetcodeNumber": 4,
          "companies": ["Google", "Amazon", "Microsoft", "Facebook"],
          "tags": ["Array", "Binary Search", "Divide and Conquer"],
          "description": "Find median of two sorted arrays in O(log(min(m,n))) using binary search partition method.",
          "detailedDescription": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\n\nThe overall run time complexity should be O(log (m+n)).\n\nExample 1:\nInput: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.\n\nExample 2:\nInput: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n\nConstraints:\n• nums1.length == m\n• nums2.length == n\n• 0 <= m <= 1000\n• 0 <= n <= 1000\n• 1 <= m + n <= 2000\n• -10^6 <= nums1[i], nums2[i] <= 10^6",
          "approach": "Binary search on the smaller array to find the correct partition where left half has (m+n+1)//2 elements and all elements in left half <= all elements in right half.",
          "solution": "Partition both arrays such that left partition has half the total elements. Adjust partition using binary search until valid partition is found.",
          "code": "def findMedianSortedArrays(nums1, nums2):\n    A, B = sorted((nums1, nums2), key=len)\n    m, n = len(A), len(B)\n    imin, imax = 0, m\n\n    while imin <= imax:\n        i = (imin + imax) // 2\n        j = (m + n + 1) // 2 - i\n        if i < m and B[j-1] > A[i]:\n            imin = i + 1\n        elif i > 0 and A[i-1] > B[j]:\n            imax = i - 1\n        else:\n            max_left = max(A[i-1] if i > 0 else float('-inf'),\n                           B[j-1] if j > 0 else float('-inf'))\n            if (m + n) % 2 == 1:\n                return max_left\n            min_right = min(A[i] if i < m else float('inf'),\n                            B[j] if j < n else float('inf'))\n            return (max_left + min_right) / 2.0\n\n# Test cases\ntest_cases = [\n    ([1,3], [2]),\n    ([1,2], [3,4]),\n    ([0,0], [0,0]),\n    ([], [1]),\n    ([2], [])\n]\n\nfor nums1, nums2 in test_cases:\n    result = findMedianSortedArrays(nums1, nums2)\n    print(f\"nums1: {nums1}, nums2: {nums2} -> median: {result}\")",
          "timeComplexity": "O(log(min(m,n))) where m and n are lengths of the two arrays",
          "spaceComplexity": "O(1) constant space complexity",
          "keyInsights": "• Always binary search on the smaller array for optimization\n• Partition constraint: left partition has (m+n+1)//2 elements\n• Valid partition: max(left) <= min(right)\n• Handle edge cases with infinity values for empty partitions\n• Most challenging binary search problem requiring careful boundary handling",
          "link": "https://leetcode.com/problems/median-of-two-sorted-arrays/"
        }
      ]
    },
    {
      "id": "linked-list",
      "title": "Linked List",
      "description": "Linked list manipulation, traversal, and advanced pointer techniques",
      "questions": [
        {
          "id": "ll_1",
          "title": "Reverse Linked List",
          "routeName": "reverse_linked_list",
          "difficulty": "Easy",
          "leetcodeNumber": 206,
          "companies": ["Amazon", "Google", "Microsoft", "Facebook"],
          "tags": ["Linked List", "Recursion"],
          "description": "Given the head of a singly linked list, reverse the list, and return the reversed list.",
          "detailedDescription": "Given the head of a singly linked list, reverse the list, and return the reversed list.\n\nExample 1:\nInput: head = [1,2,3,4,5]\nOutput: [5,4,3,2,1]\n\nExample 2:\nInput: head = [1,2]\nOutput: [2,1]\n\nExample 3:\nInput: head = []\nOutput: []\n\nConstraints:\n• The number of nodes in the list is the range [0, 5000].\n• -5000 <= Node.val <= 5000\n\nFollow up: A linked list can be reversed either iteratively or recursively. Could you implement both?",
          "approach": "Iterative approach using three pointers to reverse the links between nodes.",
          "solution": "Use prev, curr, and next pointers to reverse the direction of links while traversing the list.",
          "code": "def reverseList(head):\n    prev = None\n    curr = head\n    while curr:\n        nxt = curr.next\n        curr.next = prev\n        prev = curr\n        curr = nxt\n    return prev\n\n# Alternative recursive solution\ndef reverseListRecursive(head):\n    if not head or not head.next:\n        return head\n    \n    new_head = reverseListRecursive(head.next)\n    head.next.next = head\n    head.next = None\n    return new_head\n\n# Test with ListNode class\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n# Helper function to print list\ndef print_list(head):\n    result = []\n    while head:\n        result.append(head.val)\n        head = head.next\n    return result\n\n# Test case\nhead = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5)))))\nreversed_head = reverseList(head)\nprint(print_list(reversed_head))  # [5, 4, 3, 2, 1]",
          "timeComplexity": "O(n) where n is the number of nodes in the linked list",
          "spaceComplexity": "O(1) for iterative, O(n) for recursive due to call stack",
          "keyInsights": "• Three-pointer technique is fundamental for linked list manipulation\n• Always store next node before breaking the link\n• Recursive solution reverses from the end and works backwards\n• Foundation pattern for many linked list problems",
          "link": "https://leetcode.com/problems/reverse-linked-list/"
        },
        {
          "id": "ll_2",
          "title": "Merge Two Sorted Lists",
          "routeName": "merge_two_sorted_lists",
          "difficulty": "Easy",
          "leetcodeNumber": 21,
          "companies": ["Amazon", "Google", "Microsoft", "Apple"],
          "tags": ["Linked List", "Recursion"],
          "description": "You are given the heads of two sorted linked lists list1 and list2. Merge the two lists in a one sorted list.",
          "detailedDescription": "You are given the heads of two sorted linked lists list1 and list2.\n\nMerge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.\n\nReturn the head of the merged linked list.\n\nExample 1:\nInput: list1 = [1,2,4], list2 = [1,3,4]\nOutput: [1,1,2,3,4,4]\n\nExample 2:\nInput: list1 = [], list2 = []\nOutput: []\n\nExample 3:\nInput: list1 = [], list2 = [0]\nOutput: [0]\n\nConstraints:\n• The number of nodes in both lists is in the range [0, 50].\n• -100 <= Node.val <= 100\n• Both list1 and list2 are sorted in non-decreasing order.",
          "approach": "Use dummy node technique with two pointers to merge lists by comparing values.",
          "solution": "Create dummy head, compare values from both lists, and link smaller nodes while advancing pointers.",
          "code": "def mergeTwoLists(l1, l2):\n    dummy = tail = ListNode(0)\n    while l1 and l2:\n        if l1.val < l2.val:\n            tail.next = l1\n            l1 = l1.next\n        else:\n            tail.next = l2\n            l2 = l2.next\n        tail = tail.next\n    tail.next = l1 or l2\n    return dummy.next\n\n# Recursive solution\ndef mergeTwoListsRecursive(l1, l2):\n    if not l1:\n        return l2\n    if not l2:\n        return l1\n    \n    if l1.val < l2.val:\n        l1.next = mergeTwoListsRecursive(l1.next, l2)\n        return l1\n    else:\n        l2.next = mergeTwoListsRecursive(l1, l2.next)\n        return l2\n\n# Test case\nl1 = ListNode(1, ListNode(2, ListNode(4)))\nl2 = ListNode(1, ListNode(3, ListNode(4)))\nmerged = mergeTwoLists(l1, l2)\nprint(print_list(merged))  # [1, 1, 2, 3, 4, 4]",
          "timeComplexity": "O(m + n) where m and n are lengths of the two lists",
          "spaceComplexity": "O(1) for iterative, O(m + n) for recursive due to call stack",
          "keyInsights": "• Dummy node simplifies edge cases and code structure\n• tail.next = l1 or l2 handles remaining nodes elegantly\n• Two-pointer technique for merging sorted structures\n• Foundation for merge sort and other divide-and-conquer algorithms",
          "link": "https://leetcode.com/problems/merge-two-sorted-lists/"
        },
        {
          "id": "ll_3",
          "title": "Linked List Cycle",
          "routeName": "linked_list_cycle",
          "difficulty": "Easy",
          "leetcodeNumber": 141,
          "companies": ["Amazon", "Google", "Microsoft", "Facebook"],
          "tags": ["Hash Table", "Linked List", "Two Pointers"],
          "description": "Given head, the head of a linked list, determine if the linked list has a cycle in it.",
          "detailedDescription": "Given head, the head of a linked list, determine if the linked list has a cycle in it.\n\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter.\n\nReturn true if there is a cycle in the linked list. Otherwise, return false.\n\nExample 1:\nInput: head = [3,2,0,-4], pos = 1\nOutput: true\nExplanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).\n\nExample 2:\nInput: head = [1,2], pos = 0\nOutput: true\nExplanation: There is a cycle in the linked list, where the tail connects to the 0th node.\n\nExample 3:\nInput: head = [1], pos = -1\nOutput: false\nExplanation: There is no cycle in the linked list.\n\nConstraints:\n• The number of the nodes in the list is in the range [0, 10^4].\n• -10^5 <= Node.val <= 10^5\n• pos is -1 or a valid index in the linked-list.\n\nFollow up: Can you solve it using O(1) (i.e. constant) memory?",
          "approach": "Floyd's Cycle Detection Algorithm (Tortoise and Hare) using two pointers moving at different speeds.",
          "solution": "Use slow and fast pointers. If there's a cycle, fast pointer will eventually meet slow pointer.",
          "code": "def hasCycle(head):\n    slow = fast = head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n        if slow == fast:\n            return True\n    return False\n\n# Alternative with hash set\ndef hasCycleHashSet(head):\n    visited = set()\n    while head:\n        if head in visited:\n            return True\n        visited.add(head)\n        head = head.next\n    return False\n\n# Test case with cycle\nhead = ListNode(3)\nnode2 = ListNode(2)\nnode3 = ListNode(0)\nnode4 = ListNode(-4)\nhead.next = node2\nnode2.next = node3\nnode3.next = node4\nnode4.next = node2  # Creates cycle\n\nprint(hasCycle(head))  # True",
          "timeComplexity": "O(n) where n is the number of nodes in the linked list",
          "spaceComplexity": "O(1) for Floyd's algorithm, O(n) for hash set approach",
          "keyInsights": "• Floyd's algorithm is elegant O(1) space solution\n• Fast pointer moves twice as fast as slow pointer\n• If cycle exists, fast will 'lap' slow pointer inside the cycle\n• This algorithm is foundation for finding cycle start position",
          "link": "https://leetcode.com/problems/linked-list-cycle/"
        },
        {
          "id": "ll_4",
          "title": "Reorder List",
          "routeName": "reorder_list",
          "difficulty": "Medium",
          "leetcodeNumber": 143,
          "companies": ["Amazon", "Google", "Microsoft", "Facebook"],
          "tags": ["Linked List", "Two Pointers", "Stack", "Recursion"],
          "description": "You are given the head of a singly linked-list. The list can be represented as: L0 → L1 → … → Ln - 1 → Ln. Reorder the list to be on the following form: L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …",
          "detailedDescription": "You are given the head of a singly linked-list. The list can be represented as:\nL0 → L1 → … → Ln - 1 → Ln\n\nReorder the list to be on the following form:\nL0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …\n\nYou may not modify the values in the list's nodes. Only nodes themselves may be changed.\n\nExample 1:\nInput: head = [1,2,3,4]\nOutput: [1,4,2,3]\n\nExample 2:\nInput: head = [1,2,3,4,5]\nOutput: [1,5,2,4,3]\n\nConstraints:\n• The number of nodes in the list is in the range [1, 5 * 10^4].\n• 1 <= Node.val <= 1000",
          "approach": "Three-step process: 1) Find middle, 2) Reverse second half, 3) Merge alternately.",
          "solution": "Split list at middle, reverse second half, then merge first and reversed second half alternately.",
          "code": "def reorderList(head):\n    # Step 1: Find the middle of the list\n    slow, fast = head, head.next\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n\n    # Step 2: Reverse the second half\n    second = slow.next\n    slow.next = None\n    prev = None\n    while second:\n        tmp = second.next\n        second.next = prev\n        prev = second\n        second = tmp\n\n    # Step 3: Merge the two halves\n    first, second = head, prev\n    while second:\n        tmp1, tmp2 = first.next, second.next\n        first.next = second\n        second.next = tmp1\n        first = tmp1\n        second = tmp2\n\n# Test case\nhead = ListNode(1, ListNode(2, ListNode(3, ListNode(4))))\nreorderList(head)\nprint(print_list(head))  # [1, 4, 2, 3]",
          "timeComplexity": "O(n) where n is the number of nodes in the linked list",
          "spaceComplexity": "O(1) constant space complexity",
          "keyInsights": "• Combines multiple linked list techniques: find middle, reverse, merge\n• Use slow/fast pointers to find middle in one pass\n• Careful pointer management during merging phase\n• In-place solution without extra data structures",
          "link": "https://leetcode.com/problems/reorder-list/"
        },
        {
          "id": "ll_5",
          "title": "Remove Nth Node From End of List",
          "routeName": "remove_nth_from_end",
          "difficulty": "Medium",
          "leetcodeNumber": 19,
          "companies": ["Amazon", "Google", "Microsoft", "Facebook"],
          "tags": ["Linked List", "Two Pointers"],
          "description": "Given the head of a linked list, remove the nth node from the end of the list and return its head.",
          "detailedDescription": "Given the head of a linked list, remove the nth node from the end of the list and return its head.\n\nExample 1:\nInput: head = [1,2,3,4,5], n = 2\nOutput: [1,2,3,5]\n\nExample 2:\nInput: head = [1], n = 1\nOutput: []\n\nExample 3:\nInput: head = [1,2], n = 1\nOutput: [1]\n\nConstraints:\n• The number of nodes in the list is sz.\n• 1 <= sz <= 30\n• 0 <= Node.val <= 100\n• 1 <= n <= sz\n\nFollow up: Could you do this in one pass?",
          "approach": "Two-pointer technique with n-gap between fast and slow pointers.",
          "solution": "Use dummy node and two pointers with n+1 gap to find the node before the one to remove.",
          "code": "def removeNthFromEnd(head, n):\n    dummy = ListNode(0)\n    dummy.next = head\n    fast = slow = dummy\n    \n    # Move fast pointer n steps ahead\n    for _ in range(n):\n        fast = fast.next\n    \n    # Move both pointers until fast reaches the end\n    while fast.next:\n        fast = fast.next\n        slow = slow.next\n    \n    # Remove the nth node from end\n    slow.next = slow.next.next\n    return dummy.next\n\n# Alternative two-pass solution\ndef removeNthFromEndTwoPass(head, n):\n    # First pass: count nodes\n    length = 0\n    curr = head\n    while curr:\n        length += 1\n        curr = curr.next\n    \n    # Edge case: remove head\n    if length == n:\n        return head.next\n    \n    # Second pass: find node before target\n    curr = head\n    for _ in range(length - n - 1):\n        curr = curr.next\n    \n    curr.next = curr.next.next\n    return head\n\n# Test case\nhead = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5)))))\nresult = removeNthFromEnd(head, 2)\nprint(print_list(result))  # [1, 2, 3, 5]",
          "timeComplexity": "O(n) where n is the number of nodes in the linked list",
          "spaceComplexity": "O(1) constant space complexity",
          "keyInsights": "• Dummy node handles edge case of removing head elegantly\n• Two-pointer technique with gap eliminates need for length calculation\n• Gap of n positions ensures slow pointer stops at node before target\n• One-pass solution is more efficient than two-pass approach",
          "link": "https://leetcode.com/problems/remove-nth-node-from-end-of-list/"
        },
        {
          "id": "ll_6",
          "title": "Copy List with Random Pointer",
          "routeName": "copy_list_random_pointer",
          "difficulty": "Medium",
          "leetcodeNumber": 138,
          "companies": ["Amazon", "Google", "Microsoft", "Facebook"],
          "tags": ["Hash Table", "Linked List"],
          "description": "A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null.",
          "detailedDescription": "A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null.\n\nConstruct a deep copy of the list. The deep copy should consist of exactly n brand new nodes, where each new node has its value set to the value of its corresponding original node. Both the next and random pointers of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. None of the pointers in the new list should point to nodes in the original list.\n\nFor example, if there are two nodes X and Y in the original list, where X.random --> Y, then for the corresponding two nodes x and y in the copied list, x.random --> y.\n\nReturn the head of the copied linked list.\n\nThe linked list is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where:\n• val: an integer representing Node.val\n• random_index: the index of the node (range from 0 to n-1) that the random pointer points to, or null if it does not point to any node.\n\nYour code will only be given the head of the original linked list.\n\nExample 1:\nInput: head = [[7,null],[13,0],[11,4],[10,2],[1,0]]\nOutput: [[7,null],[13,0],[11,4],[10,2],[1,0]]\n\nExample 2:\nInput: head = [[1,1],[2,1]]\nOutput: [[1,1],[2,1]]\n\nExample 3:\nInput: head = [[3,null],[3,0],[3,null]]\nOutput: [[3,null],[3,0],[3,null]]\n\nConstraints:\n• 0 <= n <= 1000\n• -10^4 <= Node.val <= 10^4\n• Node.random is null or is pointing to some node in the linked list.",
          "approach": "Three-pass algorithm: 1) Create interleaved list, 2) Set random pointers, 3) Separate lists.",
          "solution": "Insert copy nodes between original nodes, copy random pointers, then separate the two lists.",
          "code": "def copyRandomList(head):\n    if not head:\n        return None\n    \n    # Step 1: Create copy nodes and interleave with original\n    curr = head\n    while curr:\n        new_node = Node(curr.val, curr.next, None)\n        curr.next = new_node\n        curr = new_node.next\n    \n    # Step 2: Set random pointers for copy nodes\n    curr = head\n    while curr:\n        if curr.random:\n            curr.next.random = curr.random.next\n        curr = curr.next.next\n    \n    # Step 3: Separate original and copy lists\n    old_list, new_list = head, head.next\n    new_head = head.next\n    while old_list:\n        old_list.next = old_list.next.next\n        new_list.next = new_list.next.next if new_list.next else None\n        old_list = old_list.next\n        new_list = new_list.next\n    \n    return new_head\n\n# Alternative hash map solution\ndef copyRandomListHashMap(head):\n    if not head:\n        return None\n    \n    # Create mapping from original to copy nodes\n    node_map = {}\n    curr = head\n    \n    # First pass: create all copy nodes\n    while curr:\n        node_map[curr] = Node(curr.val)\n        curr = curr.next\n    \n    # Second pass: set next and random pointers\n    curr = head\n    while curr:\n        if curr.next:\n            node_map[curr].next = node_map[curr.next]\n        if curr.random:\n            node_map[curr].random = node_map[curr.random]\n        curr = curr.next\n    \n    return node_map[head]\n\nclass Node:\n    def __init__(self, val=0, next=None, random=None):\n        self.val = val\n        self.next = next\n        self.random = random",
          "timeComplexity": "O(n) where n is the number of nodes in the linked list",
          "spaceComplexity": "O(1) for interleaving approach, O(n) for hash map approach",
          "keyInsights": "• Interleaving technique achieves O(1) space without hash map\n• Three-pass algorithm cleanly separates concerns\n• Hash map approach is more intuitive but uses extra space\n• Careful pointer manipulation required during separation phase",
          "link": "https://leetcode.com/problems/copy-list-with-random-pointer/"
        },
        {
          "id": "ll_7",
          "title": "Add Two Numbers",
          "routeName": "add_two_numbers",
          "difficulty": "Medium",
          "leetcodeNumber": 2,
          "companies": ["Amazon", "Google", "Microsoft", "Facebook"],
          "tags": ["Linked List", "Math", "Recursion"],
          "description": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.",
          "detailedDescription": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\n\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n\nExample 1:\nInput: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.\n\nExample 2:\nInput: l1 = [0], l2 = [0]\nOutput: [0]\n\nExample 3:\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]\n\nConstraints:\n• The number of nodes in each linked list is in the range [1, 100].\n• 0 <= Node.val <= 9\n• It is guaranteed that the list represents a number that does not have leading zeros.",
          "approach": "Simulate addition with carry, process digits from least to most significant.",
          "solution": "Use dummy node, track carry, and handle different length lists with divmod for clean carry calculation.",
          "code": "def addTwoNumbers(l1, l2):\n    dummy = tail = ListNode(0)\n    carry = 0\n    while l1 or l2 or carry:\n        v1 = l1.val if l1 else 0\n        v2 = l2.val if l2 else 0\n        carry, val = divmod(v1 + v2 + carry, 10)\n        tail.next = ListNode(val)\n        tail = tail.next\n        l1 = l1.next if l1 else None\n        l2 = l2.next if l2 else None\n    return dummy.next\n\n# Alternative without divmod\ndef addTwoNumbersAlternative(l1, l2):\n    dummy = tail = ListNode(0)\n    carry = 0\n    \n    while l1 or l2 or carry:\n        total = carry\n        if l1:\n            total += l1.val\n            l1 = l1.next\n        if l2:\n            total += l2.val\n            l2 = l2.next\n        \n        carry = total // 10\n        digit = total % 10\n        tail.next = ListNode(digit)\n        tail = tail.next\n    \n    return dummy.next\n\n# Test case\nl1 = ListNode(2, ListNode(4, ListNode(3)))\nl2 = ListNode(5, ListNode(6, ListNode(4)))\nresult = addTwoNumbers(l1, l2)\nprint(print_list(result))  # [7, 0, 8]",
          "timeComplexity": "O(max(m, n)) where m and n are lengths of the two linked lists",
          "spaceComplexity": "O(max(m, n)) for the result linked list",
          "keyInsights": "• divmod(sum, 10) elegantly handles carry and digit calculation\n• Continue loop while any list has nodes OR carry exists\n• Dummy node simplifies result list construction\n• Handle unequal length lists by treating missing nodes as 0",
          "link": "https://leetcode.com/problems/add-two-numbers/"
        },
        {
          "id": "ll_8",
          "title": "Find the Duplicate Number",
          "routeName": "find_duplicate_number",
          "difficulty": "Medium",
          "leetcodeNumber": 287,
          "companies": ["Amazon", "Google", "Microsoft", "Facebook"],
          "tags": [
            "Array",
            "Two Pointers",
            "Binary Search",
            "Bit Manipulation"
          ],
          "description": "Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive. There is only one repeated number in nums, return this repeated number.",
          "detailedDescription": "Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.\n\nThere is only one repeated number in nums, return this repeated number.\n\nYou must solve the problem without modifying the array nums and uses only constant extra space.\n\nExample 1:\nInput: nums = [1,3,4,2,2]\nOutput: 2\n\nExample 2:\nInput: nums = [3,1,3,4,2]\nOutput: 3\n\nConstraints:\n• 1 <= n <= 10^5\n• nums.length == n + 1\n• 1 <= nums[i] <= n\n• All the integers in nums appear only once except for one integer which appears two or more times.\n\nFollow up:\n• How can we prove that at least one duplicate number must exist in nums?\n• Can you solve the problem in linear runtime complexity?",
          "approach": "Floyd's Cycle Detection Algorithm treating array as implicit linked list where nums[i] points to nums[nums[i]].",
          "solution": "Use slow/fast pointers to detect cycle, then find cycle start which is the duplicate number.",
          "code": "def findDuplicate(nums):\n    # Phase 1: Detect cycle using Floyd's algorithm\n    slow = fast = nums[0]\n    while True:\n        slow = nums[slow]\n        fast = nums[nums[fast]]\n        if slow == fast:\n            break\n    \n    # Phase 2: Find the start of the cycle\n    slow2 = nums[0]\n    while slow != slow2:\n        slow = nums[slow]\n        slow2 = nums[slow2]\n    \n    return slow\n\n# Alternative binary search solution\ndef findDuplicateBinarySearch(nums):\n    left, right = 1, len(nums) - 1\n    \n    while left < right:\n        mid = (left + right) // 2\n        count = sum(1 for num in nums if num <= mid)\n        \n        if count > mid:\n            right = mid\n        else:\n            left = mid + 1\n    \n    return left\n\n# Test cases\ntest_cases = [\n    [1,3,4,2,2],\n    [3,1,3,4,2],\n    [1,1],\n    [1,1,2]\n]\n\nfor nums in test_cases:\n    result = findDuplicate(nums)\n    print(f\"nums: {nums} -> duplicate: {result}\")",
          "timeComplexity": "O(n) for Floyd's algorithm, O(n log n) for binary search",
          "spaceComplexity": "O(1) constant space for both approaches",
          "keyInsights": "• Array indices and values form implicit linked list structure\n• Duplicate creates cycle in this implicit linked list\n• Floyd's algorithm finds cycle start = duplicate number\n• Binary search counts elements ≤ mid to determine search direction",
          "link": "https://leetcode.com/problems/find-the-duplicate-number/"
        },
        {
          "id": "ll_9",
          "title": "LRU Cache",
          "routeName": "lru_cache",
          "difficulty": "Medium",
          "leetcodeNumber": 146,
          "companies": ["Amazon", "Google", "Microsoft", "Facebook"],
          "tags": ["Hash Table", "Linked List", "Design"],
          "description": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.",
          "detailedDescription": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\n\nImplement the LRUCache class:\n• LRUCache(int capacity) Initialize the LRU cache with positive size capacity.\n• int get(int key) Return the value of the key if the key exists, otherwise return -1.\n• void put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.\n\nThe functions get and put must each run in O(1) average time complexity.\n\nExample 1:\nInput\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\nOutput\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\nExplanation\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // cache is {1=1}\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\nlRUCache.get(2);    // returns -1 (not found)\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\nlRUCache.get(1);    // return -1 (not found)\nlRUCache.get(3);    // return 3\nlRUCache.get(4);    // return 4\n\nConstraints:\n• 1 <= capacity <= 3000\n• 0 <= key <= 10^4\n• 0 <= value <= 10^5\n• At most 2 * 10^5 calls will be made to get and put.",
          "approach": "Use OrderedDict for O(1) operations with move_to_end for LRU ordering.",
          "solution": "OrderedDict maintains insertion order, move_to_end updates access order, popitem(last=False) removes LRU item.",
          "code": "from collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity):\n        self.cache = OrderedDict()\n        self.capacity = capacity\n\n    def get(self, key):\n        if key not in self.cache:\n            return -1\n        # Move to end (most recently used)\n        self.cache.move_to_end(key)\n        return self.cache[key]\n\n    def put(self, key, value):\n        if key in self.cache:\n            # Update existing key\n            self.cache.move_to_end(key)\n        self.cache[key] = value\n        if len(self.cache) > self.capacity:\n            # Remove least recently used (first item)\n            self.cache.popitem(last=False)\n\n# Alternative implementation with doubly linked list + hash map\nclass DLLNode:\n    def __init__(self, key=0, val=0):\n        self.key = key\n        self.val = val\n        self.prev = None\n        self.next = None\n\nclass LRUCacheLinkedList:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.cache = {}  # key -> node\n        \n        # Create dummy head and tail\n        self.head = DLLNode()\n        self.tail = DLLNode()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n    \n    def _add_node(self, node):\n        # Add node right after head\n        node.prev = self.head\n        node.next = self.head.next\n        self.head.next.prev = node\n        self.head.next = node\n    \n    def _remove_node(self, node):\n        # Remove an existing node\n        prev_node = node.prev\n        new_node = node.next\n        prev_node.next = new_node\n        new_node.prev = prev_node\n    \n    def _move_to_head(self, node):\n        # Move node to head (most recent)\n        self._remove_node(node)\n        self._add_node(node)\n    \n    def _pop_tail(self):\n        # Pop last node (least recent)\n        last_node = self.tail.prev\n        self._remove_node(last_node)\n        return last_node\n    \n    def get(self, key):\n        node = self.cache.get(key)\n        if not node:\n            return -1\n        # Move to head\n        self._move_to_head(node)\n        return node.val\n    \n    def put(self, key, value):\n        node = self.cache.get(key)\n        if not node:\n            new_node = DLLNode(key, value)\n            self.cache[key] = new_node\n            self._add_node(new_node)\n            \n            if len(self.cache) > self.capacity:\n                # Remove LRU\n                tail = self._pop_tail()\n                del self.cache[tail.key]\n        else:\n            # Update existing\n            node.val = value\n            self._move_to_head(node)\n\n# Test case\nlru = LRUCache(2)\nlru.put(1, 1)\nlru.put(2, 2)\nprint(lru.get(1))  # 1\nlru.put(3, 3)\nprint(lru.get(2))  # -1\nlru.put(4, 4)\nprint(lru.get(1))  # -1\nprint(lru.get(3))  # 3\nprint(lru.get(4))  # 4",
          "timeComplexity": "O(1) for both get and put operations",
          "spaceComplexity": "O(capacity) for storing up to capacity key-value pairs",
          "keyInsights": "• OrderedDict provides clean O(1) implementation\n• move_to_end() updates access order efficiently\n• popitem(last=False) removes least recently used item\n• Doubly linked list + hash map is the classic manual implementation",
          "link": "https://leetcode.com/problems/lru-cache/"
        },
        {
          "id": "ll_10",
          "title": "Merge k Sorted Lists",
          "routeName": "merge_k_sorted_lists",
          "difficulty": "Hard",
          "leetcodeNumber": 23,
          "companies": ["Amazon", "Google", "Microsoft", "Facebook"],
          "tags": [
            "Linked List",
            "Divide and Conquer",
            "Heap (Priority Queue)",
            "Merge Sort"
          ],
          "description": "You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it.",
          "detailedDescription": "You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\n\nMerge all the linked-lists into one sorted linked-list and return it.\n\nExample 1:\nInput: lists = [[1,4,5],[1,3,4],[2,6]]\nOutput: [1,1,2,3,4,4,5,6]\nExplanation: The linked-lists are:\n[\n  1->4->5,\n  1->3->4,\n  2->6\n]\nmerging them into one sorted list:\n1->1->2->3->4->4->5->6\n\nExample 2:\nInput: lists = []\nOutput: []\n\nExample 3:\nInput: lists = [[]]\nOutput: []\n\nConstraints:\n• k == lists.length\n• 0 <= k <= 10^4\n• 0 <= lists[i].length <= 500\n• -10^4 <= lists[i][j] <= 10^4\n• lists[i] is sorted in ascending order.\n• The sum of lists[i].length will not exceed 10^4.",
          "approach": "Min-heap approach to efficiently extract minimum values from multiple sorted lists.",
          "solution": "Add all values to heap, then build result list by popping from heap in sorted order.",
          "code": "import heapq\n\ndef mergeKLists(lists):\n    heap = []\n    \n    # Add all values to heap\n    for l in lists:\n        while l:\n            heapq.heappush(heap, l.val)\n            l = l.next\n    \n    # Build result list from heap\n    dummy = tail = ListNode(0)\n    while heap:\n        val = heapq.heappop(heap)\n        tail.next = ListNode(val)\n        tail = tail.next\n    \n    return dummy.next\n\n# Alternative divide and conquer approach\ndef mergeKListsDivideConquer(lists):\n    if not lists:\n        return None\n    \n    def merge_two_lists(l1, l2):\n        dummy = tail = ListNode(0)\n        while l1 and l2:\n            if l1.val < l2.val:\n                tail.next = l1\n                l1 = l1.next\n            else:\n                tail.next = l2\n                l2 = l2.next\n            tail = tail.next\n        tail.next = l1 or l2\n        return dummy.next\n    \n    while len(lists) > 1:\n        merged_lists = []\n        for i in range(0, len(lists), 2):\n            l1 = lists[i]\n            l2 = lists[i + 1] if i + 1 < len(lists) else None\n            merged_lists.append(merge_two_lists(l1, l2))\n        lists = merged_lists\n    \n    return lists[0]\n\n# Priority queue with node objects (more efficient)\ndef mergeKListsPriorityQueue(lists):\n    import heapq\n    \n    heap = []\n    \n    # Add first node of each list to heap\n    for i, l in enumerate(lists):\n        if l:\n            heapq.heappush(heap, (l.val, i, l))\n    \n    dummy = tail = ListNode(0)\n    \n    while heap:\n        val, i, node = heapq.heappop(heap)\n        tail.next = node\n        tail = tail.next\n        \n        if node.next:\n            heapq.heappush(heap, (node.next.val, i, node.next))\n    \n    return dummy.next\n\n# Test case\nlists = [\n    ListNode(1, ListNode(4, ListNode(5))),\n    ListNode(1, ListNode(3, ListNode(4))),\n    ListNode(2, ListNode(6))\n]\nresult = mergeKLists(lists)\nprint(print_list(result))  # [1, 1, 2, 3, 4, 4, 5, 6]",
          "timeComplexity": "• Heap approach: O(N log N) where N is total number of nodes\n• Divide and conquer: O(N log k) where k is number of lists\n• Priority queue: O(N log k) most efficient",
          "spaceComplexity": "• Heap approach: O(N) for storing all values\n• Divide and conquer: O(log k) for recursion stack\n• Priority queue: O(k) for heap size",
          "keyInsights": "• Heap approach is simple but recreates nodes\n• Divide and conquer reuses existing nodes efficiently\n• Priority queue with nodes is most optimal O(N log k) solution\n• Pattern extends to merging any k sorted sequences",
          "link": "https://leetcode.com/problems/merge-k-sorted-lists/"
        },
        {
          "id": "ll_11",
          "title": "Reverse Nodes in k-Group",
          "routeName": "reverse_nodes_k_group",
          "difficulty": "Hard",
          "leetcodeNumber": 25,
          "companies": ["Amazon", "Google", "Microsoft", "Facebook"],
          "tags": ["Linked List", "Recursion"],
          "description": "Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.",
          "detailedDescription": "Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.\n\nk is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as is.\n\nYou may not alter the values in the list's nodes, only nodes themselves may be changed.\n\nExample 1:\nInput: head = [1,2,3,4,5], k = 2\nOutput: [2,1,4,3,5]\n\nExample 2:\nInput: head = [1,2,3,4,5], k = 3\nOutput: [3,2,1,4,5]\n\nConstraints:\n• The number of nodes in the list is n.\n• 1 <= k <= n <= 5000\n• 0 <= Node.val <= 1000\n\nFollow-up: Can you solve the problem in O(1) extra memory (i.e., without recursion)?",
          "approach": "Recursive approach: check if k nodes exist, reverse them, then recursively process remaining list.",
          "solution": "Count k nodes, if available reverse them and recursively process rest, otherwise return unchanged.",
          "code": "def reverseKGroup(head, k):\n    def reverse(head, k):\n        prev = None\n        curr = head\n        while k:\n            nxt = curr.next\n            curr.next = prev\n            prev = curr\n            curr = nxt\n            k -= 1\n        return prev\n\n    # Check if we have k nodes to reverse\n    count = 0\n    curr = head\n    while curr and count != k:\n        curr = curr.next\n        count += 1\n    \n    if count == k:\n        # Reverse current k-group\n        reversed_head = reverse(head, k)\n        # Recursively process remaining list\n        head.next = reverseKGroup(curr, k)\n        return reversed_head\n    \n    return head\n\n# Iterative solution\ndef reverseKGroupIterative(head, k):\n    def reverse_between(start, end):\n        prev = start\n        curr = start.next\n        \n        while curr != end:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        \n        return prev\n    \n    def get_kth_node(curr, k):\n        while curr and k > 0:\n            curr = curr.next\n            k -= 1\n        return curr\n    \n    dummy = ListNode(0)\n    dummy.next = head\n    group_prev = dummy\n    \n    while True:\n        kth = get_kth_node(group_prev, k)\n        if not kth:\n            break\n        \n        group_next = kth.next\n        \n        # Reverse group\n        prev, curr = kth.next, group_prev.next\n        while curr != group_next:\n            next_temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_temp\n        \n        # Connect with previous group\n        tmp = group_prev.next\n        group_prev.next = kth\n        group_prev = tmp\n    \n    return dummy.next\n\n# Test cases\ntest_cases = [\n    ([1,2,3,4,5], 2),\n    ([1,2,3,4,5], 3),\n    ([1,2,3,4,5], 1),\n    ([1], 1)\n]\n\nfor values, k in test_cases:\n    # Create linked list\n    head = None\n    for val in reversed(values):\n        head = ListNode(val, head)\n    \n    result = reverseKGroup(head, k)\n    print(f\"values: {values}, k: {k} -> {print_list(result)}\")",
          "timeComplexity": "O(n) where n is the number of nodes in the linked list",
          "spaceComplexity": "O(n/k) for recursive calls, O(1) for iterative solution",
          "keyInsights": "• Count nodes first to ensure we have k nodes to reverse\n• Recursive approach is cleaner: reverse current group, recurse on rest\n• Original head becomes tail after reversal, so connect it to next group\n• Iterative solution uses dummy node for cleaner edge case handling",
          "link": "https://leetcode.com/problems/reverse-nodes-in-k-group/"
        }
      ]
    },
    {
      "id": "trees",
      "title": "Trees",
      "description": "Binary trees, binary search trees, tree traversals, and tree-based algorithms",
      "questions": [
        {
          "id": "tree_1",
          "title": "Invert Binary Tree",
          "routeName": "invert_binary_tree",
          "difficulty": "Easy",
          "leetcodeNumber": 226,
          "companies": ["Google", "Amazon", "Microsoft", "Facebook"],
          "tags": [
            "Tree",
            "Depth-First Search",
            "Breadth-First Search",
            "Binary Tree"
          ],
          "description": "Given the root of a binary tree, invert the tree, and return its root.",
          "detailedDescription": "Given the root of a binary tree, invert the tree, and return its root.\n\nExample 1:\nInput: root = [4,2,7,1,3,6,9]\nOutput: [4,7,2,9,6,3,1]\n\nExample 2:\nInput: root = [2,1,3]\nOutput: [2,3,1]\n\nExample 3:\nInput: root = []\nOutput: []\n\nConstraints:\n• The number of nodes in the tree is in the range [0, 100].\n• -100 <= Node.val <= 100",
          "approach": "Recursive approach to swap left and right children at each node.",
          "solution": "Recursively invert left and right subtrees, then swap them at current node.",
          "code": "def invertTree(root):\n    if not root:\n        return None\n    root.left, root.right = invertTree(root.right), invertTree(root.left)\n    return root\n\n# Alternative iterative approach\nfrom collections import deque\n\ndef invertTreeIterative(root):\n    if not root:\n        return None\n    \n    queue = deque([root])\n    while queue:\n        node = queue.popleft()\n        node.left, node.right = node.right, node.left\n        \n        if node.left:\n            queue.append(node.left)\n        if node.right:\n            queue.append(node.right)\n    \n    return root\n\n# TreeNode class for testing\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n# Test case\nroot = TreeNode(4)\nroot.left = TreeNode(2, TreeNode(1), TreeNode(3))\nroot.right = TreeNode(7, TreeNode(6), TreeNode(9))\ninverted = invertTree(root)",
          "timeComplexity": "O(n) where n is the number of nodes in the tree",
          "spaceComplexity": "O(h) where h is the height of the tree (recursion stack)",
          "keyInsights": "• Simple recursive pattern: process children first, then current node\n• Swapping can be done elegantly with tuple assignment\n• This is a classic tree traversal problem\n• Both DFS and BFS approaches work equally well",
          "link": "https://leetcode.com/problems/invert-binary-tree/"
        },
        {
          "id": "tree_2",
          "title": "Maximum Depth of Binary Tree",
          "routeName": "maximum_depth_binary_tree",
          "difficulty": "Easy",
          "leetcodeNumber": 104,
          "companies": ["Amazon", "Google", "Microsoft", "Facebook"],
          "tags": [
            "Tree",
            "Depth-First Search",
            "Breadth-First Search",
            "Binary Tree"
          ],
          "description": "Given the root of a binary tree, return its maximum depth.",
          "detailedDescription": "Given the root of a binary tree, return its maximum depth.\n\nA binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\n\nExample 1:\nInput: root = [3,9,20,null,null,15,7]\nOutput: 3\n\nExample 2:\nInput: root = [1,null,2]\nOutput: 2\n\nConstraints:\n• The number of nodes in the tree is in the range [0, 10^4].\n• -100 <= Node.val <= 100",
          "approach": "Recursive DFS to find maximum depth by taking max of left and right subtree depths plus 1.",
          "solution": "Base case returns 0 for null nodes, recursive case returns 1 + max of subtree depths.",
          "code": "def maxDepth(root):\n    if not root:\n        return 0\n    return 1 + max(maxDepth(root.left), maxDepth(root.right))\n\n# Alternative iterative BFS approach\nfrom collections import deque\n\ndef maxDepthBFS(root):\n    if not root:\n        return 0\n    \n    queue = deque([(root, 1)])\n    max_depth = 0\n    \n    while queue:\n        node, depth = queue.popleft()\n        max_depth = max(max_depth, depth)\n        \n        if node.left:\n            queue.append((node.left, depth + 1))\n        if node.right:\n            queue.append((node.right, depth + 1))\n    \n    return max_depth\n\n# Iterative DFS with stack\ndef maxDepthDFS(root):\n    if not root:\n        return 0\n    \n    stack = [(root, 1)]\n    max_depth = 0\n    \n    while stack:\n        node, depth = stack.pop()\n        max_depth = max(max_depth, depth)\n        \n        if node.left:\n            stack.append((node.left, depth + 1))\n        if node.right:\n            stack.append((node.right, depth + 1))\n    \n    return max_depth\n\n# Test case\nroot = TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7)))\nprint(maxDepth(root))  # Output: 3",
          "timeComplexity": "O(n) where n is the number of nodes in the tree",
          "spaceComplexity": "O(h) where h is the height of the tree",
          "keyInsights": "• Classic divide and conquer pattern\n• Recursive solution is most elegant and concise\n• Can be solved with DFS or BFS approaches\n• Foundation for many tree depth-related problems",
          "link": "https://leetcode.com/problems/maximum-depth-of-binary-tree/"
        },
        {
          "id": "tree_3",
          "title": "Diameter of Binary Tree",
          "routeName": "diameter_binary_tree",
          "difficulty": "Easy",
          "leetcodeNumber": 543,
          "companies": ["Amazon", "Google", "Microsoft", "Facebook"],
          "tags": ["Tree", "Depth-First Search", "Binary Tree"],
          "description": "Given the root of a binary tree, return the length of the diameter of the tree.",
          "detailedDescription": "Given the root of a binary tree, return the length of the diameter of the tree.\n\nThe diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.\n\nThe length of a path between two nodes is represented by the number of edges between them.\n\nExample 1:\nInput: root = [1,2,3,4,5]\nOutput: 3\nExplanation: 3 is the length of the path [4,2,1,3] or [5,2,1,3].\n\nExample 2:\nInput: root = [1,2]\nOutput: 1\n\nConstraints:\n• The number of nodes in the tree is in the range [1, 10^4].\n• -100 <= Node.val <= 100",
          "approach": "DFS with global variable to track maximum diameter while computing depths.",
          "solution": "For each node, diameter through that node is left_depth + right_depth. Track maximum globally.",
          "code": "def diameterOfBinaryTree(root):\n    diameter = 0\n    \n    def depth(node):\n        nonlocal diameter\n        if not node:\n            return 0\n        \n        left = depth(node.left)\n        right = depth(node.right)\n        \n        # Update diameter if path through current node is longer\n        diameter = max(diameter, left + right)\n        \n        # Return depth of current node\n        return 1 + max(left, right)\n    \n    depth(root)\n    return diameter\n\n# Alternative approach returning both depth and diameter\ndef diameterOfBinaryTreeAlt(root):\n    def helper(node):\n        if not node:\n            return 0, 0  # (depth, diameter)\n        \n        left_depth, left_diameter = helper(node.left)\n        right_depth, right_diameter = helper(node.right)\n        \n        current_depth = 1 + max(left_depth, right_depth)\n        current_diameter = max(\n            left_diameter,\n            right_diameter,\n            left_depth + right_depth\n        )\n        \n        return current_depth, current_diameter\n    \n    _, diameter = helper(root)\n    return diameter\n\n# Test case\nroot = TreeNode(1)\nroot.left = TreeNode(2, TreeNode(4), TreeNode(5))\nroot.right = TreeNode(3)\nprint(diameterOfBinaryTree(root))  # Output: 3",
          "timeComplexity": "O(n) where n is the number of nodes in the tree",
          "spaceComplexity": "O(h) where h is the height of the tree (recursion stack)",
          "keyInsights": "• Diameter through a node = left_depth + right_depth\n• Need to check diameter at every node, not just root\n• Use nonlocal variable to track global maximum\n• Each node's contribution to diameter is sum of its subtree depths",
          "link": "https://leetcode.com/problems/diameter-of-binary-tree/"
        },
        {
          "id": "tree_4",
          "title": "Balanced Binary Tree",
          "routeName": "balanced_binary_tree",
          "difficulty": "Easy",
          "leetcodeNumber": 110,
          "companies": ["Amazon", "Google", "Microsoft", "Facebook"],
          "tags": ["Tree", "Depth-First Search", "Binary Tree"],
          "description": "Given a binary tree, determine if it is height-balanced.",
          "detailedDescription": "Given a binary tree, determine if it is height-balanced.\n\nA height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.\n\nExample 1:\nInput: root = [3,9,20,null,null,15,7]\nOutput: true\n\nExample 2:\nInput: root = [1,2,2,3,3,null,null,4,4]\nOutput: false\n\nExample 3:\nInput: root = []\nOutput: true\n\nConstraints:\n• The number of nodes in the tree is in the range [0, 5000].\n• -10^4 <= Node.val <= 10^4",
          "approach": "DFS that returns height or -1 if unbalanced, checking balance condition at each node.",
          "solution": "Return -1 for unbalanced subtrees, otherwise return height. Check |left_height - right_height| <= 1.",
          "code": "def isBalanced(root):\n    def check(node):\n        if not node:\n            return 0\n        \n        left = check(node.left)\n        if left == -1:\n            return -1\n        \n        right = check(node.right)\n        if right == -1 or abs(left - right) > 1:\n            return -1\n        \n        return 1 + max(left, right)\n    \n    return check(root) != -1\n\n# Alternative approach with separate functions\ndef isBalancedAlt(root):\n    def height(node):\n        if not node:\n            return 0\n        return 1 + max(height(node.left), height(node.right))\n    \n    def balanced(node):\n        if not node:\n            return True\n        \n        left_height = height(node.left)\n        right_height = height(node.right)\n        \n        return (abs(left_height - right_height) <= 1 and \n                balanced(node.left) and \n                balanced(node.right))\n    \n    return balanced(root)\n\n# Test case\nroot = TreeNode(3)\nroot.left = TreeNode(9)\nroot.right = TreeNode(20, TreeNode(15), TreeNode(7))\nprint(isBalanced(root))  # Output: True",
          "timeComplexity": "O(n) for optimized solution, O(n²) for naive approach",
          "spaceComplexity": "O(h) where h is the height of the tree (recursion stack)",
          "keyInsights": "• Use -1 as sentinel value to propagate unbalanced state\n• Check balance condition while computing height to avoid redundant calculations\n• Early termination when unbalanced subtree is detected\n• Pattern: combine validation with computation for efficiency",
          "link": "https://leetcode.com/problems/balanced-binary-tree/"
        },
        {
          "id": "tree_5",
          "title": "Same Tree",
          "routeName": "same_tree",
          "difficulty": "Easy",
          "leetcodeNumber": 100,
          "companies": ["Amazon", "Google", "Microsoft", "Facebook"],
          "tags": [
            "Tree",
            "Depth-First Search",
            "Breadth-First Search",
            "Binary Tree"
          ],
          "description": "Given the roots of two binary trees p and q, write a function to check if they are the same or not.",
          "detailedDescription": "Given the roots of two binary trees p and q, write a function to check if they are the same or not.\n\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.\n\nExample 1:\nInput: p = [1,2,3], q = [1,2,3]\nOutput: true\n\nExample 2:\nInput: p = [1,2], q = [1,null,2]\nOutput: false\n\nExample 3:\nInput: p = [1,2,1], q = [1,1,2]\nOutput: false\n\nConstraints:\n• The number of nodes in both trees is in the range [0, 100].\n• -10^4 <= Node.val <= 10^4",
          "approach": "Recursive comparison of corresponding nodes in both trees.",
          "solution": "Base cases for null nodes, then check values and recursively compare left and right subtrees.",
          "code": "def isSameTree(p, q):\n    if not p and not q:\n        return True\n    if not p or not q or p.val != q.val:\n        return False\n    return isSameTree(p.left, q.left) and isSameTree(p.right, q.right)\n\n# Alternative iterative approach with stack\ndef isSameTreeIterative(p, q):\n    stack = [(p, q)]\n    \n    while stack:\n        node1, node2 = stack.pop()\n        \n        if not node1 and not node2:\n            continue\n        if not node1 or not node2 or node1.val != node2.val:\n            return False\n        \n        stack.append((node1.left, node2.left))\n        stack.append((node1.right, node2.right))\n    \n    return True\n\n# BFS approach with queue\nfrom collections import deque\n\ndef isSameTreeBFS(p, q):\n    queue = deque([(p, q)])\n    \n    while queue:\n        node1, node2 = queue.popleft()\n        \n        if not node1 and not node2:\n            continue\n        if not node1 or not node2 or node1.val != node2.val:\n            return False\n        \n        queue.append((node1.left, node2.left))\n        queue.append((node1.right, node2.right))\n    \n    return True\n\n# Test case\np = TreeNode(1, TreeNode(2), TreeNode(3))\nq = TreeNode(1, TreeNode(2), TreeNode(3))\nprint(isSameTree(p, q))  # Output: True",
          "timeComplexity": "O(n) where n is the minimum number of nodes in the two trees",
          "spaceComplexity": "O(h) where h is the height of the tree",
          "keyInsights": "• Handle null cases first for clean logic\n• Short-circuit evaluation with logical AND\n• Pattern applies to any tree comparison problem\n• Both recursive and iterative solutions work well",
          "link": "https://leetcode.com/problems/same-tree/"
        },
        {
          "id": "tree_6",
          "title": "Subtree of Another Tree",
          "routeName": "subtree_another_tree",
          "difficulty": "Easy",
          "leetcodeNumber": 572,
          "companies": ["Amazon", "Google", "Microsoft", "Facebook"],
          "tags": [
            "Tree",
            "Depth-First Search",
            "String Matching",
            "Binary Tree",
            "Hash Function"
          ],
          "description": "Given the roots of two binary trees root and subRoot, return true if there is a subtree of root with the same structure and node values of subRoot and false otherwise.",
          "detailedDescription": "Given the roots of two binary trees root and subRoot, return true if there is a subtree of root with the same structure and node values of subRoot and false otherwise.\n\nA subtree of a binary tree tree is a tree that consists of a node in tree and all of this node's descendants. The tree tree could also be considered as a subtree of itself.\n\nExample 1:\nInput: root = [3,4,5,1,2], subRoot = [4,1,2]\nOutput: true\n\nExample 2:\nInput: root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]\nOutput: false\n\nConstraints:\n• The number of nodes in the root tree is in the range [1, 2000].\n• The number of nodes in the subRoot tree is in the range [1, 1000].\n• -10^4 <= root.val <= 10^4\n• -10^4 <= subRoot.val <= 10^4",
          "approach": "For each node in main tree, check if subtree starting there matches the target subtree.",
          "solution": "Use helper function to check if two trees are identical, then check at each node of main tree.",
          "code": "def isSubtree(s, t):\n    def isSame(s, t):\n        if not s and not t:\n            return True\n        if not s or not t or s.val != t.val:\n            return False\n        return isSame(s.left, t.left) and isSame(s.right, t.right)\n    \n    if not s:\n        return False\n    if isSame(s, t):\n        return True\n    return isSubtree(s.left, t) or isSubtree(s.right, t)\n\n# Alternative approach using string serialization\ndef isSubtreeString(s, t):\n    def serialize(node):\n        if not node:\n            return '#'\n        return f'^{node.val},{serialize(node.left)},{serialize(node.right)}'\n    \n    return serialize(t) in serialize(s)\n\n# Test case\nroot = TreeNode(3)\nroot.left = TreeNode(4, TreeNode(1), TreeNode(2))\nroot.right = TreeNode(5)\n\nsubRoot = TreeNode(4, TreeNode(1), TreeNode(2))\nprint(isSubtree(root, subRoot))  # Output: True",
          "timeComplexity": "O(m * n) where m and n are the number of nodes in the trees",
          "spaceComplexity": "O(max(m, n)) for the recursion stack",
          "keyInsights": "• Combine tree traversal with tree comparison\n• Check for subtree match at every node of main tree\n• String serialization approach can be more efficient in some cases\n• Pattern: nested recursive functions for complex tree problems",
          "link": "https://leetcode.com/problems/subtree-of-another-tree/"
        },
        {
          "id": "tree_7",
          "title": "Lowest Common Ancestor of a BST",
          "routeName": "lca_bst",
          "difficulty": "Medium",
          "leetcodeNumber": 235,
          "companies": ["Amazon", "Google", "Microsoft", "Facebook"],
          "tags": [
            "Tree",
            "Depth-First Search",
            "Binary Search Tree",
            "Binary Tree"
          ],
          "description": "Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.",
          "detailedDescription": "Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.\n\nAccording to the definition of LCA on Wikipedia: 'The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).'\n\nExample 1:\nInput: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8\nOutput: 6\nExplanation: The LCA of nodes 2 and 8 is 6.\n\nExample 2:\nInput: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4\nOutput: 2\nExplanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.\n\nExample 3:\nInput: root = [2,1], p = 2, q = 1\nOutput: 2\n\nConstraints:\n• The number of nodes in the tree is in the range [2, 10^5].\n• -10^9 <= Node.val <= 10^9\n• All Node.val are unique.\n• p != q\n• p and q will exist in the BST.",
          "approach": "Use BST property: if both nodes are smaller, go left; if both larger, go right; otherwise current is LCA.",
          "solution": "Compare node values with current root to determine search direction using BST ordering property.",
          "code": "def lowestCommonAncestor(root, p, q):\n    if p.val < root.val > q.val:\n        return lowestCommonAncestor(root.left, p, q)\n    elif p.val > root.val < q.val:\n        return lowestCommonAncestor(root.right, p, q)\n    else:\n        return root\n\n# Alternative iterative approach\ndef lowestCommonAncestorIterative(root, p, q):\n    while root:\n        if p.val < root.val > q.val:\n            root = root.left\n        elif p.val > root.val < q.val:\n            root = root.right\n        else:\n            return root\n    return None\n\n# More explicit version\ndef lowestCommonAncestorExplicit(root, p, q):\n    while root:\n        if p.val < root.val and q.val < root.val:\n            root = root.left\n        elif p.val > root.val and q.val > root.val:\n            root = root.right\n        else:\n            return root\n    return None\n\n# Test case\nroot = TreeNode(6)\nroot.left = TreeNode(2, TreeNode(0), TreeNode(4, TreeNode(3), TreeNode(5)))\nroot.right = TreeNode(8, TreeNode(7), TreeNode(9))\np = root.left  # Node 2\nq = root.right  # Node 8\nprint(lowestCommonAncestor(root, p, q).val)  # Output: 6",
          "timeComplexity": "O(h) where h is the height of the tree",
          "spaceComplexity": "O(h) for recursive, O(1) for iterative approach",
          "keyInsights": "• BST property eliminates need to search both subtrees\n• LCA is the split point where paths to p and q diverge\n• If both nodes are on same side, continue in that direction\n• Current node is LCA when nodes are on different sides or one equals current",
          "link": "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/"
        },
        {
          "id": "tree_8",
          "title": "Binary Tree Level Order Traversal",
          "routeName": "level_order_traversal",
          "difficulty": "Medium",
          "leetcodeNumber": 102,
          "companies": ["Amazon", "Google", "Microsoft", "Facebook"],
          "tags": ["Tree", "Breadth-First Search", "Binary Tree"],
          "description": "Given the root of a binary tree, return the level order traversal of its nodes' values.",
          "detailedDescription": "Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).\n\nExample 1:\nInput: root = [3,9,20,null,null,15,7]\nOutput: [[3],[9,20],[15,7]]\n\nExample 2:\nInput: root = [1]\nOutput: [[1]]\n\nExample 3:\nInput: root = []\nOutput: []\n\nConstraints:\n• The number of nodes in the tree is in the range [0, 2000].\n• -1000 <= Node.val <= 1000",
          "approach": "BFS using queue, process all nodes at current level before moving to next level.",
          "solution": "Use queue to store nodes, process level by level using queue size to determine level boundaries.",
          "code": "from collections import deque\n\ndef levelOrder(root):\n    res = []\n    if not root:\n        return res\n    \n    queue = deque([root])\n    while queue:\n        level_size = len(queue)\n        level = []\n        \n        for _ in range(level_size):\n            node = queue.popleft()\n            level.append(node.val)\n            \n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        \n        res.append(level)\n    \n    return res\n\n# Alternative DFS approach\ndef levelOrderDFS(root):\n    result = []\n    \n    def dfs(node, level):\n        if not node:\n            return\n        \n        if len(result) == level:\n            result.append([])\n        \n        result[level].append(node.val)\n        dfs(node.left, level + 1)\n        dfs(node.right, level + 1)\n    \n    dfs(root, 0)\n    return result\n\n# Test case\nroot = TreeNode(3)\nroot.left = TreeNode(9)\nroot.right = TreeNode(20, TreeNode(15), TreeNode(7))\nprint(levelOrder(root))  # Output: [[3], [9, 20], [15, 7]]",
          "timeComplexity": "O(n) where n is the number of nodes in the tree",
          "spaceComplexity": "O(w) where w is the maximum width of the tree",
          "keyInsights": "• Use queue size to determine level boundaries\n• BFS naturally processes nodes level by level\n• DFS approach uses level parameter to group nodes\n• Foundation pattern for many level-based tree problems",
          "link": "https://leetcode.com/problems/binary-tree-level-order-traversal/"
        },
        {
          "id": "tree_9",
          "title": "Binary Tree Right Side View",
          "routeName": "right_side_view",
          "difficulty": "Medium",
          "leetcodeNumber": 199,
          "companies": ["Amazon", "Google", "Microsoft", "Facebook"],
          "tags": [
            "Tree",
            "Depth-First Search",
            "Breadth-First Search",
            "Binary Tree"
          ],
          "description": "Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.",
          "detailedDescription": "Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.\n\nExample 1:\nInput: root = [1,2,3,null,5,null,4]\nOutput: [1,3,4]\n\nExample 2:\nInput: root = [1,null,3]\nOutput: [1,3]\n\nExample 3:\nInput: root = []\nOutput: []\n\nConstraints:\n• The number of nodes in the tree is in the range [0, 100].\n• -100 <= Node.val <= 100",
          "approach": "BFS level order traversal, collect the rightmost node value at each level.",
          "solution": "Process nodes level by level, add the last node's value in each level to result.",
          "code": "from collections import deque\n\ndef rightSideView(root):\n    if not root:\n        return []\n    \n    queue = deque([root])\n    view = []\n    \n    while queue:\n        level_size = len(queue)\n        \n        for i in range(level_size):\n            node = queue.popleft()\n            \n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n            \n            # Add rightmost node of current level\n            if i == level_size - 1:\n                view.append(node.val)\n    \n    return view\n\n# Alternative DFS approach (right-first)\ndef rightSideViewDFS(root):\n    result = []\n    \n    def dfs(node, level):\n        if not node:\n            return\n        \n        # First time visiting this level\n        if level == len(result):\n            result.append(node.val)\n        \n        # Visit right first to ensure rightmost node is added first\n        dfs(node.right, level + 1)\n        dfs(node.left, level + 1)\n    \n    dfs(root, 0)\n    return result\n\n# Test case\nroot = TreeNode(1)\nroot.left = TreeNode(2, None, TreeNode(5))\nroot.right = TreeNode(3, None, TreeNode(4))\nprint(rightSideView(root))  # Output: [1, 3, 4]",
          "timeComplexity": "O(n) where n is the number of nodes in the tree",
          "spaceComplexity": "O(h) where h is the height of the tree",
          "keyInsights": "• Rightmost node in each level forms the right side view\n• BFS: track position in level to identify rightmost node\n• DFS: visit right subtree first to capture rightmost node per level\n• Pattern applies to left side view, top view, bottom view problems",
          "link": "https://leetcode.com/problems/binary-tree-right-side-view/"
        },
        {
          "id": "tree_10",
          "title": "Count Good Nodes in Binary Tree",
          "routeName": "count_good_nodes",
          "difficulty": "Medium",
          "leetcodeNumber": 1448,
          "companies": ["Amazon", "Google", "Microsoft", "Facebook"],
          "tags": ["Tree", "Depth-First Search", "Binary Tree"],
          "description": "Given a binary tree root, a node X in the tree is named good if in the path from root to X there are no nodes with a value greater than X.",
          "detailedDescription": "Given a binary tree root, a node X in the tree is named good if in the path from root to X there are no nodes with a value greater than X.\n\nReturn the number of good nodes in the binary tree.\n\nExample 1:\nInput: root = [3,1,4,3,null,1,5]\nOutput: 4\nExplanation: Nodes in blue are good.\nRoot Node (3) is always a good node.\nNode 4 -> (3,4) is the maximum value in the path starting from the root.\nNode 5 -> (3,4,5) is the maximum value in the path\nNode 3 -> (3,1,3) is the maximum value in the path.\n\nExample 2:\nInput: root = [3,3,null,4,2]\nOutput: 3\nExplanation: Node 2 -> (3, 3, 2) is not good, because \"3\" is higher than it.\n\nExample 3:\nInput: root = [1]\nOutput: 1\nExplanation: Root is considered as good.\n\nConstraints:\n• The number of nodes in the binary tree is in the range [1, 10^5].\n• Each node's value is between [-10^4, 10^4].",
          "approach": "DFS while tracking the maximum value seen along the path from root to current node.",
          "solution": "Pass down the maximum value in path, increment count if current node value >= max_val.",
          "code": "def goodNodes(root):\n    def dfs(node, max_val):\n        if not node:\n            return 0\n        \n        count = 1 if node.val >= max_val else 0\n        max_val = max(max_val, node.val)\n        \n        count += dfs(node.left, max_val)\n        count += dfs(node.right, max_val)\n        \n        return count\n    \n    return dfs(root, float('-inf'))\n\n# Alternative approach with explicit path tracking\ndef goodNodesPath(root):\n    def dfs(node, path_max):\n        if not node:\n            return 0\n        \n        result = 0\n        if node.val >= path_max:\n            result = 1\n        \n        new_max = max(path_max, node.val)\n        result += dfs(node.left, new_max)\n        result += dfs(node.right, new_max)\n        \n        return result\n    \n    return dfs(root, root.val)\n\n# Iterative approach with stack\ndef goodNodesIterative(root):\n    if not root:\n        return 0\n    \n    stack = [(root, float('-inf'))]\n    count = 0\n    \n    while stack:\n        node, max_val = stack.pop()\n        \n        if node.val >= max_val:\n            count += 1\n        \n        new_max = max(max_val, node.val)\n        \n        if node.left:\n            stack.append((node.left, new_max))\n        if node.right:\n            stack.append((node.right, new_max))\n    \n    return count\n\n# Test case\nroot = TreeNode(3)\nroot.left = TreeNode(1, TreeNode(3))\nroot.right = TreeNode(4, TreeNode(1), TreeNode(5))\nprint(goodNodes(root))  # Output: 4",
          "timeComplexity": "O(n) where n is the number of nodes in the tree",
          "spaceComplexity": "O(h) where h is the height of the tree (recursion stack)",
          "keyInsights": "• Pass down path information (max value) through DFS\n• Node is good if it's >= all ancestors in its path\n• Update path maximum at each level\n• Pattern: DFS with path state for tree problems requiring ancestor information",
          "link": "https://leetcode.com/problems/count-good-nodes-in-binary-tree/"
        },
        {
          "id": "tree_11",
          "title": "Validate Binary Search Tree",
          "routeName": "validate_bst",
          "difficulty": "Medium",
          "leetcodeNumber": 98,
          "companies": ["Amazon", "Google", "Microsoft", "Facebook"],
          "tags": [
            "Tree",
            "Depth-First Search",
            "Binary Search Tree",
            "Binary Tree"
          ],
          "description": "Given the root of a binary tree, determine if it is a valid binary search tree (BST).",
          "detailedDescription": "Given the root of a binary tree, determine if it is a valid binary search tree (BST).\n\nA valid BST is defined as follows:\n• The left subtree of a node contains only nodes with keys less than the node's key.\n• The right subtree of a node contains only nodes with keys greater than the node's key.\n• Both the left and right subtrees must also be binary search trees.\n\nExample 1:\nInput: root = [2,1,3]\nOutput: true\n\nExample 2:\nInput: root = [5,1,4,null,null,3,6]\nOutput: false\nExplanation: The root node's value is 5 but its right child's value is 4.\n\nConstraints:\n• The number of nodes in the tree is in the range [1, 10^4].\n• -2^31 <= Node.val <= 2^31 - 1",
          "approach": "DFS with valid range bounds (low, high) that get updated as we traverse the tree.",
          "solution": "For each node, check if value is in valid range, then recursively validate subtrees with updated bounds.",
          "code": "def isValidBST(root):\n    def helper(node, low, high):\n        if not node:\n            return True\n        \n        if not (low < node.val < high):\n            return False\n        \n        return (helper(node.left, low, node.val) and \n                helper(node.right, node.val, high))\n    \n    return helper(root, float('-inf'), float('inf'))\n\n# Alternative inorder traversal approach\ndef isValidBSTInorder(root):\n    def inorder(node):\n        if not node:\n            return []\n        return inorder(node.left) + [node.val] + inorder(node.right)\n    \n    values = inorder(root)\n    for i in range(1, len(values)):\n        if values[i] <= values[i-1]:\n            return False\n    return True\n\n# Optimized inorder with early termination\ndef isValidBSTInorderOptimized(root):\n    def inorder(node):\n        nonlocal prev\n        if not node:\n            return True\n        \n        if not inorder(node.left):\n            return False\n        \n        if prev is not None and node.val <= prev:\n            return False\n        prev = node.val\n        \n        return inorder(node.right)\n    \n    prev = None\n    return inorder(root)\n\n# Iterative approach\ndef isValidBSTIterative(root):\n    if not root:\n        return True\n    \n    stack = [(root, float('-inf'), float('inf'))]\n    \n    while stack:\n        node, low, high = stack.pop()\n        \n        if not (low < node.val < high):\n            return False\n        \n        if node.left:\n            stack.append((node.left, low, node.val))\n        if node.right:\n            stack.append((node.right, node.val, high))\n    \n    return True\n\n# Test case\nroot = TreeNode(2, TreeNode(1), TreeNode(3))\nprint(isValidBST(root))  # Output: True",
          "timeComplexity": "O(n) where n is the number of nodes in the tree",
          "spaceComplexity": "O(h) where h is the height of the tree",
          "keyInsights": "• Use bounds checking rather than just comparing with parent\n• Left child must be < parent, right child must be > parent\n• Bounds propagate down: left gets upper bound, right gets lower bound\n• Inorder traversal of valid BST produces sorted sequence",
          "link": "https://leetcode.com/problems/validate-binary-search-tree/"
        },
        {
          "id": "tree_12",
          "title": "Kth Smallest Element in BST",
          "routeName": "kth_smallest_bst",
          "difficulty": "Medium",
          "leetcodeNumber": 230,
          "companies": ["Amazon", "Google", "Microsoft", "Facebook"],
          "tags": [
            "Tree",
            "Depth-First Search",
            "Binary Search Tree",
            "Binary Tree"
          ],
          "description": "Given the root of a binary search tree, and an integer k, return the kth smallest value (1-indexed) of all the values of the nodes in the tree.",
          "detailedDescription": "Given the root of a binary search tree, and an integer k, return the kth smallest value (1-indexed) of all the values of the nodes in the tree.\n\nExample 1:\nInput: root = [3,1,4,null,2], k = 1\nOutput: 1\n\nExample 2:\nInput: root = [5,3,6,2,4,null,null,1], k = 3\nOutput: 3\n\nConstraints:\n• The number of nodes in the tree is n.\n• 1 <= k <= n <= 10^4\n• 0 <= Node.val <= 10^4\n\nFollow up: If the BST is modified often (i.e., we can do insert and delete operations) and you need to find the kth smallest frequently, how would you optimize it?",
          "approach": "Inorder traversal of BST produces sorted sequence, return kth element.",
          "solution": "Use iterative inorder traversal with stack, decrement k until reaching 0.",
          "code": "def kthSmallest(root, k):\n    stack = []\n    \n    while True:\n        while root:\n            stack.append(root)\n            root = root.left\n        \n        root = stack.pop()\n        k -= 1\n        if k == 0:\n            return root.val\n        \n        root = root.right\n\n# Alternative recursive approach\ndef kthSmallestRecursive(root, k):\n    def inorder(node):\n        if not node:\n            return []\n        return inorder(node.left) + [node.val] + inorder(node.right)\n    \n    return inorder(root)[k-1]\n\n# Optimized recursive with early termination\ndef kthSmallestOptimized(root, k):\n    def inorder(node):\n        nonlocal k\n        if not node or k == 0:\n            return None\n        \n        result = inorder(node.left)\n        if result is not None:\n            return result\n        \n        k -= 1\n        if k == 0:\n            return node.val\n        \n        return inorder(node.right)\n    \n    return inorder(root)\n\n# Follow-up: BST with rank (for frequent queries)\nclass TreeNodeWithSize:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.size = 1  # Number of nodes in subtree\n\ndef kthSmallestWithSize(root, k):\n    def get_size(node):\n        return node.size if node else 0\n    \n    while root:\n        left_size = get_size(root.left)\n        \n        if k <= left_size:\n            root = root.left\n        elif k > left_size + 1:\n            k -= left_size + 1\n            root = root.right\n        else:\n            return root.val\n    \n    return -1\n\n# Test case\nroot = TreeNode(3)\nroot.left = TreeNode(1, None, TreeNode(2))\nroot.right = TreeNode(4)\nprint(kthSmallest(root, 1))  # Output: 1",
          "timeComplexity": "O(h + k) where h is height of tree and k is the target rank",
          "spaceComplexity": "O(h) for the stack in iterative approach",
          "keyInsights": "• Inorder traversal of BST yields sorted sequence\n• Iterative approach allows early termination at kth element\n• For frequent queries, augment nodes with subtree size\n• Stack-based inorder is more space efficient than recursive",
          "link": "https://leetcode.com/problems/kth-smallest-element-in-a-bst/"
        },
        {
          "id": "tree_13",
          "title": "Construct Binary Tree from Preorder and Inorder Traversal",
          "routeName": "construct_tree_preorder_inorder",
          "difficulty": "Medium",
          "leetcodeNumber": 105,
          "companies": ["Amazon", "Google", "Microsoft", "Facebook"],
          "tags": [
            "Array",
            "Hash Table",
            "Divide and Conquer",
            "Tree",
            "Binary Tree"
          ],
          "description": "Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.",
          "detailedDescription": "Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.\n\nExample 1:\nInput: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]\nOutput: [3,9,20,null,null,15,7]\n\nExample 2:\nInput: preorder = [-1], inorder = [-1]\nOutput: [-1]\n\nConstraints:\n• 1 <= preorder.length <= 3000\n• inorder.length == preorder.length\n• -3000 <= preorder[i], inorder[i] <= 3000\n• preorder and inorder consist of unique values.\n• Each value of inorder also appears in preorder.\n• preorder is guaranteed to be the preorder traversal of the tree.\n• inorder is guaranteed to be the inorder traversal of the tree.",
          "approach": "Use preorder to identify root, inorder to split into left and right subtrees recursively.",
          "solution": "First element in preorder is root, find it in inorder to determine left/right subtree boundaries.",
          "code": "def buildTree(preorder, inorder):\n    if not preorder or not inorder:\n        return None\n    \n    root_val = preorder[0]\n    root = TreeNode(root_val)\n    mid = inorder.index(root_val)\n    \n    root.left = buildTree(preorder[1:mid+1], inorder[:mid])\n    root.right = buildTree(preorder[mid+1:], inorder[mid+1:])\n    \n    return root\n\n# Optimized version with hashmap for O(1) lookups\ndef buildTreeOptimized(preorder, inorder):\n    inorder_map = {val: i for i, val in enumerate(inorder)}\n    preorder_idx = [0]  # Use list to make it mutable in nested function\n    \n    def build(left, right):\n        if left > right:\n            return None\n        \n        root_val = preorder[preorder_idx[0]]\n        preorder_idx[0] += 1\n        \n        root = TreeNode(root_val)\n        mid = inorder_map[root_val]\n        \n        # Build left subtree first (preorder: root -> left -> right)\n        root.left = build(left, mid - 1)\n        root.right = build(mid + 1, right)\n        \n        return root\n    \n    return build(0, len(inorder) - 1)\n\n# Alternative approach with explicit index tracking\ndef buildTreeWithIndices(preorder, inorder):\n    def helper(pre_start, pre_end, in_start, in_end):\n        if pre_start > pre_end:\n            return None\n        \n        root_val = preorder[pre_start]\n        root = TreeNode(root_val)\n        \n        # Find root in inorder\n        mid = inorder.index(root_val)\n        left_size = mid - in_start\n        \n        root.left = helper(pre_start + 1, pre_start + left_size, \n                          in_start, mid - 1)\n        root.right = helper(pre_start + left_size + 1, pre_end, \n                           mid + 1, in_end)\n        \n        return root\n    \n    return helper(0, len(preorder) - 1, 0, len(inorder) - 1)\n\n# Test case\npreorder = [3, 9, 20, 15, 7]\ninorder = [9, 3, 15, 20, 7]\nroot = buildTree(preorder, inorder)",
          "timeComplexity": "O(n) with hashmap optimization, O(n²) with index() calls",
          "spaceComplexity": "O(n) for hashmap and recursion stack",
          "keyInsights": "• Preorder gives root order, inorder gives left/right split\n• First element of preorder is always the root\n• Root position in inorder determines left and right subtree sizes\n• Hashmap optimization avoids repeated linear searches",
          "link": "https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/"
        },
        {
          "id": "tree_14",
          "title": "Binary Tree Maximum Path Sum",
          "routeName": "max_path_sum",
          "difficulty": "Hard",
          "leetcodeNumber": 124,
          "companies": ["Amazon", "Google", "Microsoft", "Facebook"],
          "tags": [
            "Dynamic Programming",
            "Tree",
            "Depth-First Search",
            "Binary Tree"
          ],
          "description": "A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.",
          "detailedDescription": "A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.\n\nThe path sum of a path is the sum of the node's values in the path.\n\nGiven the root of a binary tree, return the maximum path sum of any non-empty path.\n\nExample 1:\nInput: root = [1,2,3]\nOutput: 6\nExplanation: The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6.\n\nExample 2:\nInput: root = [-10,9,20,null,null,15,7]\nOutput: 42\nExplanation: The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42.\n\nConstraints:\n• The number of nodes in the tree is in the range [1, 3 * 10^4].\n• -1000 <= Node.val <= 1000",
          "approach": "DFS that tracks two values: max gain from subtree and global maximum path sum.",
          "solution": "For each node, calculate max path through it and max gain it can contribute to parent.",
          "code": "def maxPathSum(root):\n    max_sum = float('-inf')\n    \n    def max_gain(node):\n        nonlocal max_sum\n        if not node:\n            return 0\n        \n        # Maximum gain from left and right subtrees (ignore negative gains)\n        left_gain = max(max_gain(node.left), 0)\n        right_gain = max(max_gain(node.right), 0)\n        \n        # Maximum path sum through current node\n        price_newpath = node.val + left_gain + right_gain\n        \n        # Update global maximum\n        max_sum = max(max_sum, price_newpath)\n        \n        # Return maximum gain current node can contribute to its parent\n        return node.val + max(left_gain, right_gain)\n    \n    max_gain(root)\n    return max_sum\n\n# Alternative approach with explicit return values\ndef maxPathSumAlt(root):\n    def helper(node):\n        if not node:\n            return 0, float('-inf')  # (max_gain, max_path)\n        \n        left_gain, left_path = helper(node.left)\n        right_gain, right_path = helper(node.right)\n        \n        # Current node's contribution\n        current_gain = node.val + max(0, max(left_gain, right_gain))\n        current_path = node.val + max(0, left_gain) + max(0, right_gain)\n        \n        # Overall maximum path\n        max_path = max(left_path, right_path, current_path)\n        \n        return current_gain, max_path\n    \n    _, result = helper(root)\n    return result\n\n# Test case\nroot = TreeNode(-10)\nroot.left = TreeNode(9)\nroot.right = TreeNode(20, TreeNode(15), TreeNode(7))\nprint(maxPathSum(root))  # Output: 42",
          "timeComplexity": "O(n) where n is the number of nodes in the tree",
          "spaceComplexity": "O(h) where h is the height of the tree (recursion stack)",
          "keyInsights": "• Distinguish between path through node vs. gain from subtree\n• Path through node includes both left and right gains\n• Gain from subtree can only include one child (to form valid path)\n• Ignore negative gains by taking max with 0\n• Track global maximum across all possible paths",
          "link": "https://leetcode.com/problems/binary-tree-maximum-path-sum/"
        },
        {
          "id": "tree_15",
          "title": "Serialize and Deserialize Binary Tree",
          "routeName": "serialize_deserialize_tree",
          "difficulty": "Hard",
          "leetcodeNumber": 297,
          "companies": ["Amazon", "Google", "Microsoft", "Facebook"],
          "tags": [
            "String",
            "Tree",
            "Depth-First Search",
            "Breadth-First Search",
            "Design",
            "Binary Tree"
          ],
          "description": "Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.",
          "detailedDescription": "Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\n\nDesign an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.\n\nClarification: The input/output format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.\n\nExample 1:\nInput: root = [1,2,3,null,null,4,5]\nOutput: [1,2,3,null,null,4,5]\n\nExample 2:\nInput: root = []\nOutput: []\n\nConstraints:\n• The number of nodes in the tree is in the range [0, 10^4].\n• -1000 <= Node.val <= 1000",
          "approach": "Use preorder DFS for serialization with null markers, and reconstruct using same order during deserialization.",
          "solution": "Serialize with preorder traversal and '#' for null nodes, deserialize by consuming tokens in preorder.",
          "code": "from collections import deque\n\nclass Codec:\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\"\"\"\n        vals = []\n        \n        def dfs(node):\n            if node:\n                vals.append(str(node.val))\n                dfs(node.left)\n                dfs(node.right)\n            else:\n                vals.append('#')\n        \n        dfs(root)\n        return ' '.join(vals)\n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\"\"\"\n        vals = deque(data.split())\n        \n        def dfs():\n            val = vals.popleft()\n            if val == '#':\n                return None\n            \n            node = TreeNode(int(val))\n            node.left = dfs()\n            node.right = dfs()\n            return node\n        \n        return dfs()\n\n# Alternative BFS approach\nclass CodecBFS:\n    def serialize(self, root):\n        if not root:\n            return ''\n        \n        queue = deque([root])\n        result = []\n        \n        while queue:\n            node = queue.popleft()\n            if node:\n                result.append(str(node.val))\n                queue.append(node.left)\n                queue.append(node.right)\n            else:\n                result.append('#')\n        \n        return ','.join(result)\n    \n    def deserialize(self, data):\n        if not data:\n            return None\n        \n        vals = data.split(',')\n        root = TreeNode(int(vals[0]))\n        queue = deque([root])\n        i = 1\n        \n        while queue and i < len(vals):\n            node = queue.popleft()\n            \n            if vals[i] != '#':\n                node.left = TreeNode(int(vals[i]))\n                queue.append(node.left)\n            i += 1\n            \n            if i < len(vals) and vals[i] != '#':\n                node.right = TreeNode(int(vals[i]))\n                queue.append(node.right)\n            i += 1\n        \n        return root\n\n# Test case\ncodec = Codec()\nroot = TreeNode(1)\nroot.left = TreeNode(2)\nroot.right = TreeNode(3, TreeNode(4), TreeNode(5))\n\nserialized = codec.serialize(root)\nprint(f\"Serialized: {serialized}\")\ndeserialized = codec.deserialize(serialized)\nprint(f\"Deserialized successfully: {deserialized is not None}\")",
          "timeComplexity": "O(n) for both serialization and deserialization",
          "spaceComplexity": "O(n) for storing the serialized string and recursion stack",
          "keyInsights": "• Preorder traversal naturally preserves tree structure\n• Use sentinel values ('#') to represent null nodes\n• Deque allows efficient left-side popping during deserialization\n• Both DFS and BFS approaches work, DFS is more concise\n• Key insight: serialization order must match deserialization order",
          "link": "https://leetcode.com/problems/serialize-and-deserialize-binary-tree/"
        }
      ]
    },
    {
      "id": "tries",
      "title": "Tries",
      "description": "Prefix trees (Tries) for efficient string operations and word searches",
      "questions": [
        {
          "id": "trie_1",
          "title": "Implement Trie (Prefix Tree)",
          "routeName": "implement_trie",
          "difficulty": "Medium",
          "leetcodeNumber": 208,
          "companies": ["Amazon", "Google", "Microsoft", "Facebook", "Apple"],
          "tags": ["Hash Table", "String", "Design", "Trie"],
          "description": "A trie (pronounced as 'try') or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings.",
          "detailedDescription": "A trie (pronounced as 'try') or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.\n\nImplement the Trie class:\n• Trie() Initializes the trie object.\n• void insert(String word) Inserts the string word into the trie.\n• boolean search(String word) Returns true if the string word is in the trie (i.e., was inserted before), and false otherwise.\n• boolean startsWith(String prefix) Returns true if there is a previously inserted string word that has the prefix prefix, and false otherwise.\n\nExample 1:\nInput\n['Trie', 'insert', 'search', 'search', 'startsWith', 'insert', 'search']\n[[], ['apple'], ['apple'], ['app'], ['app'], ['app'], ['app']]\nOutput\n[null, null, true, false, true, null, true]\n\nExplanation\nTrie trie = new Trie();\ntrie.insert('apple');\ntrie.search('apple');   // return True\ntrie.search('app');     // return False\ntrie.startsWith('app'); // return True\ntrie.insert('app');\ntrie.search('app');     // return True\n\nConstraints:\n• 1 <= word.length, prefix.length <= 2000\n• word and prefix consist only of lowercase English letters.\n• At most 3 * 10^4 calls in total will be made to insert, search, and startsWith.",
          "approach": "Use nested dictionaries to represent trie nodes, with special marker for end of words.",
          "solution": "Each node contains children dictionary and end-of-word flag. Traverse character by character for operations.",
          "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word: str) -> bool:\n        node = self._search_prefix(word)\n        return node is not None and node.is_end_of_word\n\n    def startsWith(self, prefix: str) -> bool:\n        return self._search_prefix(prefix) is not None\n\n    def _search_prefix(self, prefix: str):\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return None\n            node = node.children[char]\n        return node\n\n# Test case\ntrie = Trie()\ntrie.insert('apple')\nprint(trie.search('apple'))   # True\nprint(trie.search('app'))     # False\nprint(trie.startsWith('app')) # True\ntrie.insert('app')\nprint(trie.search('app'))     # True",
          "timeComplexity": "O(m) for insert, search, and startsWith where m is the length of the word/prefix",
          "spaceComplexity": "O(ALPHABET_SIZE * N * M) where N is number of words and M is average length",
          "keyInsights": "• Trie enables efficient prefix-based operations\n• Each node represents a character, path from root forms words\n• End-of-word marker distinguishes complete words from prefixes\n• Shared prefixes are stored only once, saving space\n• Foundation for autocomplete, spell checkers, and IP routing",
          "link": "https://leetcode.com/problems/implement-trie-prefix-tree/"
        },
        {
          "id": "trie_2",
          "title": "Design Add and Search Words Data Structure",
          "routeName": "add_search_words",
          "difficulty": "Medium",
          "leetcodeNumber": 211,
          "companies": ["Amazon", "Google", "Microsoft", "Facebook", "Apple"],
          "tags": ["String", "Depth-First Search", "Design", "Trie"],
          "description": "Design a data structure that supports adding new words and finding if a string matches any previously added string.",
          "detailedDescription": "Design a data structure that supports adding new words and finding if a string matches any previously added string.\n\nImplement the WordDictionary class:\n• WordDictionary() Initializes the object.\n• void addWord(word) Adds word to the data structure, it can be matched later.\n• bool search(word) Returns true if there is any string in the data structure that matches word or false otherwise. word may contain dots '.' where dots can be matched with any letter.\n\nExample:\nInput\n['WordDictionary','addWord','addWord','addWord','search','search','search','search']\n[[],['bad'],['dad'],['mad'],['pad'],['bad'],['.ad'],['b..']]\nOutput\n[null,null,null,null,false,true,true,true]\n\nExplanation\nWordDictionary wordDictionary = new WordDictionary();\nwordDictionary.addWord('bad');\nwordDictionary.addWord('dad');\nwordDictionary.addWord('mad');\nwordDictionary.search('pad'); // return False\nwordDictionary.search('bad'); // return True\nwordDictionary.search('.ad'); // return True\nwordDictionary.search('b..'); // return True\n\nConstraints:\n• 1 <= word.length <= 25\n• word in addWord consists of lowercase English letters.\n• word in search consist of '.' or lowercase English letters.\n• There will be at most 2 dots in word for search queries.\n• At most 10^4 calls will be made to addWord and search.",
          "approach": "Use trie with DFS for wildcard search. When encountering '.', try all possible children.",
          "solution": "Standard trie for addWord, DFS with backtracking for search when encountering wildcard '.'.",
          "code": "class WordDictionary:\n    def __init__(self):\n        self.root = {}\n\n    def addWord(self, word: str) -> None:\n        node = self.root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True  # End of word marker\n\n    def search(self, word: str) -> bool:\n        def dfs(j, node):\n            for i in range(j, len(word)):\n                char = word[i]\n                if char == '.':\n                    for child in node:\n                        if child != '$' and dfs(i + 1, node[child]):\n                            return True\n                    return False\n                else:\n                    if char not in node:\n                        return False\n                    node = node[char]\n            return '$' in node\n        return dfs(0, self.root)\n\n# Alternative implementation with TrieNode class\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_word = False\n\nclass WordDictionaryAlt:\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def addWord(self, word: str) -> None:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_word = True\n    \n    def search(self, word: str) -> bool:\n        def dfs(index, node):\n            if index == len(word):\n                return node.is_word\n            \n            char = word[index]\n            if char == '.':\n                for child in node.children.values():\n                    if dfs(index + 1, child):\n                        return True\n                return False\n            else:\n                if char in node.children:\n                    return dfs(index + 1, node.children[char])\n                return False\n        \n        return dfs(0, self.root)\n\n# Test case\nwd = WordDictionary()\nwd.addWord('bad')\nwd.addWord('dad')\nwd.addWord('mad')\nprint(wd.search('pad'))  # False\nprint(wd.search('bad'))  # True\nprint(wd.search('.ad'))  # True\nprint(wd.search('b..'))  # True",
          "timeComplexity": "O(m) for addWord, O(n * 26^m) worst case for search with wildcards",
          "spaceComplexity": "O(ALPHABET_SIZE * N * M) for storing the trie",
          "keyInsights": "• Wildcard '.' requires exploring all possible paths\n• DFS naturally handles the branching for wildcard characters\n• Early termination when no matching children found\n• Trie structure enables efficient prefix matching even with wildcards\n• Pattern: combine trie traversal with recursive exploration",
          "link": "https://leetcode.com/problems/design-add-and-search-words-data-structure/"
        },
        {
          "id": "trie_3",
          "title": "Word Search II",
          "routeName": "word_search_ii",
          "difficulty": "Hard",
          "leetcodeNumber": 212,
          "companies": ["Amazon", "Google", "Microsoft", "Facebook", "Apple"],
          "tags": ["Array", "String", "Backtracking", "Trie", "Matrix"],
          "description": "Given an m x n board of characters and a list of strings words, return all words on the board.",
          "detailedDescription": "Given an m x n board of characters and a list of strings words, return all words on the board.\n\nEach word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.\n\nExample 1:\nInput: board = [['o','a','a','n'],['e','t','a','e'],['i','h','k','r'],['i','f','l','v']], words = ['oath','pea','eat','rain']\nOutput: ['eat','oath']\n\nExample 2:\nInput: board = [['a','b'],['c','d']], words = ['abcb']\nOutput: []\n\nConstraints:\n• m == board.length\n• n == board[i].length\n• 1 <= m, n <= 12\n• board[i][j] is a lowercase English letter.\n• 1 <= words.length <= 3 * 10^4\n• 1 <= words[i].length <= 10\n• words[i] consists of lowercase English letters.\n• All the strings of words are unique.",
          "approach": "Build trie from words, then DFS from each board cell following trie paths. Use backtracking for board traversal.",
          "solution": "Construct trie from word list, then explore board with DFS while following valid trie paths and using backtracking.",
          "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.word = None\n\ndef findWords(board, words):\n    # Build Trie\n    root = TrieNode()\n    for word in words:\n        node = root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.word = word\n\n    rows, cols = len(board), len(board[0])\n    result = []\n\n    def backtrack(r, c, parent):\n        letter = board[r][c]\n        curr_node = parent.children.get(letter)\n        if not curr_node:\n            return\n\n        # Found a word\n        if curr_node.word:\n            result.append(curr_node.word)\n            curr_node.word = None  # Avoid duplicate\n\n        # Mark cell as visited\n        board[r][c] = '#'\n        \n        # Explore neighbors\n        for rr, cc in [(r-1,c),(r+1,c),(r,c-1),(r,c+1)]:\n            if 0 <= rr < rows and 0 <= cc < cols and board[rr][cc] != '#':\n                backtrack(rr, cc, curr_node)\n        \n        # Restore cell\n        board[r][c] = letter\n\n        # Optimization: remove leaf nodes\n        if not curr_node.children:\n            parent.children.pop(letter)\n\n    # Start DFS from each cell\n    for r in range(rows):\n        for c in range(cols):\n            backtrack(r, c, root)\n\n    return result\n\n# Alternative implementation with explicit visited set\ndef findWordsAlt(board, words):\n    class TrieNode:\n        def __init__(self):\n            self.children = {}\n            self.is_word = False\n            self.word = ''\n    \n    # Build trie\n    root = TrieNode()\n    for word in words:\n        node = root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_word = True\n        node.word = word\n    \n    def dfs(r, c, node, visited):\n        if (r < 0 or r >= len(board) or \n            c < 0 or c >= len(board[0]) or \n            (r, c) in visited or \n            board[r][c] not in node.children):\n            return\n        \n        visited.add((r, c))\n        node = node.children[board[r][c]]\n        \n        if node.is_word:\n            result.add(node.word)\n        \n        for dr, dc in [(0,1), (0,-1), (1,0), (-1,0)]:\n            dfs(r + dr, c + dc, node, visited)\n        \n        visited.remove((r, c))\n    \n    result = set()\n    for r in range(len(board)):\n        for c in range(len(board[0])):\n            dfs(r, c, root, set())\n    \n    return list(result)\n\n# Test case\nboard = [['o','a','a','n'],['e','t','a','e'],['i','h','k','r'],['i','f','l','v']]\nwords = ['oath','pea','eat','rain']\nprint(findWords(board, words))  # ['eat', 'oath']",
          "timeComplexity": "O(M * 4^L + N * 26^L) where M is board cells, N is words, L is max word length",
          "spaceComplexity": "O(N * L) for trie storage plus O(L) for recursion stack",
          "keyInsights": "• Trie eliminates need to search for each word individually\n• Pruning: stop exploration when no trie path exists\n• Backtracking restores board state after exploring each path\n• Remove found words from trie to avoid duplicates\n• Optimization: remove leaf nodes to reduce future search space\n• Pattern: combine trie with backtracking for efficient multi-pattern search",
          "link": "https://leetcode.com/problems/word-search-ii/"
        }
      ]
    },
    {
      "id": "heap",
      "title": "Heap / Priority Queue",
      "description": "Heap data structure and priority queue operations for efficient min/max element access",
      "questions": [
        {
          "id": "heap_1",
          "title": "Kth Largest Element in a Stream",
          "routeName": "kth_largest_stream",
          "difficulty": "Easy",
          "leetcodeNumber": 703,
          "companies": ["Amazon", "Google", "Microsoft", "Facebook", "Apple"],
          "tags": [
            "Tree",
            "Design",
            "Binary Search Tree",
            "Heap (Priority Queue)",
            "Binary Tree",
            "Data Stream"
          ],
          "description": "Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element.",
          "detailedDescription": "Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element.\n\nImplement KthLargest class:\n• KthLargest(int k, int[] nums) Initializes the object with the integer k and the stream of integers nums.\n• int add(int val) Appends the integer val to the stream and returns the element representing the kth largest element in the stream.\n\nExample 1:\nInput\n['KthLargest', 'add', 'add', 'add', 'add', 'add']\n[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]\nOutput\n[null, 4, 5, 5, 8, 8]\n\nExplanation\nKthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);\nkthLargest.add(3);   // return 4\nkthLargest.add(5);   // return 5\nkthLargest.add(10);  // return 5\nkthLargest.add(9);   // return 8\nkthLargest.add(4);   // return 8\n\nConstraints:\n• 1 <= k <= 10^4\n• 0 <= nums.length <= 10^4\n• -10^4 <= nums[i] <= 10^4\n• -10^4 <= val <= 10^4\n• At most 10^4 calls will be made to add.",
          "approach": "Use min-heap of size k to maintain k largest elements. Root of heap is kth largest.",
          "solution": "Maintain min-heap with exactly k elements. When adding new element, push to heap and pop if size exceeds k.",
          "code": "import heapq\n\nclass KthLargest:\n    def __init__(self, k, nums):\n        self.k = k\n        self.heap = nums\n        heapq.heapify(self.heap)\n        # Keep only k largest elements\n        while len(self.heap) > k:\n            heapq.heappop(self.heap)\n\n    def add(self, val):\n        heapq.heappush(self.heap, val)\n        if len(self.heap) > self.k:\n            heapq.heappop(self.heap)\n        return self.heap[0]\n\n# Alternative implementation with more explicit logic\nclass KthLargestAlt:\n    def __init__(self, k, nums):\n        self.k = k\n        self.heap = []\n        \n        for num in nums:\n            self.add(num)\n    \n    def add(self, val):\n        if len(self.heap) < self.k:\n            heapq.heappush(self.heap, val)\n        elif val > self.heap[0]:\n            heapq.heappushpop(self.heap, val)\n        \n        return self.heap[0] if len(self.heap) == self.k else None\n\n# Test case\nkthLargest = KthLargest(3, [4, 5, 8, 2])\nprint(kthLargest.add(3))   # 4\nprint(kthLargest.add(5))   # 5\nprint(kthLargest.add(10))  # 5\nprint(kthLargest.add(9))   # 8\nprint(kthLargest.add(4))   # 8",
          "timeComplexity": "O(log k) for add operation, O(n log k) for initialization",
          "spaceComplexity": "O(k) for storing k elements in heap",
          "keyInsights": "• Min-heap of size k keeps k largest elements efficiently\n• Root of min-heap is the kth largest (smallest among k largest)\n• heappushpop is more efficient than separate push and pop\n• Only need to track k elements, not entire stream\n• Foundation pattern for kth largest/smallest problems",
          "link": "https://leetcode.com/problems/kth-largest-element-in-a-stream/"
        },
        {
          "id": "heap_2",
          "title": "Last Stone Weight",
          "routeName": "last_stone_weight",
          "difficulty": "Easy",
          "leetcodeNumber": 1046,
          "companies": ["Amazon", "Google", "Microsoft", "Facebook"],
          "tags": ["Array", "Heap (Priority Queue)"],
          "description": "You are given an array of integers stones where stones[i] is the weight of the ith stone.",
          "detailedDescription": "You are given an array of integers stones where stones[i] is the weight of the ith stone.\n\nWe are playing a game with the stones. On each turn, we choose the heaviest two stones and smash them together. Suppose the heaviest two stones have weights x and y with x <= y. The result of this smash is:\n• If x == y, both stones are destroyed, and\n• If x != y, the stone of weight x is destroyed, and the stone of weight y has new weight y - x.\n\nAt the end of the game, there is at most one stone left.\n\nReturn the weight of the last stone. If there are no stones left, return 0.\n\nExample 1:\nInput: stones = [2,7,4,1,8,1]\nOutput: 1\nExplanation: \nWe combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then,\nwe combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then,\nwe combine 2 and 1 to get 1 so the array converts to [1,1,1] then,\nwe combine 1 and 1 to get 0 so the array converts to [1] then that's the value of the last stone.\n\nExample 2:\nInput: stones = [1]\nOutput: 1\n\nConstraints:\n• 1 <= stones.length <= 30\n• 1 <= stones[i] <= 1000",
          "approach": "Use max-heap (simulate with negative values in min-heap) to repeatedly get two heaviest stones.",
          "solution": "Convert to max-heap using negative values, repeatedly pop two largest, compute difference, and push back if non-zero.",
          "code": "import heapq\n\ndef lastStoneWeight(stones):\n    # Convert to max-heap using negative values\n    stones = [-s for s in stones]\n    heapq.heapify(stones)\n    \n    while len(stones) > 1:\n        # Get two heaviest stones\n        first = heapq.heappop(stones)   # Most negative (heaviest)\n        second = heapq.heappop(stones)  # Second most negative\n        \n        # If stones have different weights, add the difference back\n        if first != second:\n            heapq.heappush(stones, first - second)\n    \n    # Return last stone weight or 0 if no stones left\n    return -stones[0] if stones else 0\n\n# Alternative implementation without heap\ndef lastStoneWeightSort(stones):\n    while len(stones) > 1:\n        stones.sort()\n        # Take two largest\n        first = stones.pop()\n        second = stones.pop()\n        \n        if first != second:\n            stones.append(first - second)\n    \n    return stones[0] if stones else 0\n\n# Test case\nstones = [2, 7, 4, 1, 8, 1]\nprint(lastStoneWeight(stones))  # 1\n\nstones2 = [1]\nprint(lastStoneWeight(stones2))  # 1",
          "timeComplexity": "O(n log n) where n is the number of stones",
          "spaceComplexity": "O(n) for the heap storage",
          "keyInsights": "• Max-heap simulation using negative values in Python's min-heap\n• Process pairs of elements repeatedly until convergence\n• Heap provides efficient access to maximum elements\n• Alternative sorting approach is O(n^2 log n) due to repeated sorting\n• Pattern: simulation problems often benefit from priority queues",
          "link": "https://leetcode.com/problems/last-stone-weight/"
        },
        {
          "id": "heap_3",
          "title": "K Closest Points to Origin",
          "routeName": "k_closest_points",
          "difficulty": "Medium",
          "leetcodeNumber": 973,
          "companies": ["Amazon", "Google", "Microsoft", "Facebook", "Apple"],
          "tags": [
            "Array",
            "Math",
            "Divide and Conquer",
            "Geometry",
            "Sorting",
            "Heap (Priority Queue)",
            "Quickselect"
          ],
          "description": "Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane and an integer k, return the k closest points to the origin (0, 0).",
          "detailedDescription": "Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane and an integer k, return the k closest points to the origin (0, 0).\n\nThe distance between two points on the X-Y plane is the Euclidean distance (i.e., √((x1 - x2)^2 + (y1 - y2)^2)).\n\nYou may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in).\n\nExample 1:\nInput: points = [[1,1],[3,3],[2,2]], k = 1\nOutput: [[1,1]]\nExplanation:\nThe distance between (1, 1) and the origin is sqrt(2).\nThe distance between (3, 3) and the origin is sqrt(18).\nThe distance between (2, 2) and the origin is sqrt(8).\nSince sqrt(2) < sqrt(8) < sqrt(18), we return [[1,1]].\n\nExample 2:\nInput: points = [[3,3],[5,-1],[-2,4]], k = 2\nOutput: [[3,3],[-2,4]]\nExplanation: The answer [[-2,4],[3,3]] would also be accepted.\n\nConstraints:\n• 1 <= k <= points.length <= 10^4\n• -10^4 <= xi, yi <= 10^4",
          "approach": "Use max-heap of size k to maintain k closest points. Use negative distances for max-heap simulation.",
          "solution": "Maintain max-heap with k closest points. For each point, compare with farthest in heap and replace if closer.",
          "code": "import heapq\n\ndef kClosest(points, k):\n    heap = []\n    \n    for x, y in points:\n        dist = -(x*x + y*y)  # Negative for max-heap simulation\n        if len(heap) == k:\n            heapq.heappushpop(heap, (dist, x, y))\n        else:\n            heapq.heappush(heap, (dist, x, y))\n    \n    return [(x, y) for (dist, x, y) in heap]\n\n# Alternative: Sort approach\ndef kClosestSort(points, k):\n    points.sort(key=lambda p: p[0]*p[0] + p[1]*p[1])\n    return points[:k]\n\n# Alternative: Min-heap with all points\ndef kClosestMinHeap(points, k):\n    heap = []\n    for x, y in points:\n        dist = x*x + y*y\n        heapq.heappush(heap, (dist, x, y))\n    \n    result = []\n    for _ in range(k):\n        _, x, y = heapq.heappop(heap)\n        result.append([x, y])\n    \n    return result\n\n# Alternative: Using heapq.nsmallest\ndef kClosestNSmallest(points, k):\n    return heapq.nsmallest(k, points, key=lambda p: p[0]*p[0] + p[1]*p[1])\n\n# Test case\npoints = [[1,1],[3,3],[2,2]]\nk = 1\nprint(kClosest(points, k))  # [[1,1]]\n\npoints2 = [[3,3],[5,-1],[-2,4]]\nk2 = 2\nprint(kClosest(points2, k2))  # [[3,3],[-2,4]] or [[-2,4],[3,3]]",
          "timeComplexity": "O(n log k) for heap approach, O(n log n) for sorting approach",
          "spaceComplexity": "O(k) for heap storage",
          "keyInsights": "• Max-heap of size k is more efficient than min-heap of size n when k << n\n• No need to compute actual distance, squared distance suffices for comparison\n• heappushpop is atomic operation that's more efficient than separate push/pop\n• Multiple valid approaches: heap, sorting, quickselect\n• Pattern: top-k problems often benefit from size-k heaps",
          "link": "https://leetcode.com/problems/k-closest-points-to-origin/"
        },
        {
          "id": "heap_4",
          "title": "Kth Largest Element in an Array",
          "routeName": "kth_largest_array",
          "difficulty": "Medium",
          "leetcodeNumber": 215,
          "companies": ["Amazon", "Google", "Microsoft", "Facebook", "Apple"],
          "tags": [
            "Array",
            "Divide and Conquer",
            "Sorting",
            "Heap (Priority Queue)",
            "Quickselect"
          ],
          "description": "Given an integer array nums and an integer k, return the kth largest element in the array.",
          "detailedDescription": "Given an integer array nums and an integer k, return the kth largest element in the array.\n\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\n\nCan you solve it without sorting?\n\nExample 1:\nInput: nums = [3,2,1,5,6,4], k = 2\nOutput: 5\n\nExample 2:\nInput: nums = [3,2,3,1,2,4,5,5,6], k = 4\nOutput: 4\n\nConstraints:\n• 1 <= k <= nums.length <= 10^5\n• -10^4 <= nums[i] <= 10^4",
          "approach": "Multiple approaches: min-heap of size k, max-heap with n elements, or quickselect algorithm.",
          "solution": "Use heapq.nlargest for simplicity, or implement min-heap of size k for better space complexity.",
          "code": "import heapq\nimport random\n\ndef findKthLargest(nums, k):\n    # Simplest approach using heapq.nlargest\n    return heapq.nlargest(k, nums)[-1]\n\n# Min-heap approach (more space efficient)\ndef findKthLargestMinHeap(nums, k):\n    heap = []\n    for num in nums:\n        if len(heap) < k:\n            heapq.heappush(heap, num)\n        elif num > heap[0]:\n            heapq.heappushpop(heap, num)\n    return heap[0]\n\n# Max-heap approach\ndef findKthLargestMaxHeap(nums, k):\n    heap = [-num for num in nums]\n    heapq.heapify(heap)\n    for _ in range(k-1):\n        heapq.heappop(heap)\n    return -heap[0]\n\n# Quickselect approach (average O(n))\ndef findKthLargestQuickSelect(nums, k):\n    def quickselect(left, right, k_smallest):\n        if left == right:\n            return nums[left]\n        \n        # Random pivot for better average performance\n        pivot_index = random.randint(left, right)\n        pivot_index = partition(left, right, pivot_index)\n        \n        if k_smallest == pivot_index:\n            return nums[k_smallest]\n        elif k_smallest < pivot_index:\n            return quickselect(left, pivot_index - 1, k_smallest)\n        else:\n            return quickselect(pivot_index + 1, right, k_smallest)\n    \n    def partition(left, right, pivot_index):\n        pivot = nums[pivot_index]\n        # Move pivot to end\n        nums[pivot_index], nums[right] = nums[right], nums[pivot_index]\n        \n        store_index = left\n        for i in range(left, right):\n            if nums[i] < pivot:\n                nums[store_index], nums[i] = nums[i], nums[store_index]\n                store_index += 1\n        \n        # Move pivot to its final place\n        nums[right], nums[store_index] = nums[store_index], nums[right]\n        return store_index\n    \n    # kth largest is (n-k)th smallest\n    return quickselect(0, len(nums) - 1, len(nums) - k)\n\n# Test case\nnums = [3,2,1,5,6,4]\nk = 2\nprint(findKthLargest(nums, k))  # 5\n\nnums2 = [3,2,3,1,2,4,5,5,6]\nk2 = 4\nprint(findKthLargest(nums2, k2))  # 4",
          "timeComplexity": "O(n log k) for min-heap, O(n) average for quickselect, O(n log n) for sorting",
          "spaceComplexity": "O(k) for min-heap, O(1) for quickselect",
          "keyInsights": "• Multiple valid approaches with different trade-offs\n• Min-heap of size k is space-efficient for large arrays\n• Quickselect achieves O(n) average time without extra space\n• heapq.nlargest is simplest but uses O(n) space\n• Pattern: kth element problems have heap and quickselect solutions",
          "link": "https://leetcode.com/problems/kth-largest-element-in-an-array/"
        },
        {
          "id": "heap_5",
          "title": "Task Scheduler",
          "routeName": "task_scheduler",
          "difficulty": "Medium",
          "leetcodeNumber": 621,
          "companies": ["Amazon", "Google", "Microsoft", "Facebook", "Apple"],
          "tags": [
            "Array",
            "Hash Table",
            "Greedy",
            "Sorting",
            "Heap (Priority Queue)",
            "Counting"
          ],
          "description": "Given a characters array tasks, representing the tasks a CPU must do, and a positive integer n, representing the cooling time between two same tasks, return the minimum number of units of times that the CPU will take to finish all the given tasks.",
          "detailedDescription": "Given a characters array tasks, representing the tasks a CPU must do, and a positive integer n, representing the cooling time between two same tasks (the same task cannot be executed twice within n units of time), return the minimum number of units of times that the CPU will take to finish all the given tasks.\n\nExample 1:\nInput: tasks = ['A','A','A','B','B','B'], n = 2\nOutput: 8\nExplanation: \nA -> B -> idle -> A -> B -> idle -> A -> B\nThere is at least 2 units of time between any two same tasks.\n\nExample 2:\nInput: tasks = ['A','A','A','B','B','B'], n = 0\nOutput: 6\nExplanation: On this case any permutation of size 6 would work since n = 0.\n['A','A','A','B','B','B']\n['A','B','A','B','A','B']\n['B','B','B','A','A','A']\n...\nAnd so on.\n\nExample 3:\nInput: tasks = ['A','A','A','A','A','A','B','C','D','E','F','G'], n = 2\nOutput: 16\nExplanation: \nOne possible solution is\nA -> B -> C -> A -> D -> E -> A -> F -> G -> A -> idle -> idle -> A -> idle -> idle -> A\n\nConstraints:\n• 1 <= task.length <= 10^4\n• tasks[i] is upper-case English letter.\n• The integer n is in the range [0, 100].",
          "approach": "Mathematical approach: calculate based on most frequent task and available slots.",
          "solution": "Find max frequency, calculate slots needed, and determine if idle time is required.",
          "code": "from collections import Counter\nimport heapq\n\ndef leastInterval(tasks, n):\n    # Mathematical approach\n    counts = list(Counter(tasks).values())\n    max_count = max(counts)\n    max_count_tasks = counts.count(max_count)\n    \n    # Calculate minimum time needed\n    return max(len(tasks), (max_count - 1) * (n + 1) + max_count_tasks)\n\n# Alternative heap-based simulation approach\ndef leastIntervalHeap(tasks, n):\n    count = Counter(tasks)\n    max_heap = [-cnt for cnt in count.values()]\n    heapq.heapify(max_heap)\n    \n    time = 0\n    queue = []  # (count, time_available)\n    \n    while max_heap or queue:\n        time += 1\n        \n        if max_heap:\n            cnt = heapq.heappop(max_heap)\n            cnt += 1  # Decrease count (was negative)\n            if cnt < 0:  # Still have tasks remaining\n                queue.append((cnt, time + n))\n        \n        # Check if any tasks are ready to be scheduled again\n        if queue and queue[0][1] == time:\n            cnt, _ = queue.pop(0)\n            heapq.heappush(max_heap, cnt)\n    \n    return time\n\n# Detailed mathematical explanation\ndef leastIntervalExplained(tasks, n):\n    \"\"\"\n    Key insight: The task with maximum frequency determines the structure.\n    \n    If max frequency is f, we need at least (f-1) complete cycles.\n    Each cycle has length (n+1) - one slot for the frequent task, n slots for cooling.\n    After (f-1) cycles, we place remaining tasks with max frequency.\n    \n    Formula: max(total_tasks, (max_freq - 1) * (n + 1) + num_max_freq_tasks)\n    \"\"\"\n    counter = Counter(tasks)\n    max_freq = max(counter.values())\n    max_freq_count = sum(1 for freq in counter.values() if freq == max_freq)\n    \n    # Minimum time based on structure imposed by most frequent tasks\n    min_time = (max_freq - 1) * (n + 1) + max_freq_count\n    \n    # If we have enough variety of tasks, no idle time needed\n    return max(len(tasks), min_time)\n\n# Test cases\ntasks1 = ['A','A','A','B','B','B']\nn1 = 2\nprint(leastInterval(tasks1, n1))  # 8\n\ntasks2 = ['A','A','A','B','B','B']\nn2 = 0\nprint(leastInterval(tasks2, n2))  # 6\n\ntasks3 = ['A','A','A','A','A','A','B','C','D','E','F','G']\nn3 = 2\nprint(leastInterval(tasks3, n3))  # 16",
          "timeComplexity": "O(n) for mathematical approach, O(n log k) for heap approach where k is unique tasks",
          "spaceComplexity": "O(k) where k is the number of unique tasks",
          "keyInsights": "• Mathematical formula avoids simulation complexity\n• Most frequent task determines minimum structure required\n• If enough task variety exists, no idle time needed\n• Heap simulation provides intuitive understanding but is less efficient\n• Pattern: scheduling problems often have mathematical closed-form solutions",
          "link": "https://leetcode.com/problems/task-scheduler/"
        },
        {
          "id": "heap_6",
          "title": "Design Twitter",
          "routeName": "design_twitter",
          "difficulty": "Medium",
          "leetcodeNumber": 355,
          "companies": ["Amazon", "Google", "Microsoft", "Facebook", "Twitter"],
          "tags": [
            "Hash Table",
            "Linked List",
            "Design",
            "Heap (Priority Queue)"
          ],
          "description": "Design a simplified version of Twitter where users can post tweets, follow/unfollow another user, and see the 10 most recent tweets in the user's news feed.",
          "detailedDescription": "Design a simplified version of Twitter where users can post tweets, follow/unfollow another user, and see the 10 most recent tweets in the user's news feed.\n\nImplement the Twitter class:\n• Twitter() Initializes your twitter object.\n• void postTweet(int userId, int tweetId) Composes a new tweet with ID tweetId by the user userId. Each call to this function will be made with a unique tweetId.\n• List<Integer> getNewsFeed(int userId) Retrieves the 10 most recent tweet IDs in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user themself. Tweets must be ordered from most recent to least recent.\n• void follow(int followerId, int followeeId) The user with ID followerId started following the user with ID followeeId.\n• void unfollow(int followerId, int followeeId) The user with ID followerId started unfollowing the user with ID followeeId.\n\nExample 1:\nInput\n['Twitter', 'postTweet', 'getNewsFeed', 'follow', 'postTweet', 'getNewsFeed', 'unfollow', 'getNewsFeed']\n[[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]]\nOutput\n[null, null, [5], null, null, [6, 5], null, [5]]\n\nExplanation\nTwitter twitter = new Twitter();\ntwitter.postTweet(1, 5); // User 1 posts a new tweet (id = 5).\ntwitter.getNewsFeed(1);  // User 1's news feed should return a list with 1 tweet id -> [5]. return [5]\ntwitter.follow(1, 2);    // User 1 follows user 2.\ntwitter.postTweet(2, 6); // User 2 posts a new tweet (id = 6).\ntwitter.getNewsFeed(1);  // User 1's news feed should return a list with 2 tweet ids -> [6, 5]. Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.\ntwitter.unfollow(1, 2);  // User 1 unfollows user 2.\ntwitter.getNewsFeed(1);  // User 1's news feed should return a list with 1 tweet id -> [5], since user 1 is no longer following user 2.\n\nConstraints:\n• 1 <= userId, followerId, followeeId <= 500\n• 0 <= tweetId <= 10^4\n• All the tweets have unique IDs.\n• At most 3 * 10^4 calls will be made to postTweet, getNewsFeed, follow, and unfollow.",
          "approach": "Use hash maps for user relationships and tweets, heap for merging recent tweets from followed users.",
          "solution": "Store tweets with timestamps, maintain followee sets, use heap to merge k sorted lists for news feed.",
          "code": "import heapq\nfrom collections import defaultdict\n\nclass Twitter:\n    def __init__(self):\n        self.time = 0  # Global timestamp\n        self.tweets = defaultdict(list)  # userId -> [(time, tweetId)]\n        self.following = defaultdict(set)  # userId -> set of followeeIds\n\n    def postTweet(self, userId: int, tweetId: int) -> None:\n        self.tweets[userId].append((self.time, tweetId))\n        self.time += 1\n\n    def getNewsFeed(self, userId: int) -> list[int]:\n        # Get all relevant users (self + followees)\n        users = self.following[userId] | {userId}\n        \n        # Use heap to merge recent tweets from all relevant users\n        heap = []\n        \n        for user in users:\n            if self.tweets[user]:\n                # Add most recent tweet from each user\n                time, tweetId = self.tweets[user][-1]\n                heap.append((-time, tweetId, user, len(self.tweets[user]) - 1))\n        \n        heapq.heapify(heap)\n        \n        feed = []\n        while heap and len(feed) < 10:\n            neg_time, tweetId, user, index = heapq.heappop(heap)\n            feed.append(tweetId)\n            \n            # Add next tweet from same user if available\n            if index > 0:\n                next_time, next_tweetId = self.tweets[user][index - 1]\n                heapq.heappush(heap, (-next_time, next_tweetId, user, index - 1))\n        \n        return feed\n\n    def follow(self, followerId: int, followeeId: int) -> None:\n        if followerId != followeeId:  # Can't follow yourself\n            self.following[followerId].add(followeeId)\n\n    def unfollow(self, followerId: int, followeeId: int) -> None:\n        self.following[followerId].discard(followeeId)\n\n# Alternative simpler implementation (less efficient for large datasets)\nclass TwitterSimple:\n    def __init__(self):\n        self.time = 0\n        self.tweets = defaultdict(list)\n        self.following = defaultdict(set)\n    \n    def postTweet(self, userId: int, tweetId: int) -> None:\n        self.tweets[userId].append((self.time, tweetId))\n        self.time += 1\n    \n    def getNewsFeed(self, userId: int) -> list[int]:\n        # Collect all relevant tweets\n        all_tweets = []\n        users = self.following[userId] | {userId}\n        \n        for user in users:\n            all_tweets.extend(self.tweets[user])\n        \n        # Sort by time and return top 10\n        all_tweets.sort(key=lambda x: x[0], reverse=True)\n        return [tweetId for _, tweetId in all_tweets[:10]]\n    \n    def follow(self, followerId: int, followeeId: int) -> None:\n        if followerId != followeeId:\n            self.following[followerId].add(followeeId)\n    \n    def unfollow(self, followerId: int, followeeId: int) -> None:\n        self.following[followerId].discard(followeeId)\n\n# Test case\ntwitter = Twitter()\ntwitter.postTweet(1, 5)\nprint(twitter.getNewsFeed(1))  # [5]\ntwitter.follow(1, 2)\ntwitter.postTweet(2, 6)\nprint(twitter.getNewsFeed(1))  # [6, 5]\ntwitter.unfollow(1, 2)\nprint(twitter.getNewsFeed(1))  # [5]",
          "timeComplexity": "O(k log k) for getNewsFeed where k is number of followed users, O(1) for other operations",
          "spaceComplexity": "O(n * m) where n is users and m is average tweets per user",
          "keyInsights": "• Heap efficiently merges k sorted lists (user timelines)\n• Global timestamp ensures correct ordering across users\n• Only load tweets from relevant users to optimize memory\n• Set operations for follow/unfollow provide O(1) lookup\n• Pattern: merge k sorted lists is common in timeline/feed problems",
          "link": "https://leetcode.com/problems/design-twitter/"
        },
        {
          "id": "heap_7",
          "title": "Find Median from Data Stream",
          "routeName": "median_data_stream",
          "difficulty": "Hard",
          "leetcodeNumber": 295,
          "companies": ["Amazon", "Google", "Microsoft", "Facebook", "Apple"],
          "tags": [
            "Two Pointers",
            "Design",
            "Sorting",
            "Heap (Priority Queue)",
            "Data Stream"
          ],
          "description": "The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values.",
          "detailedDescription": "The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values.\n\n• For example, for arr = [2,3,4], the median is 3.\n• For example, for arr = [2,3], the median is (2 + 3) / 2 = 2.5.\n\nImplement the MedianFinder class:\n• MedianFinder() initializes the MedianFinder object.\n• void addNum(int num) adds the integer num from the data stream to the data structure.\n• double findMedian() returns the median of all elements so far. Answers within 10^-5 of the actual answer will be accepted.\n\nExample 1:\nInput\n['MedianFinder', 'addNum', 'addNum', 'findMedian', 'addNum', 'findMedian']\n[[], [1], [2], [], [3], []]\nOutput\n[null, null, null, 1.5, null, 2.0]\n\nExplanation\nMedianFinder medianFinder = new MedianFinder();\nmedianFinder.addNum(1);    // arr = [1]\nmedianFinder.addNum(2);    // arr = [1, 2]\nmedianFinder.findMedian(); // return 1.5 (i.e., (1 + 2) / 2)\nmedianFinder.addNum(3);    // arr = [1, 2, 3]\nmedianFinder.findMedian(); // return 2.0\n\nConstraints:\n• -10^5 <= num <= 10^5\n• There will be at least one element in the data structure before calling findMedian.\n• At most 5 * 10^4 calls will be made to addNum and findMedian.\n\nFollow up:\n• If all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?\n• If 99% of all integer numbers from the stream are in the range [0, 100], how would you optimize your solution?",
          "approach": "Use two heaps: max-heap for smaller half, min-heap for larger half. Balance sizes to maintain median at heap tops.",
          "solution": "Maintain two heaps with balanced sizes. Median is either top of larger heap or average of both tops.",
          "code": "import heapq\n\nclass MedianFinder:\n    def __init__(self):\n        self.small = []  # max-heap (store negative values)\n        self.large = []  # min-heap\n\n    def addNum(self, num: int) -> None:\n        # Always add to small heap first\n        heapq.heappush(self.small, -num)\n        \n        # Ensure all elements in small <= all elements in large\n        if (self.small and self.large and \n            -self.small[0] > self.large[0]):\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        \n        # Balance heap sizes (difference <= 1)\n        if len(self.small) > len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        if len(self.large) > len(self.small) + 1:\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n    def findMedian(self) -> float:\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        if len(self.large) > len(self.small):\n            return self.large[0]\n        return (-self.small[0] + self.large[0]) / 2\n\n# Alternative implementation with clearer logic\nclass MedianFinderAlt:\n    def __init__(self):\n        self.max_heap = []  # For smaller half (use negative values)\n        self.min_heap = []  # For larger half\n    \n    def addNum(self, num: int) -> None:\n        # Decide which heap to add to\n        if not self.max_heap or num <= -self.max_heap[0]:\n            heapq.heappush(self.max_heap, -num)\n        else:\n            heapq.heappush(self.min_heap, num)\n        \n        # Rebalance if necessary\n        self._rebalance()\n    \n    def _rebalance(self):\n        if len(self.max_heap) > len(self.min_heap) + 1:\n            val = -heapq.heappop(self.max_heap)\n            heapq.heappush(self.min_heap, val)\n        elif len(self.min_heap) > len(self.max_heap) + 1:\n            val = heapq.heappop(self.min_heap)\n            heapq.heappush(self.max_heap, -val)\n    \n    def findMedian(self) -> float:\n        if len(self.max_heap) == len(self.min_heap):\n            return (-self.max_heap[0] + self.min_heap[0]) / 2.0\n        elif len(self.max_heap) > len(self.min_heap):\n            return -self.max_heap[0]\n        else:\n            return self.min_heap[0]\n\n# Test case\nmedianFinder = MedianFinder()\nmedianFinder.addNum(1)\nmedianFinder.addNum(2)\nprint(medianFinder.findMedian())  # 1.5\nmedianFinder.addNum(3)\nprint(medianFinder.findMedian())  # 2.0",
          "timeComplexity": "O(log n) for addNum, O(1) for findMedian",
          "spaceComplexity": "O(n) for storing all elements in heaps",
          "keyInsights": "• Two heaps divide elements around median efficiently\n• Max-heap stores smaller half, min-heap stores larger half\n• Heap size difference ≤ 1 ensures median is at heap top(s)\n• Balancing after each insertion maintains invariant\n• Pattern: median problems often use dual heap approach\n• Alternative: balanced BST, but heaps are simpler",
          "link": "https://leetcode.com/problems/find-median-from-data-stream/"
        }
      ]
    },
    {
      "id": "backtracking",
      "title": "Backtracking",
      "description": "Systematic exploration of solution space with backtracking to find all valid solutions",
      "questions": [
        {
          "id": "bt_1",
          "title": "Subsets",
          "routeName": "subsets",
          "difficulty": "Medium",
          "leetcodeNumber": 78,
          "companies": ["Amazon", "Google", "Microsoft", "Facebook", "Apple"],
          "tags": ["Array", "Backtracking", "Bit Manipulation"],
          "description": "Given an integer array nums of unique elements, return all possible subsets (the power set).",
          "detailedDescription": "Given an integer array nums of unique elements, return all possible subsets (the power set).\n\nThe solution set must not contain duplicate subsets. Return the solution in any order.\n\nExample 1:\nInput: nums = [1,2,3]\nOutput: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n\nExample 2:\nInput: nums = [0]\nOutput: [[],[0]]\n\nConstraints:\n• 1 <= nums.length <= 10\n• -10 <= nums[i] <= 10\n• All the numbers of nums are unique.",
          "approach": "DFS backtracking where for each element, we have two choices: include it or exclude it in the current subset.",
          "solution": "Use recursion to explore both include/exclude decisions for each element, building subsets incrementally.",
          "code": "def subsets(nums):\n    res = []\n    subset = []\n    \n    def dfs(i):\n        if i == len(nums):\n            res.append(subset.copy())  # Important: copy the subset\n            return\n        \n        # Include nums[i] in current subset\n        subset.append(nums[i])\n        dfs(i + 1)\n        \n        # Exclude nums[i] from current subset (backtrack)\n        subset.pop()\n        dfs(i + 1)\n    \n    dfs(0)\n    return res\n\n# Alternative iterative approach\ndef subsetsIterative(nums):\n    result = [[]]\n    \n    for num in nums:\n        result += [subset + [num] for subset in result]\n    \n    return result\n\n# Alternative bit manipulation approach\ndef subsetsBitManipulation(nums):\n    n = len(nums)\n    result = []\n    \n    for i in range(2**n):\n        subset = []\n        for j in range(n):\n            if (i >> j) & 1:\n                subset.append(nums[j])\n        result.append(subset)\n    \n    return result\n\n# Test case\nnums = [1, 2, 3]\nprint(subsets(nums))\n# Output: [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]",
          "timeComplexity": "O(2^n * n) where n is the length of nums",
          "spaceComplexity": "O(2^n * n) for storing all subsets",
          "keyInsights": "• Classic backtracking pattern: explore, choose, unchoose\n• Each element has two choices: include or exclude\n• Must copy subset when adding to result to avoid reference issues\n• Can also solve with iteration or bit manipulation\n• Foundation for many subset-related problems",
          "link": "https://leetcode.com/problems/subsets/"
        },
        {
          "id": "bt_2",
          "title": "Combination Sum",
          "routeName": "combination_sum",
          "difficulty": "Medium",
          "leetcodeNumber": 39,
          "companies": ["Amazon", "Google", "Microsoft", "Facebook", "Apple"],
          "tags": ["Array", "Backtracking"],
          "description": "Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target.",
          "detailedDescription": "Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.\n\nThe same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.\n\nThe test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input.\n\nExample 1:\nInput: candidates = [2,3,6,7], target = 7\nOutput: [[2,2,3],[7]]\nExplanation:\n2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\n7 is a candidate, and 7 = 7.\nThese are the only two combinations.\n\nExample 2:\nInput: candidates = [2,3,5], target = 8\nOutput: [[2,2,2,2],[2,3,3],[3,5]]\n\nExample 3:\nInput: candidates = [2], target = 1\nOutput: []\n\nConstraints:\n• 1 <= candidates.length <= 30\n• 2 <= candidates[i] <= 40\n• All elements of candidates are distinct.\n• 1 <= target <= 40",
          "approach": "Backtracking with remaining target value. For each candidate, try including it and recurse with reduced target.",
          "solution": "Use DFS to explore combinations, allowing reuse of elements. Prune when remaining target becomes negative.",
          "code": "def combinationSum(candidates, target):\n    res = []\n    candidates.sort()  # Optional: helps with early termination\n    \n    def backtrack(remain, combo, start):\n        if remain == 0:\n            res.append(combo.copy())\n            return\n        if remain < 0:\n            return  # Pruning: no point continuing if target exceeded\n        \n        for i in range(start, len(candidates)):\n            # Early termination if sorted\n            if candidates[i] > remain:\n                break\n            \n            combo.append(candidates[i])\n            # Use same index i to allow reusing same element\n            backtrack(remain - candidates[i], combo, i)\n            combo.pop()  # Backtrack\n    \n    backtrack(target, [], 0)\n    return res\n\n# Alternative implementation without sorting\ndef combinationSumAlt(candidates, target):\n    result = []\n    \n    def backtrack(start, current_combination, remaining_target):\n        if remaining_target == 0:\n            result.append(current_combination[:])\n            return\n        \n        for i in range(start, len(candidates)):\n            if candidates[i] <= remaining_target:\n                current_combination.append(candidates[i])\n                backtrack(i, current_combination, remaining_target - candidates[i])\n                current_combination.pop()\n    \n    backtrack(0, [], target)\n    return result\n\n# Test case\ncandidates = [2, 3, 6, 7]\ntarget = 7\nprint(combinationSum(candidates, target))\n# Output: [[2, 2, 3], [7]]",
          "timeComplexity": "O(N^(T/M)) where N is number of candidates, T is target, M is minimal value",
          "spaceComplexity": "O(T/M) for recursion depth",
          "keyInsights": "• Allow reusing elements by starting next recursion from same index\n• Sorting enables early termination for efficiency\n• Track remaining target instead of current sum\n• Pruning when remaining < 0 reduces unnecessary exploration\n• Pattern: combination problems with unlimited reuse",
          "link": "https://leetcode.com/problems/combination-sum/"
        },
        {
          "id": "bt_3",
          "title": "Permutations",
          "routeName": "permutations",
          "difficulty": "Medium",
          "leetcodeNumber": 46,
          "companies": ["Amazon", "Google", "Microsoft", "Facebook", "Apple"],
          "tags": ["Array", "Backtracking"],
          "description": "Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.",
          "detailedDescription": "Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.\n\nExample 1:\nInput: nums = [1,2,3]\nOutput: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n\nExample 2:\nInput: nums = [0,1]\nOutput: [[0,1],[1,0]]\n\nExample 3:\nInput: nums = [1]\nOutput: [[1]]\n\nConstraints:\n• 1 <= nums.length <= 6\n• -10 <= nums[i] <= 10\n• All the integers of nums are unique.",
          "approach": "Backtracking by building permutations one element at a time, tracking used elements to avoid duplicates.",
          "solution": "Use DFS with path tracking and remaining elements, or use visited array to track element usage.",
          "code": "def permute(nums):\n    res = []\n    \n    def backtrack(path, remaining):\n        if not remaining:\n            res.append(path)\n            return\n        \n        for i in range(len(remaining)):\n            # Choose current element\n            new_path = path + [remaining[i]]\n            new_remaining = remaining[:i] + remaining[i+1:]\n            backtrack(new_path, new_remaining)\n    \n    backtrack([], nums)\n    return res\n\n# Alternative implementation using visited array\ndef permuteVisited(nums):\n    result = []\n    \n    def backtrack(current_permutation):\n        if len(current_permutation) == len(nums):\n            result.append(current_permutation[:])\n            return\n        \n        for num in nums:\n            if num not in current_permutation:\n                current_permutation.append(num)\n                backtrack(current_permutation)\n                current_permutation.pop()\n    \n    backtrack([])\n    return result\n\n# More efficient implementation with index swapping\ndef permuteSwap(nums):\n    result = []\n    \n    def backtrack(start):\n        if start == len(nums):\n            result.append(nums[:])\n            return\n        \n        for i in range(start, len(nums)):\n            # Swap current element to start position\n            nums[start], nums[i] = nums[i], nums[start]\n            backtrack(start + 1)\n            # Backtrack: swap back\n            nums[start], nums[i] = nums[i], nums[start]\n    \n    backtrack(0)\n    return result\n\n# Iterative approach using built-in\nfrom itertools import permutations\n\ndef permuteItertools(nums):\n    return list(map(list, permutations(nums)))\n\n# Test case\nnums = [1, 2, 3]\nprint(permute(nums))\n# Output: [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]",
          "timeComplexity": "O(n! * n) where n is the length of nums",
          "spaceComplexity": "O(n! * n) for storing all permutations",
          "keyInsights": "• Permutations require tracking which elements are used\n• Can use remaining elements list or visited array\n• Swapping approach modifies input array but is more efficient\n• Each level of recursion fixes one position\n• Pattern: when order matters, use permutation-style backtracking",
          "link": "https://leetcode.com/problems/permutations/"
        },
        {
          "id": "bt_4",
          "title": "Subsets II",
          "routeName": "subsets_ii",
          "difficulty": "Medium",
          "leetcodeNumber": 90,
          "companies": ["Amazon", "Google", "Microsoft", "Facebook"],
          "tags": ["Array", "Backtracking", "Bit Manipulation"],
          "description": "Given an integer array nums that may contain duplicates, return all possible subsets (the power set).",
          "detailedDescription": "Given an integer array nums that may contain duplicates, return all possible subsets (the power set).\n\nThe solution set must not contain duplicate subsets. Return the solution in any order.\n\nExample 1:\nInput: nums = [1,2,2]\nOutput: [[],[1],[1,2],[1,2,2],[2],[2,2]]\n\nExample 2:\nInput: nums = [0]\nOutput: [[],[0]]\n\nConstraints:\n• 1 <= nums.length <= 10\n• -10 <= nums[i] <= 10",
          "approach": "Sort array first, then use backtracking with duplicate skipping. Skip duplicates at same recursion level.",
          "solution": "Sort input, then for each level skip consecutive duplicates except the first occurrence.",
          "code": "def subsetsWithDup(nums):\n    res = []\n    nums.sort()  # Sort to group duplicates together\n    \n    def backtrack(start, path):\n        # Add current subset to result\n        res.append(path.copy())\n        \n        for i in range(start, len(nums)):\n            # Skip duplicates: if current element equals previous\n            # and we're not at the start of this level\n            if i > start and nums[i] == nums[i-1]:\n                continue\n            \n            path.append(nums[i])\n            backtrack(i + 1, path)\n            path.pop()\n    \n    backtrack(0, [])\n    return res\n\n# Alternative implementation with more explicit duplicate handling\ndef subsetsWithDupAlt(nums):\n    result = []\n    nums.sort()\n    \n    def backtrack(index, current_subset):\n        if index == len(nums):\n            result.append(current_subset[:])\n            return\n        \n        # Include current element\n        current_subset.append(nums[index])\n        backtrack(index + 1, current_subset)\n        current_subset.pop()\n        \n        # Skip all duplicates and exclude current element\n        while index + 1 < len(nums) and nums[index] == nums[index + 1]:\n            index += 1\n        backtrack(index + 1, current_subset)\n    \n    backtrack(0, [])\n    return result\n\n# Test case\nnums = [1, 2, 2]\nprint(subsetsWithDup(nums))\n# Output: [[], [1], [1, 2], [1, 2, 2], [2], [2, 2]]",
          "timeComplexity": "O(2^n * n) where n is the length of nums",
          "spaceComplexity": "O(2^n * n) for storing all unique subsets",
          "keyInsights": "• Sorting is crucial for efficient duplicate detection\n• Skip duplicates only at the same recursion level, not across levels\n• Use 'i > start' condition to allow first occurrence of duplicates\n• Pattern: sort + skip duplicates for problems with duplicate inputs\n• Extends basic subset generation to handle duplicates",
          "link": "https://leetcode.com/problems/subsets-ii/"
        },
        {
          "id": "bt_5",
          "title": "Combination Sum II",
          "routeName": "combination_sum_ii",
          "difficulty": "Medium",
          "leetcodeNumber": 40,
          "companies": ["Amazon", "Google", "Microsoft", "Facebook"],
          "tags": ["Array", "Backtracking"],
          "description": "Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.",
          "detailedDescription": "Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.\n\nEach number in candidates may only be used once in the combination.\n\nNote: The solution set must not contain duplicate combinations.\n\nExample 1:\nInput: candidates = [10,1,2,7,6,1,5], target = 8\nOutput: [[1,1,6],[1,2,5],[1,7],[2,6]]\n\nExample 2:\nInput: candidates = [2,5,2,1,2], target = 5\nOutput: [[1,2,2],[5]]\n\nConstraints:\n• 1 <= candidates.length <= 100\n• 1 <= candidates[i] <= 50\n• 1 <= target <= 30",
          "approach": "Sort array, use backtracking with duplicate skipping. Each element can only be used once, so increment start index.",
          "solution": "Sort input to group duplicates, skip duplicates at same level, increment index to avoid reuse of same element.",
          "code": "def combinationSum2(candidates, target):\n    res = []\n    candidates.sort()  # Sort to handle duplicates\n    \n    def backtrack(remain, combo, start):\n        if remain == 0:\n            res.append(combo.copy())\n            return\n        if remain < 0:\n            return  # Pruning\n        \n        for i in range(start, len(candidates)):\n            # Skip duplicates at the same level\n            if i > start and candidates[i] == candidates[i-1]:\n                continue\n            \n            # Early termination if sorted\n            if candidates[i] > remain:\n                break\n            \n            combo.append(candidates[i])\n            # Use i+1 to avoid reusing same element\n            backtrack(remain - candidates[i], combo, i + 1)\n            combo.pop()\n    \n    backtrack(target, [], 0)\n    return res\n\n# Alternative implementation with explicit duplicate handling\ndef combinationSum2Alt(candidates, target):\n    result = []\n    candidates.sort()\n    \n    def backtrack(start, current_combination, remaining_target):\n        if remaining_target == 0:\n            result.append(current_combination[:])\n            return\n        \n        prev = -1\n        for i in range(start, len(candidates)):\n            # Skip duplicates\n            if candidates[i] == prev:\n                continue\n            \n            if candidates[i] <= remaining_target:\n                current_combination.append(candidates[i])\n                backtrack(i + 1, current_combination, remaining_target - candidates[i])\n                current_combination.pop()\n                prev = candidates[i]\n    \n    backtrack(0, [], target)\n    return result\n\n# Test case\ncandidates = [10, 1, 2, 7, 6, 1, 5]\ntarget = 8\nprint(combinationSum2(candidates, target))\n# Output: [[1, 1, 6], [1, 2, 5], [1, 7], [2, 6]]",
          "timeComplexity": "O(2^n) where n is the length of candidates",
          "spaceComplexity": "O(target) for recursion depth",
          "keyInsights": "• Combines duplicate handling with single-use constraint\n• Sort + skip duplicates pattern prevents duplicate combinations\n• Use i+1 for next recursion to ensure single use per element\n• Early termination with sorted array improves performance\n• Pattern: when elements can't be reused, increment start index",
          "link": "https://leetcode.com/problems/combination-sum-ii/"
        },
        {
          "id": "bt_6",
          "title": "Word Search",
          "routeName": "word_search",
          "difficulty": "Medium",
          "leetcodeNumber": 79,
          "companies": ["Amazon", "Google", "Microsoft", "Facebook", "Apple"],
          "tags": ["Array", "Backtracking", "Matrix"],
          "description": "Given an m x n grid of characters board and a string word, return true if word exists in the grid.",
          "detailedDescription": "Given an m x n grid of characters board and a string word, return true if word exists in the grid.\n\nThe word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.\n\nExample 1:\nInput: board = [['A','B','C','E'],['S','F','C','S'],['A','D','E','E']], word = 'ABCCED'\nOutput: true\n\nExample 2:\nInput: board = [['A','B','C','E'],['S','F','C','S'],['A','D','E','E']], word = 'SEE'\nOutput: true\n\nExample 3:\nInput: board = [['A','B','C','E'],['S','F','C','S'],['A','D','E','E']], word = 'ABCB'\nOutput: false\n\nConstraints:\n• m == board.length\n• n = board[i].length\n• 1 <= m, n <= 6\n• 1 <= word.length <= 15\n• board and word consists of only lowercase and uppercase English letters.",
          "approach": "DFS from each cell that matches first character. Use temporary marking to avoid revisiting cells in same path.",
          "solution": "Try starting from each cell, use DFS with path marking to explore all 4 directions while building the word.",
          "code": "def exist(board, word):\n    if not board or not board[0] or not word:\n        return False\n    \n    rows, cols = len(board), len(board[0])\n    \n    def backtrack(r, c, index):\n        # Found complete word\n        if index == len(word):\n            return True\n        \n        # Boundary checks and character match\n        if (r < 0 or r >= rows or c < 0 or c >= cols or \n            board[r][c] != word[index]):\n            return False\n        \n        # Mark cell as visited\n        temp = board[r][c]\n        board[r][c] = '#'\n        \n        # Explore all 4 directions\n        found = (backtrack(r+1, c, index+1) or \n                backtrack(r-1, c, index+1) or \n                backtrack(r, c+1, index+1) or \n                backtrack(r, c-1, index+1))\n        \n        # Restore cell (backtrack)\n        board[r][c] = temp\n        \n        return found\n    \n    # Try starting from each cell\n    for r in range(rows):\n        for c in range(cols):\n            if backtrack(r, c, 0):\n                return True\n    \n    return False\n\n# Alternative implementation with visited set\ndef existVisited(board, word):\n    rows, cols = len(board), len(board[0])\n    \n    def dfs(r, c, index, visited):\n        if index == len(word):\n            return True\n        \n        if (r < 0 or r >= rows or c < 0 or c >= cols or \n            (r, c) in visited or board[r][c] != word[index]):\n            return False\n        \n        visited.add((r, c))\n        \n        result = (dfs(r+1, c, index+1, visited) or\n                 dfs(r-1, c, index+1, visited) or\n                 dfs(r, c+1, index+1, visited) or\n                 dfs(r, c-1, index+1, visited))\n        \n        visited.remove((r, c))\n        return result\n    \n    for r in range(rows):\n        for c in range(cols):\n            if dfs(r, c, 0, set()):\n                return True\n    \n    return False\n\n# Test case\nboard = [['A','B','C','E'],['S','F','C','S'],['A','D','E','E']]\nword = 'ABCCED'\nprint(exist(board, word))  # True\n\nword2 = 'SEE'\nprint(exist(board, word2))  # True\n\nword3 = 'ABCB'\nprint(exist(board, word3))  # False",
          "timeComplexity": "O(m * n * 4^L) where m,n are board dimensions and L is word length",
          "spaceComplexity": "O(L) for recursion depth",
          "keyInsights": "• Must track visited cells in current path to avoid cycles\n• Temporary marking (board[r][c] = '#') is efficient for path tracking\n• Try all possible starting positions for the word\n• Backtrack by restoring original cell value\n• Pattern: 2D grid traversal with path constraints",
          "link": "https://leetcode.com/problems/word-search/"
        },
        {
          "id": "bt_7",
          "title": "Palindrome Partitioning",
          "routeName": "palindrome_partitioning",
          "difficulty": "Medium",
          "leetcodeNumber": 131,
          "companies": ["Amazon", "Google", "Microsoft", "Facebook"],
          "tags": ["String", "Dynamic Programming", "Backtracking"],
          "description": "Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s.",
          "detailedDescription": "Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s.\n\nExample 1:\nInput: s = 'aab'\nOutput: [['a','a','b'],['aa','b']]\n\nExample 2:\nInput: s = 'raceacar'\nOutput: [['r','a','c','e','a','c','a','r'],['r','a','ce','c','a','r'],['r','ace','ca','r'],['raceacar']]\n\nExample 3:\nInput: s = 'a'\nOutput: [['a']]\n\nConstraints:\n• 1 <= s.length <= 16\n• s contains only lowercase English letters.",
          "approach": "Backtracking to try all possible partitions. For each position, try all possible palindromic substrings starting from that position.",
          "solution": "Use DFS to explore all partitions, checking if each substring is palindrome before adding to current partition.",
          "code": "def partition(s):\n    res = []\n    \n    def is_palindrome(start, end):\n        while start < end:\n            if s[start] != s[end]:\n                return False\n            start += 1\n            end -= 1\n        return True\n    \n    def backtrack(start, path):\n        if start == len(s):\n            res.append(path.copy())\n            return\n        \n        for end in range(start, len(s)):\n            if is_palindrome(start, end):\n                path.append(s[start:end+1])\n                backtrack(end + 1, path)\n                path.pop()\n    \n    backtrack(0, [])\n    return res\n\n# Optimized version with memoized palindrome check\ndef partitionOptimized(s):\n    n = len(s)\n    # Precompute palindrome matrix\n    is_palindrome = [[False] * n for _ in range(n)]\n    \n    # Every single character is palindrome\n    for i in range(n):\n        is_palindrome[i][i] = True\n    \n    # Check for palindromes of length 2\n    for i in range(n - 1):\n        if s[i] == s[i + 1]:\n            is_palindrome[i][i + 1] = True\n    \n    # Check for palindromes of length 3 or more\n    for length in range(3, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if s[i] == s[j] and is_palindrome[i + 1][j - 1]:\n                is_palindrome[i][j] = True\n    \n    result = []\n    \n    def backtrack(start, current_partition):\n        if start == n:\n            result.append(current_partition[:])\n            return\n        \n        for end in range(start, n):\n            if is_palindrome[start][end]:\n                current_partition.append(s[start:end + 1])\n                backtrack(end + 1, current_partition)\n                current_partition.pop()\n    \n    backtrack(0, [])\n    return result\n\n# Alternative with expand around center for palindrome check\ndef partitionExpandCenter(s):\n    def expand_around_center(left, right):\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return left + 1, right - 1\n    \n    def is_palindrome_substring(start, end):\n        return s[start:end+1] == s[start:end+1][::-1]\n    \n    result = []\n    \n    def backtrack(index, current_partition):\n        if index == len(s):\n            result.append(current_partition[:])\n            return\n        \n        for i in range(index, len(s)):\n            if is_palindrome_substring(index, i):\n                current_partition.append(s[index:i+1])\n                backtrack(i + 1, current_partition)\n                current_partition.pop()\n    \n    backtrack(0, [])\n    return result\n\n# Test case\ns = 'aab'\nprint(partition(s))\n# Output: [['a', 'a', 'b'], ['aa', 'b']]",
          "timeComplexity": "O(2^n * n) where n is length of string",
          "spaceComplexity": "O(n) for recursion depth and path storage",
          "keyInsights": "• Try all possible cuts in the string with palindrome validation\n• Palindrome check can be optimized with precomputation\n• Each valid palindromic substring leads to subproblem on remaining string\n• Pattern: string partitioning with validity constraints\n• Can optimize with DP table for palindrome checks",
          "link": "https://leetcode.com/problems/palindrome-partitioning/"
        },
        {
          "id": "bt_8",
          "title": "Letter Combinations of a Phone Number",
          "routeName": "letter_combinations_phone",
          "difficulty": "Medium",
          "leetcodeNumber": 17,
          "companies": ["Amazon", "Google", "Microsoft", "Facebook", "Apple"],
          "tags": ["Hash Table", "String", "Backtracking"],
          "description": "Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.",
          "detailedDescription": "Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.\n\nA mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\n\n2: abc\n3: def\n4: ghi\n5: jkl\n6: mno\n7: pqrs\n8: tuv\n9: wxyz\n\nExample 1:\nInput: digits = '23'\nOutput: ['ad','ae','af','bd','be','bf','cd','ce','cf']\n\nExample 2:\nInput: digits = ''\nOutput: []\n\nExample 3:\nInput: digits = '2'\nOutput: ['a','b','c']\n\nConstraints:\n• 0 <= digits.length <= 4\n• digits[i] is a digit in the range ['2', '9'].",
          "approach": "Backtracking to build combinations character by character. For each digit, try all possible letters.",
          "solution": "Use mapping dictionary and DFS to explore all combinations by appending letters for each digit position.",
          "code": "def letterCombinations(digits):\n    if not digits:\n        return []\n    \n    # Mapping of digits to letters\n    phone_map = {\n        '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl',\n        '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'\n    }\n    \n    res = []\n    \n    def backtrack(index, path):\n        # Base case: processed all digits\n        if index == len(digits):\n            res.append(''.join(path))\n            return\n        \n        # Get letters for current digit\n        letters = phone_map[digits[index]]\n        \n        # Try each letter for current digit\n        for letter in letters:\n            path.append(letter)\n            backtrack(index + 1, path)\n            path.pop()\n    \n    backtrack(0, [])\n    return res\n\n# Alternative iterative approach\ndef letterCombinationsIterative(digits):\n    if not digits:\n        return []\n    \n    phone_map = {\n        '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl',\n        '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'\n    }\n    \n    result = ['']\n    \n    for digit in digits:\n        temp = []\n        for combination in result:\n            for letter in phone_map[digit]:\n                temp.append(combination + letter)\n        result = temp\n    \n    return result\n\n# Using product from itertools\nfrom itertools import product\n\ndef letterCombinationsProduct(digits):\n    if not digits:\n        return []\n    \n    phone_map = {\n        '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl',\n        '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'\n    }\n    \n    letter_groups = [phone_map[digit] for digit in digits]\n    return [''.join(combination) for combination in product(*letter_groups)]\n\n# Test case\ndigits = '23'\nprint(letterCombinations(digits))\n# Output: ['ad', 'ae', 'af', 'bd', 'be', 'bf', 'cd', 'ce', 'cf']",
          "timeComplexity": "O(4^n * n) where n is length of digits (4 is max letters per digit)",
          "spaceComplexity": "O(4^n * n) for storing all combinations",
          "keyInsights": "• Classic backtracking for generating all combinations\n• Use index to track current digit position\n• Each digit contributes one letter to final combination\n• Can also solve iteratively by building combinations incrementally\n• Pattern: cartesian product of character sets",
          "link": "https://leetcode.com/problems/letter-combinations-of-a-phone-number/"
        },
        {
          "id": "bt_9",
          "title": "N-Queens",
          "routeName": "n_queens",
          "difficulty": "Hard",
          "leetcodeNumber": 51,
          "companies": ["Amazon", "Google", "Microsoft", "Facebook", "Apple"],
          "tags": ["Array", "Backtracking"],
          "description": "The n-queens puzzle is the problem of placing n chess queens on an n×n chessboard so that no two queens attack each other.",
          "detailedDescription": "The n-queens puzzle is the problem of placing n chess queens on an n×n chessboard so that no two queens attack each other.\n\nGiven an integer n, return all distinct solutions to the n-queens puzzle. You may return the answer in any order.\n\nEach solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space, respectively.\n\nExample 1:\nInput: n = 4\nOutput: [[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"]]\nExplanation: There exist two distinct solutions to the 4-queens puzzle as shown above\n\nExample 2:\nInput: n = 1\nOutput: [[\"Q\"]]\n\nConstraints:\n• 1 <= n <= 9",
          "approach": "Backtracking with constraint checking. Place queens row by row, checking column and diagonal conflicts.",
          "solution": "Use sets to track occupied columns and diagonals. For each row, try placing queen in each valid column.",
          "code": "def solveNQueens(n):\n    res = []\n    board = [['.'] * n for _ in range(n)]\n    \n    # Sets to track conflicts\n    cols = set()  # Columns with queens\n    pos_diags = set()  # Positive diagonals (r + c)\n    neg_diags = set()  # Negative diagonals (r - c)\n    \n    def backtrack(r):\n        # Base case: placed all queens\n        if r == n:\n            res.append([''.join(row) for row in board])\n            return\n        \n        # Try placing queen in each column of current row\n        for c in range(n):\n            # Check if position conflicts with existing queens\n            if c in cols or (r + c) in pos_diags or (r - c) in neg_diags:\n                continue\n            \n            # Place queen\n            board[r][c] = 'Q'\n            cols.add(c)\n            pos_diags.add(r + c)\n            neg_diags.add(r - c)\n            \n            # Recurse to next row\n            backtrack(r + 1)\n            \n            # Backtrack: remove queen\n            board[r][c] = '.'\n            cols.remove(c)\n            pos_diags.remove(r + c)\n            neg_diags.remove(r - c)\n    \n    backtrack(0)\n    return res\n\n# Alternative implementation with is_safe function\ndef solveNQueensAlt(n):\n    def is_safe(board, row, col):\n        # Check column\n        for i in range(row):\n            if board[i][col] == 'Q':\n                return False\n        \n        # Check diagonal (top-left to bottom-right)\n        i, j = row - 1, col - 1\n        while i >= 0 and j >= 0:\n            if board[i][j] == 'Q':\n                return False\n            i -= 1\n            j -= 1\n        \n        # Check diagonal (top-right to bottom-left)\n        i, j = row - 1, col + 1\n        while i >= 0 and j < n:\n            if board[i][j] == 'Q':\n                return False\n            i -= 1\n            j += 1\n        \n        return True\n    \n    def backtrack(board, row, result):\n        if row == n:\n            result.append([''.join(row) for row in board])\n            return\n        \n        for col in range(n):\n            if is_safe(board, row, col):\n                board[row][col] = 'Q'\n                backtrack(board, row + 1, result)\n                board[row][col] = '.'\n    \n    result = []\n    board = [['.'] * n for _ in range(n)]\n    backtrack(board, 0, result)\n    return result\n\n# Optimized version returning just count\ndef totalNQueens(n):\n    def backtrack(row, cols, pos_diags, neg_diags):\n        if row == n:\n            return 1\n        \n        count = 0\n        for col in range(n):\n            if col not in cols and (row + col) not in pos_diags and (row - col) not in neg_diags:\n                count += backtrack(row + 1, \n                                 cols | {col}, \n                                 pos_diags | {row + col}, \n                                 neg_diags | {row - col})\n        return count\n    \n    return backtrack(0, set(), set(), set())\n\n# Test case\nn = 4\nsolutions = solveNQueens(n)\nfor solution in solutions:\n    for row in solution:\n        print(row)\n    print()\n# Output: Two valid 4-queens solutions",
          "timeComplexity": "O(n!) where n is the board size",
          "spaceComplexity": "O(n) for the recursion stack and constraint sets",
          "keyInsights": "• Queens attack along rows, columns, and diagonals\n• Use sets for O(1) conflict checking\n• Positive diagonal: r + c is constant\n• Negative diagonal: r - c is constant\n• Place row by row to reduce search space\n• Pattern: constraint satisfaction with efficient conflict detection",
          "link": "https://leetcode.com/problems/n-queens/"
        }
      ]
    }
  ]
}
