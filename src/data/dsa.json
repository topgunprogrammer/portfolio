{
  "dsaTopics": [
    {
      "id": "strings",
      "title": "Strings",
      "description": "String manipulation, pattern matching, and text processing problems",
      "questions": [
        {
          "id": "str_1",
          "title": "Reverse a String",
          "routeName": "reverse_a_string",
          "difficulty": "Easy",
          "companies": ["Google", "Microsoft", "Amazon"],
          "tags": ["String", "Two Pointers"],
          "description": "Write a function that reverses a string. You may assume the string consists of only lowercase English letters.",
          "detailedDescription": "Given a string s, reverse the string and return it. The reversal should be done in-place if possible, but you can also create a new string.\n\nExample 1:\nInput: s = \"hello\"\nOutput: \"olleh\"\n\nExample 2:\nInput: s = \"abcdef\"\nOutput: \"fedcba\"\n\nConstraints:\n• 1 <= s.length <= 10^5\n• s consists of printable ASCII characters",
          "approach": "Multiple approaches can be used:\n\n1. **Two Pointers Approach**: Use two pointers from start and end, swap characters while moving towards center.\n\n2. **Built-in Methods**: Use language built-in reverse methods (Python: s[::-1], Java: StringBuilder.reverse()).\n\n3. **Stack Approach**: Push all characters to stack and pop them to get reversed string.\n\n4. **Recursive Approach**: Recursively reverse substring and append first character at the end.",
          "solution": "**Approach 1: Two Pointers (In-place for mutable strings)**\n\nThis approach uses two pointers to swap characters from both ends moving towards the center.\n\n**Approach 2: Python Slicing (Most Pythonic)**\n\nPython's slicing feature provides the most concise solution.\n\n**Approach 3: Using Built-in Reverse**\n\nConvert to list, reverse, and join back to string.",
          "code": "# Approach 1: Two Pointers (if string was mutable)\ndef reverse_string_two_pointers(s):\n    chars = list(s)  # Convert to mutable list\n    left, right = 0, len(chars) - 1\n    \n    while left < right:\n        # Swap characters\n        chars[left], chars[right] = chars[right], chars[left]\n        left += 1\n        right -= 1\n    \n    return ''.join(chars)\n\n# Approach 2: Python Slicing (Most Pythonic)\ndef reverse_string_slicing(s):\n    return s[::-1]\n\n# Approach 3: Using Built-in Reverse\ndef reverse_string_builtin(s):\n    return ''.join(reversed(s))\n\n# Approach 4: Recursive\ndef reverse_string_recursive(s):\n    if len(s) <= 1:\n        return s\n    return reverse_string_recursive(s[1:]) + s[0]\n\n# Test the functions\ntest_cases = [\"hello\", \"abcdef\", \"a\", \"\"]\nfor test in test_cases:\n    print(f\"Input: '{test}' -> Output: '{reverse_string_slicing(test)}'\")",
          "timeComplexity": "O(n) where n is the length of the string. We need to process each character once.",
          "spaceComplexity": "• **Two Pointers**: O(n) for creating the character list\n• **Slicing**: O(n) for creating the new reversed string\n• **Built-in**: O(n) for the result string\n• **Recursive**: O(n) for recursion stack space",
          "keyInsights": "• String reversal is a fundamental operation in many algorithms\n• Two pointers technique is efficient for in-place operations\n• Python slicing ([::-1]) is the most concise and readable\n• Consider memory constraints when choosing between approaches\n• This pattern appears in palindrome problems and string manipulation",
          "link": ""
        },
        {
          "id": "str_2",
          "title": "Valid Anagram",
          "routeName": "valid_anagram",
          "difficulty": "Easy",
          "companies": ["Facebook", "Amazon", "Netflix"],
          "tags": ["String", "Hash Table", "Sorting"],
          "description": "Given two strings s and t, return true if t is an anagram of s, and false otherwise.",
          "detailedDescription": "An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n\nExample 1:\nInput: s = \"anagram\", t = \"nagaram\"\nOutput: true\n\nExample 2:\nInput: s = \"rat\", t = \"car\"\nOutput: false\n\nConstraints:\n• 1 <= s.length, t.length <= 5 * 10^4\n• s and t consist of lowercase English letters",
          "approach": "Several approaches to solve this problem:\n\n1. **Sorting Approach**: Sort both strings and compare if they are equal.\n\n2. **Hash Map/Counter**: Count frequency of each character in both strings and compare.\n\n3. **Array Counting**: Use array of size 26 for lowercase letters to count frequencies.\n\n4. **Character Cancellation**: Increment count for characters in first string, decrement for second string, check if all counts are zero.",
          "solution": "**Approach 1: Sorting**\nSort both strings and check if they are identical.\n\n**Approach 2: Hash Map (Counter)**\nCount character frequencies and compare the frequency maps.\n\n**Approach 3: Array Counting**\nUse a fixed-size array to count character frequencies for better space efficiency.\n\n**Approach 4: Single Pass with Counter**\nIncrement counter for first string, decrement for second string.",
          "code": "from collections import Counter\n\n# Approach 1: Sorting\ndef is_anagram_sorting(s, t):\n    if len(s) != len(t):\n        return False\n    return sorted(s) == sorted(t)\n\n# Approach 2: Hash Map (Counter)\ndef is_anagram_counter(s, t):\n    if len(s) != len(t):\n        return False\n    return Counter(s) == Counter(t)\n\n# Approach 3: Array Counting (most efficient)\ndef is_anagram_array(s, t):\n    if len(s) != len(t):\n        return False\n    \n    # Array for 26 lowercase letters\n    char_count = [0] * 26\n    \n    for i in range(len(s)):\n        char_count[ord(s[i]) - ord('a')] += 1\n        char_count[ord(t[i]) - ord('a')] -= 1\n    \n    return all(count == 0 for count in char_count)\n\n# Approach 4: Manual Counter\ndef is_anagram_manual(s, t):\n    if len(s) != len(t):\n        return False\n    \n    char_count = {}\n    \n    # Count characters in s\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    # Subtract characters in t\n    for char in t:\n        if char not in char_count:\n            return False\n        char_count[char] -= 1\n        if char_count[char] == 0:\n            del char_count[char]\n    \n    return len(char_count) == 0\n\n# Test the functions\ntest_cases = [\n    (\"anagram\", \"nagaram\"),\n    (\"rat\", \"car\"),\n    (\"listen\", \"silent\"),\n    (\"a\", \"ab\")\n]\n\nfor s, t in test_cases:\n    result = is_anagram_array(s, t)\n    print(f\"'{s}' and '{t}': {result}\")",
          "timeComplexity": "• **Sorting**: O(n log n) where n is the length of the strings\n• **Hash Map**: O(n) to iterate through both strings\n• **Array Counting**: O(n) with better constants than hash map\n• **Manual Counter**: O(n) average case",
          "spaceComplexity": "• **Sorting**: O(1) if sorting in-place, O(n) otherwise\n• **Hash Map**: O(n) for storing character counts\n• **Array Counting**: O(1) since array size is fixed (26)\n• **Manual Counter**: O(n) in worst case for the hash map",
          "keyInsights": "• Anagram problems often involve character frequency analysis\n• Array counting is most efficient for lowercase English letters\n• Early termination (length check) can save computation\n• Hash maps provide flexibility for Unicode characters\n• This pattern is useful for grouping anagrams and string comparison problems",
          "link": ""
        },
        {
          "id": "str_3",
          "title": "Longest Substring Without Repeating Characters",
          "routeName": "longest_substring_without_repeating_characters",
          "difficulty": "Medium",
          "companies": ["Amazon", "Bloomberg", "Yelp"],
          "tags": ["String", "Sliding Window", "Hash Table"],
          "description": "Given a string s, find the length of the longest substring without repeating characters.",
          "detailedDescription": "Given a string s, find the length of the longest substring without repeating characters.\n\nExample 1:\nInput: s = \"abcabcbb\"\nOutput: 3\nExplanation: The answer is \"abc\", with the length of 3.\n\nExample 2:\nInput: s = \"bbbbb\"\nOutput: 1\nExplanation: The answer is \"b\", with the length of 1.\n\nExample 3:\nInput: s = \"pwwkew\"\nOutput: 3\nExplanation: The answer is \"wke\", with the length of 3.\n\nConstraints:\n• 0 <= s.length <= 5 * 10^4\n• s consists of English letters, digits, symbols and spaces",
          "approach": "This is a classic sliding window problem:\n\n1. **Sliding Window with Hash Set**: Use two pointers and a set to track characters in current window.\n\n2. **Sliding Window with Hash Map**: Store character positions to skip ahead when duplicate is found.\n\n3. **Optimized Sliding Window**: Use hash map to store the latest index of each character for efficient skipping.\n\n4. **Brute Force**: Check all possible substrings (not recommended for large inputs).",
          "solution": "**Sliding Window Technique**\n\nThe key insight is to use a sliding window that expands when no duplicates are found and contracts when a duplicate is encountered.\n\n**Approach 1: Sliding Window with Set**\nMaintain a set of characters in the current window and two pointers.\n\n**Approach 2: Optimized with Hash Map**\nStore the index of each character to jump directly to the position after the duplicate.",
          "code": "# Approach 1: Sliding Window with Set\ndef length_of_longest_substring_set(s):\n    if not s:\n        return 0\n    \n    char_set = set()\n    left = 0\n    max_length = 0\n    \n    for right in range(len(s)):\n        # Shrink window until no duplicate\n        while s[right] in char_set:\n            char_set.remove(s[left])\n            left += 1\n        \n        # Add current character and update max length\n        char_set.add(s[right])\n        max_length = max(max_length, right - left + 1)\n    \n    return max_length\n\n# Approach 2: Optimized Sliding Window with Hash Map\ndef length_of_longest_substring_map(s):\n    if not s:\n        return 0\n    \n    char_index = {}  # Maps character to its latest index\n    left = 0\n    max_length = 0\n    \n    for right in range(len(s)):\n        char = s[right]\n        \n        # If character is already in window, move left pointer\n        if char in char_index and char_index[char] >= left:\n            left = char_index[char] + 1\n        \n        # Update character's latest index\n        char_index[char] = right\n        \n        # Update max length\n        max_length = max(max_length, right - left + 1)\n    \n    return max_length\n\n# Approach 3: Clean implementation with defaultdict\nfrom collections import defaultdict\n\ndef length_of_longest_substring_clean(s):\n    char_index = defaultdict(lambda: -1)\n    left = 0\n    max_length = 0\n    \n    for right, char in enumerate(s):\n        # Move left pointer if character was seen in current window\n        left = max(left, char_index[char] + 1)\n        \n        # Update max length and character index\n        max_length = max(max_length, right - left + 1)\n        char_index[char] = right\n    \n    return max_length\n\n# Test the functions\ntest_cases = [\n    \"abcabcbb\",\n    \"bbbbb\", \n    \"pwwkew\",\n    \"\",\n    \"dvdf\",\n    \"anviaj\"\n]\n\nfor test in test_cases:\n    result = length_of_longest_substring_map(test)\n    print(f\"Input: '{test}' -> Length: {result}\")",
          "timeComplexity": "O(n) where n is the length of the string. Each character is visited at most twice (once by right pointer, once by left pointer).",
          "spaceComplexity": "• **Set approach**: O(min(m, n)) where m is the size of the character set\n• **Hash Map approach**: O(min(m, n)) for storing character indices\n• In practice, for ASCII characters, space is O(1) since there are at most 128 unique characters",
          "keyInsights": "• Sliding window is perfect for contiguous substring problems\n• Hash map optimization reduces time complexity by avoiding unnecessary character removal\n• The key insight is to jump the left pointer directly instead of moving it one by one\n• This pattern applies to many substring problems with constraints\n• Understanding when to expand vs contract the window is crucial",
          "link": ""
        },
        {
          "id": "str_4",
          "title": "Valid Palindrome",
          "routeName": "valid_palindrome",
          "difficulty": "Easy",
          "companies": ["Facebook", "Microsoft", "Apple"],
          "tags": ["String", "Two Pointers"],
          "description": "A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward.",
          "detailedDescription": "A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.\n\nGiven a string s, return true if it is a palindrome, or false otherwise.\n\nExample 1:\nInput: s = \"A man, a plan, a canal: Panama\"\nOutput: true\nExplanation: \"amanaplanacanalpanama\" is a palindrome.\n\nExample 2:\nInput: s = \"race a car\"\nOutput: false\nExplanation: \"raceacar\" is not a palindrome.\n\nExample 3:\nInput: s = \" \"\nOutput: true\nExplanation: s is an empty string \"\" after removing non-alphanumeric characters.\n\nConstraints:\n• 1 <= s.length <= 2 * 10^5\n• s consists only of printable ASCII characters",
          "approach": "Multiple approaches to solve this problem:\n\n1. **Two Pointers**: Clean the string first, then use two pointers from both ends.\n\n2. **Two Pointers with On-the-fly Cleaning**: Skip non-alphanumeric characters while comparing.\n\n3. **Reverse and Compare**: Clean the string, reverse it, and compare with original.\n\n4. **Recursive**: Clean the string and use recursion to check palindrome property.",
          "solution": "**Approach 1: Two Pointers with Preprocessing**\nFirst clean the string by removing non-alphanumeric characters and converting to lowercase, then use two pointers.\n\n**Approach 2: Two Pointers with On-the-fly Processing**\nUse two pointers and skip invalid characters during comparison.\n\n**Approach 3: Built-in Methods**\nUse Python's built-in methods for cleaning and comparison.",
          "code": "import re\n\n# Approach 1: Two Pointers with Preprocessing\ndef is_palindrome_preprocess(s):\n    # Clean the string: keep only alphanumeric and convert to lowercase\n    cleaned = ''.join(char.lower() for char in s if char.isalnum())\n    \n    # Two pointers approach\n    left, right = 0, len(cleaned) - 1\n    \n    while left < right:\n        if cleaned[left] != cleaned[right]:\n            return False\n        left += 1\n        right -= 1\n    \n    return True\n\n# Approach 2: Two Pointers with On-the-fly Processing (Most Efficient)\ndef is_palindrome_optimal(s):\n    left, right = 0, len(s) - 1\n    \n    while left < right:\n        # Skip non-alphanumeric characters from left\n        while left < right and not s[left].isalnum():\n            left += 1\n        \n        # Skip non-alphanumeric characters from right\n        while left < right and not s[right].isalnum():\n            right -= 1\n        \n        # Compare characters (case-insensitive)\n        if s[left].lower() != s[right].lower():\n            return False\n        \n        left += 1\n        right -= 1\n    \n    return True\n\n# Approach 3: Using Regular Expressions\ndef is_palindrome_regex(s):\n    # Remove non-alphanumeric characters and convert to lowercase\n    cleaned = re.sub(r'[^a-zA-Z0-9]', '', s).lower()\n    return cleaned == cleaned[::-1]\n\n# Approach 4: Functional Programming Style\ndef is_palindrome_functional(s):\n    chars = [char.lower() for char in s if char.isalnum()]\n    return chars == chars[::-1]\n\n# Approach 5: Using filter and join\ndef is_palindrome_filter(s):\n    alphanumeric = ''.join(filter(str.isalnum, s)).lower()\n    return alphanumeric == alphanumeric[::-1]\n\n# Test the functions\ntest_cases = [\n    \"A man, a plan, a canal: Panama\",\n    \"race a car\",\n    \" \",\n    \"Madam\",\n    \"No 'x' in Nixon\",\n    \"Was it a car or a cat I saw?\"\n]\n\nfor test in test_cases:\n    result = is_palindrome_optimal(test)\n    print(f\"'{test}' -> {result}\")",
          "timeComplexity": "• **Preprocessing approach**: O(n) for cleaning + O(n) for checking = O(n)\n• **On-the-fly approach**: O(n) single pass through the string\n• **Regex approach**: O(n) for regex processing + O(n) for comparison = O(n)\nwhere n is the length of the input string.",
          "spaceComplexity": "• **Preprocessing approach**: O(n) for storing the cleaned string\n• **On-the-fly approach**: O(1) only using two pointers\n• **Regex approach**: O(n) for storing cleaned string\n• **Functional approach**: O(n) for storing the character list",
          "keyInsights": "• Two pointers technique is ideal for palindrome problems\n• On-the-fly processing saves memory by avoiding string preprocessing\n• Case-insensitive comparison requires careful handling\n• Regular expressions provide clean but potentially slower solutions\n• The pattern of skipping invalid characters while maintaining two pointers is reusable\n• Consider memory constraints when choosing between preprocessing vs on-the-fly approaches",
          "link": ""
        }
      ]
    },
    {
      "id": "arrays",
      "title": "Arrays",
      "description": "Array manipulation, searching, and algorithmic problems",
      "questions": [
        {
          "id": "arr_1",
          "title": "Two Sum",
          "routeName": "two_sum",
          "difficulty": "Easy",
          "companies": ["Google", "Amazon", "Apple", "Facebook"],
          "tags": ["Array", "Hash Table"],
          "description": "Find two numbers in an array that add up to a target sum.",
          "link": ""
        },
        {
          "id": "arr_2",
          "title": "Best Time to Buy and Sell Stock",
          "routeName": "best_time_to_buy_and_sell_stock",
          "difficulty": "Easy",
          "companies": ["Amazon", "Bloomberg", "Facebook"],
          "tags": ["Array", "Dynamic Programming"],
          "description": "Find the maximum profit from buying and selling stock.",
          "link": ""
        },
        {
          "id": "arr_3",
          "title": "Contains Duplicate",
          "routeName": "contains_duplicate",
          "difficulty": "Easy",
          "companies": ["Google", "Yahoo", "Airbnb"],
          "tags": ["Array", "Hash Table"],
          "description": "Determine if array contains any duplicates.",
          "link": ""
        },
        {
          "id": "arr_4",
          "title": "Maximum Subarray",
          "routeName": "maximum_subarray",
          "difficulty": "Easy",
          "companies": ["Microsoft", "LinkedIn", "Amazon"],
          "tags": ["Array", "Dynamic Programming", "Divide and Conquer"],
          "description": "Find the contiguous subarray with the largest sum.",
          "link": ""
        }
      ]
    },
    {
      "id": "searching",
      "title": "Searching",
      "description": "Binary search, linear search, and search optimization techniques",
      "questions": [
        {
          "id": "search_1",
          "title": "Binary Search",
          "routeName": "binary_search",
          "difficulty": "Easy",
          "companies": ["Google", "Facebook", "Microsoft"],
          "tags": ["Array", "Binary Search"],
          "description": "Implement binary search algorithm.",
          "link": ""
        },
        {
          "id": "search_2",
          "title": "Search in Rotated Sorted Array",
          "routeName": "search_in_rotated_sorted_array",
          "difficulty": "Medium",
          "companies": ["Facebook", "Microsoft", "Amazon"],
          "tags": ["Array", "Binary Search"],
          "description": "Search for a target value in a rotated sorted array.",
          "link": ""
        },
        {
          "id": "search_3",
          "title": "Find First and Last Position",
          "routeName": "find_first_and_last_position",
          "difficulty": "Medium",
          "companies": ["Google", "Amazon", "Bloomberg"],
          "tags": ["Array", "Binary Search"],
          "description": "Find first and last position of element in sorted array.",
          "link": ""
        }
      ]
    },
    {
      "id": "sorting",
      "title": "Sorting",
      "description": "Sorting algorithms and related problems",
      "questions": [
        {
          "id": "sort_1",
          "title": "Merge Sort",
          "routeName": "merge_sort",
          "difficulty": "Medium",
          "companies": ["Microsoft", "Amazon", "Apple"],
          "tags": ["Array", "Divide and Conquer", "Sorting"],
          "description": "Implement merge sort algorithm.",
          "link": ""
        },
        {
          "id": "sort_2",
          "title": "Quick Sort",
          "routeName": "quick_sort",
          "difficulty": "Medium",
          "companies": ["Google", "Facebook", "Netflix"],
          "tags": ["Array", "Divide and Conquer", "Sorting"],
          "description": "Implement quick sort algorithm.",
          "link": ""
        },
        {
          "id": "sort_3",
          "title": "Sort Colors",
          "routeName": "sort_colors",
          "difficulty": "Medium",
          "companies": ["Microsoft", "Facebook", "Amazon"],
          "tags": ["Array", "Two Pointers", "Sorting"],
          "description": "Sort an array with 0s, 1s, and 2s.",
          "link": ""
        }
      ]
    },
    {
      "id": "loops",
      "title": "Loops",
      "description": "Loop optimization and iteration problems",
      "questions": [
        {
          "id": "loop_1",
          "title": "FizzBuzz",
          "routeName": "fizzbuzz",
          "difficulty": "Easy",
          "companies": ["Amazon", "Microsoft", "Apple"],
          "tags": ["Math", "String"],
          "description": "Print numbers 1 to n, but for multiples of 3 print Fizz, for multiples of 5 print Buzz.",
          "link": ""
        },
        {
          "id": "loop_2",
          "title": "Power of Two",
          "routeName": "power_of_two",
          "difficulty": "Easy",
          "companies": ["Google", "Amazon", "Adobe"],
          "tags": ["Math", "Bit Manipulation"],
          "description": "Determine if a number is a power of two.",
          "link": ""
        }
      ]
    },
    {
      "id": "2d-array",
      "title": "2D Arrays",
      "description": "Matrix operations and 2D array problems",
      "questions": [
        {
          "id": "2d_1",
          "title": "Rotate Image",
          "routeName": "rotate_image",
          "difficulty": "Medium",
          "companies": ["Amazon", "Apple", "Microsoft"],
          "tags": ["Array", "Math", "Matrix"],
          "description": "Rotate an n x n 2D matrix by 90 degrees clockwise.",
          "link": ""
        },
        {
          "id": "2d_2",
          "title": "Spiral Matrix",
          "routeName": "spiral_matrix",
          "difficulty": "Medium",
          "companies": ["Microsoft", "Amazon", "Facebook"],
          "tags": ["Array", "Matrix", "Simulation"],
          "description": "Return all elements of matrix in spiral order.",
          "link": ""
        },
        {
          "id": "2d_3",
          "title": "Set Matrix Zeroes",
          "routeName": "set_matrix_zeroes",
          "difficulty": "Medium",
          "companies": ["Microsoft", "Amazon", "Apple"],
          "tags": ["Array", "Hash Table", "Matrix"],
          "description": "Set entire row and column to 0 if an element is 0.",
          "link": ""
        }
      ]
    },
    {
      "id": "patterns",
      "title": "Patterns",
      "description": "Common algorithmic patterns and techniques",
      "questions": [
        {
          "id": "pattern_1",
          "title": "Sliding Window Maximum",
          "routeName": "sliding_window_maximum",
          "difficulty": "Hard",
          "companies": ["Amazon", "Google", "Facebook"],
          "tags": ["Array", "Queue", "Sliding Window", "Heap"],
          "description": "Find the maximum element in each sliding window of size k.",
          "link": ""
        },
        {
          "id": "pattern_2",
          "title": "Two Pointers Pattern",
          "routeName": "two_pointers_pattern",
          "difficulty": "Medium",
          "companies": ["Facebook", "Microsoft", "LinkedIn"],
          "tags": ["Array", "Two Pointers"],
          "description": "Master the two pointers technique.",
          "link": ""
        }
      ]
    },
    {
      "id": "recursion",
      "title": "Recursion",
      "description": "Recursive algorithms and backtracking problems",
      "questions": [
        {
          "id": "rec_1",
          "title": "Fibonacci Number",
          "routeName": "fibonacci_number",
          "difficulty": "Easy",
          "companies": ["Amazon", "Microsoft", "Adobe"],
          "tags": ["Math", "Dynamic Programming", "Recursion"],
          "description": "Calculate the nth Fibonacci number.",
          "link": ""
        },
        {
          "id": "rec_2",
          "title": "Generate Parentheses",
          "routeName": "generate_parentheses",
          "difficulty": "Medium",
          "companies": ["Google", "Amazon", "Facebook"],
          "tags": ["String", "Dynamic Programming", "Backtracking"],
          "description": "Generate all combinations of well-formed parentheses.",
          "link": ""
        },
        {
          "id": "rec_3",
          "title": "Permutations",
          "routeName": "permutations",
          "difficulty": "Medium",
          "companies": ["Microsoft", "Amazon", "LinkedIn"],
          "tags": ["Array", "Backtracking"],
          "description": "Generate all possible permutations of an array.",
          "link": ""
        }
      ]
    },
    {
      "id": "linked-list",
      "title": "Linked Lists",
      "description": "Linked list manipulation and algorithms",
      "questions": [
        {
          "id": "ll_1",
          "title": "Reverse Linked List",
          "routeName": "reverse_linked_list",
          "difficulty": "Easy",
          "companies": ["Amazon", "Microsoft", "Apple", "Facebook"],
          "tags": ["Linked List", "Recursion"],
          "description": "Reverse a singly linked list.",
          "link": ""
        },
        {
          "id": "ll_2",
          "title": "Merge Two Sorted Lists",
          "routeName": "merge_two_sorted_lists",
          "difficulty": "Easy",
          "companies": ["Amazon", "Google", "Apple"],
          "tags": ["Linked List", "Recursion"],
          "description": "Merge two sorted linked lists into one.",
          "link": ""
        },
        {
          "id": "ll_3",
          "title": "Linked List Cycle",
          "routeName": "linked_list_cycle",
          "difficulty": "Easy",
          "companies": ["Amazon", "Microsoft", "Yahoo"],
          "tags": ["Hash Table", "Linked List", "Two Pointers"],
          "description": "Determine if a linked list has a cycle.",
          "link": ""
        }
      ]
    },
    {
      "id": "stacks",
      "title": "Stacks",
      "description": "Stack data structure and related algorithms",
      "questions": [
        {
          "id": "stack_1",
          "title": "Valid Parentheses",
          "routeName": "valid_parentheses",
          "difficulty": "Easy",
          "companies": ["Amazon", "Google", "Microsoft", "Facebook"],
          "tags": ["String", "Stack"],
          "description": "Determine if parentheses are properly balanced.",
          "link": ""
        },
        {
          "id": "stack_2",
          "title": "Min Stack",
          "routeName": "min_stack",
          "difficulty": "Easy",
          "companies": ["Amazon", "Google", "Bloomberg"],
          "tags": ["Stack", "Design"],
          "description": "Design a stack that supports push, pop, top, and getMin in O(1).",
          "link": ""
        },
        {
          "id": "stack_3",
          "title": "Daily Temperatures",
          "routeName": "daily_temperatures",
          "difficulty": "Medium",
          "companies": ["Google", "Amazon", "Facebook"],
          "tags": ["Array", "Stack", "Monotonic Stack"],
          "description": "Find the number of days until a warmer temperature.",
          "link": ""
        }
      ]
    },
    {
      "id": "trees",
      "title": "Trees",
      "description": "Binary trees, tree traversals, and tree algorithms",
      "questions": [
        {
          "id": "tree_1",
          "title": "Maximum Depth of Binary Tree",
          "routeName": "maximum_depth_of_binary_tree",
          "difficulty": "Easy",
          "companies": ["LinkedIn", "Amazon", "Apple"],
          "tags": ["Tree", "Depth-First Search", "Breadth-First Search"],
          "description": "Find the maximum depth of a binary tree.",
          "link": ""
        },
        {
          "id": "tree_2",
          "title": "Invert Binary Tree",
          "routeName": "invert_binary_tree",
          "difficulty": "Easy",
          "companies": ["Google", "Amazon", "Facebook"],
          "tags": ["Tree", "Depth-First Search", "Breadth-First Search"],
          "description": "Invert a binary tree.",
          "link": ""
        },
        {
          "id": "tree_3",
          "title": "Binary Tree Level Order Traversal",
          "routeName": "binary_tree_level_order_traversal",
          "difficulty": "Medium",
          "companies": ["Facebook", "Amazon", "Microsoft"],
          "tags": ["Tree", "Breadth-First Search"],
          "description": "Return level order traversal of nodes' values.",
          "link": ""
        }
      ]
    },
    {
      "id": "bst",
      "title": "Binary Search Trees (BST)",
      "description": "Binary search tree operations and algorithms",
      "questions": [
        {
          "id": "bst_1",
          "title": "Validate Binary Search Tree",
          "routeName": "validate_binary_search_tree",
          "difficulty": "Medium",
          "companies": ["Amazon", "Microsoft", "Facebook"],
          "tags": ["Tree", "Depth-First Search", "Binary Search Tree"],
          "description": "Determine if a binary tree is a valid BST.",
          "link": ""
        },
        {
          "id": "bst_2",
          "title": "Lowest Common Ancestor of BST",
          "routeName": "lowest_common_ancestor_of_bst",
          "difficulty": "Easy",
          "companies": ["Amazon", "Microsoft", "Facebook"],
          "tags": ["Tree", "Depth-First Search", "Binary Search Tree"],
          "description": "Find the lowest common ancestor in a BST.",
          "link": ""
        },
        {
          "id": "bst_3",
          "title": "Kth Smallest Element in BST",
          "routeName": "kth_smallest_element_in_bst",
          "difficulty": "Medium",
          "companies": ["Google", "Amazon", "Uber"],
          "tags": ["Tree", "Depth-First Search", "Binary Search Tree"],
          "description": "Find the kth smallest element in a BST.",
          "link": ""
        }
      ]
    },
    {
      "id": "heap",
      "title": "Heap",
      "description": "Heap data structure and priority queue problems",
      "questions": [
        {
          "id": "heap_1",
          "title": "Kth Largest Element in Array",
          "routeName": "kth_largest_element_in_array",
          "difficulty": "Medium",
          "companies": ["Facebook", "Amazon", "Apple"],
          "tags": ["Array", "Divide and Conquer", "Sorting", "Heap"],
          "description": "Find the kth largest element in an unsorted array.",
          "link": ""
        },
        {
          "id": "heap_2",
          "title": "Top K Frequent Elements",
          "routeName": "top_k_frequent_elements",
          "difficulty": "Medium",
          "companies": ["Amazon", "Yelp", "Pocket Gems"],
          "tags": [
            "Array",
            "Hash Table",
            "Divide and Conquer",
            "Sorting",
            "Heap"
          ],
          "description": "Find k most frequent elements.",
          "link": ""
        },
        {
          "id": "heap_3",
          "title": "Merge k Sorted Lists",
          "routeName": "merge_k_sorted_lists",
          "difficulty": "Hard",
          "companies": ["Amazon", "Google", "Microsoft"],
          "tags": ["Linked List", "Divide and Conquer", "Heap"],
          "description": "Merge k sorted linked lists.",
          "link": ""
        }
      ]
    },
    {
      "id": "huffman-coding",
      "title": "Huffman Coding",
      "description": "Huffman coding algorithm and compression techniques",
      "questions": [
        {
          "id": "huff_1",
          "title": "Huffman Encoding",
          "routeName": "huffman_encoding",
          "difficulty": "Medium",
          "companies": ["Google", "Amazon", "Microsoft"],
          "tags": ["Greedy", "Heap", "Tree"],
          "description": "Implement Huffman encoding algorithm.",
          "link": ""
        },
        {
          "id": "huff_2",
          "title": "Huffman Decoding",
          "routeName": "huffman_decoding",
          "difficulty": "Medium",
          "companies": ["Facebook", "Netflix", "Adobe"],
          "tags": ["Tree", "Hash Table"],
          "description": "Decode a Huffman encoded string.",
          "link": ""
        }
      ]
    },
    {
      "id": "dynamic-programming",
      "title": "Dynamic Programming",
      "description": "Dynamic programming optimization and memoization",
      "questions": [
        {
          "id": "dp_1",
          "title": "Climbing Stairs",
          "routeName": "climbing_stairs",
          "difficulty": "Easy",
          "companies": ["Amazon", "Apple", "Adobe"],
          "tags": ["Math", "Dynamic Programming", "Memoization"],
          "description": "Count ways to climb n stairs taking 1 or 2 steps.",
          "link": ""
        },
        {
          "id": "dp_2",
          "title": "House Robber",
          "routeName": "house_robber",
          "difficulty": "Medium",
          "companies": ["Amazon", "Microsoft", "Goldman Sachs"],
          "tags": ["Array", "Dynamic Programming"],
          "description": "Rob houses without robbing adjacent ones.",
          "link": ""
        },
        {
          "id": "dp_3",
          "title": "Coin Change",
          "routeName": "coin_change",
          "difficulty": "Medium",
          "companies": ["Amazon", "Google", "Microsoft"],
          "tags": ["Array", "Dynamic Programming", "Breadth-First Search"],
          "description": "Find minimum coins needed to make amount.",
          "link": ""
        },
        {
          "id": "dp_4",
          "title": "Longest Increasing Subsequence",
          "routeName": "longest_increasing_subsequence",
          "difficulty": "Medium",
          "companies": ["Microsoft", "Amazon", "Google"],
          "tags": ["Array", "Binary Search", "Dynamic Programming"],
          "description": "Find length of longest increasing subsequence.",
          "link": ""
        }
      ]
    },
    {
      "id": "graphs",
      "title": "Graphs",
      "description": "Graph algorithms, BFS, DFS, and shortest path problems",
      "questions": [
        {
          "id": "graph_1",
          "title": "Number of Islands",
          "routeName": "number_of_islands",
          "difficulty": "Medium",
          "companies": ["Amazon", "Microsoft", "Facebook"],
          "tags": ["Array", "Depth-First Search", "Breadth-First Search"],
          "description": "Count the number of islands in a 2D grid.",
          "link": ""
        },
        {
          "id": "graph_2",
          "title": "Clone Graph",
          "routeName": "clone_graph",
          "difficulty": "Medium",
          "companies": ["Amazon", "Google", "Facebook"],
          "tags": ["Hash Table", "Depth-First Search", "Breadth-First Search"],
          "description": "Clone an undirected graph.",
          "link": ""
        },
        {
          "id": "graph_3",
          "title": "Course Schedule",
          "routeName": "course_schedule",
          "difficulty": "Medium",
          "companies": ["Amazon", "Microsoft", "Zenefits"],
          "tags": [
            "Depth-First Search",
            "Breadth-First Search",
            "Topological Sort"
          ],
          "description": "Determine if you can finish all courses.",
          "link": ""
        }
      ]
    },
    {
      "id": "oops-python",
      "title": "OOPs in Python",
      "description": "Object-oriented programming concepts and design patterns in Python",
      "questions": [
        {
          "id": "oop_1",
          "title": "Class Design",
          "routeName": "class_design",
          "difficulty": "Medium",
          "companies": ["Google", "Amazon", "Microsoft"],
          "tags": ["Design", "Object-Oriented Programming"],
          "description": "Design a class hierarchy for a vehicle system.",
          "link": ""
        },
        {
          "id": "oop_2",
          "title": "Inheritance and Polymorphism",
          "routeName": "inheritance_and_polymorphism",
          "difficulty": "Medium",
          "companies": ["Facebook", "Netflix", "Uber"],
          "tags": ["Design", "Object-Oriented Programming"],
          "description": "Implement inheritance and polymorphism concepts.",
          "link": ""
        },
        {
          "id": "oop_3",
          "title": "Design Patterns",
          "routeName": "design_patterns",
          "difficulty": "Hard",
          "companies": ["Amazon", "Google", "Microsoft"],
          "tags": ["Design", "Object-Oriented Programming", "Design Patterns"],
          "description": "Implement common design patterns in Python.",
          "link": ""
        }
      ]
    }
  ]
}
