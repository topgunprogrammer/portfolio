{
  "dsaTopics": [
    {
      "id": "arrays-hashing",
      "title": "Arrays & Hashing",
      "description": "Array manipulation, hash tables, and frequency counting problems",
      "questions": [
        {
          "id": "ah_1",
          "title": "Contains Duplicate",
          "routeName": "contains_duplicate",
          "difficulty": "Easy",
          "leetcodeNumber": 217,
          "companies": ["Google", "Amazon", "Microsoft", "Apple"],
          "tags": ["Array", "Hash Table", "Sorting"],
          "description": "Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.",
          "detailedDescription": "Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.\n\nExample 1:\nInput: nums = [1,2,3,1]\nOutput: true\n\nExample 2:\nInput: nums = [1,2,3,4]\nOutput: false\n\nExample 3:\nInput: nums = [1,1,1,3,3,4,3,2,4,2]\nOutput: true\n\nConstraints:\n• 1 <= nums.length <= 10^5\n• -10^9 <= nums[i] <= 10^9",
          "approach": "Multiple approaches to solve this problem:\n\n1. **Hash Set**: Add elements to a set and check if element already exists.\n\n2. **Sorting**: Sort the array and check adjacent elements.\n\n3. **Length Comparison**: Convert to set and compare lengths.\n\n4. **Brute Force**: Check every pair (not recommended for large inputs).",
          "solution": "**Approach 1: Hash Set (Most Efficient)**\nUse a set to track seen elements and return true if duplicate found.\n\n**Approach 2: Length Comparison (Most Concise)**\nConvert array to set and compare lengths.\n\n**Approach 3: Sorting**\nSort array and check adjacent elements for duplicates.",
          "code": "# Approach 1: Hash Set (Most Efficient)\ndef containsDuplicate(nums):\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False\n\n# Approach 2: Length Comparison (Most Concise)\ndef containsDuplicate(nums):\n    return len(set(nums)) != len(nums)\n\n# Approach 3: Sorting\ndef containsDuplicate(nums):\n    nums.sort()\n    for i in range(1, len(nums)):\n        if nums[i] == nums[i-1]:\n            return True\n    return False\n\n# Test cases\ntest_cases = [\n    [1,2,3,1],\n    [1,2,3,4],\n    [1,1,1,3,3,4,3,2,4,2]\n]\n\nfor nums in test_cases:\n    result = containsDuplicate(nums)\n    print(f\"Input: {nums} -> Output: {result}\")",
          "timeComplexity": "• **Hash Set**: O(n) average case, O(n) worst case\n• **Length Comparison**: O(n) for set creation\n• **Sorting**: O(n log n) for sorting",
          "spaceComplexity": "• **Hash Set**: O(n) in worst case when no duplicates\n• **Length Comparison**: O(n) for set creation\n• **Sorting**: O(1) if sorting in-place, O(n) otherwise",
          "keyInsights": "• Hash set provides optimal time complexity for duplicate detection\n• Length comparison is the most concise solution\n• Early termination in hash set approach saves time when duplicates found early\n• This pattern is fundamental for many array problems\n• Consider space-time tradeoffs when choosing approach",
          "link": "https://leetcode.com/problems/contains-duplicate/"
        },
        {
          "id": "ah_2",
          "title": "Valid Anagram",
          "routeName": "valid_anagram",
          "difficulty": "Easy",
          "leetcodeNumber": 242,
          "companies": ["Facebook", "Amazon", "Netflix", "Bloomberg"],
          "tags": ["String", "Hash Table", "Sorting"],
          "description": "Given two strings s and t, return true if t is an anagram of s, and false otherwise.",
          "detailedDescription": "An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n\nExample 1:\nInput: s = \"anagram\", t = \"nagaram\"\nOutput: true\n\nExample 2:\nInput: s = \"rat\", t = \"car\"\nOutput: false\n\nConstraints:\n• 1 <= s.length, t.length <= 5 * 10^4\n• s and t consist of lowercase English letters",
          "approach": "Several approaches to solve this problem:\n\n1. **Sorting**: Sort both strings and compare if they are equal.\n\n2. **Hash Map/Counter**: Count frequency of each character in both strings and compare.\n\n3. **Array Counting**: Use array of size 26 for lowercase letters to count frequencies.\n\n4. **Character Cancellation**: Increment count for characters in first string, decrement for second string.",
          "solution": "**Approach 1: Sorting (Most Straightforward)**\nSort both strings and check if they are identical.\n\n**Approach 2: Character Frequency Count**\nCount character frequencies and compare.\n\n**Approach 3: Single Pass Counter**\nIncrement counter for first string, decrement for second string.",
          "code": "from collections import Counter\n\n# Approach 1: Sorting (Most Common)\ndef isAnagram(s, t):\n    return sorted(s) == sorted(t)\n\n# Approach 2: Counter (Using built-in)\ndef isAnagram(s, t):\n    return Counter(s) == Counter(t)\n\n# Approach 3: Manual Character Count\ndef isAnagram(s, t):\n    if len(s) != len(t):\n        return False\n    \n    char_count = {}\n    \n    # Count characters in s\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    # Subtract characters in t\n    for char in t:\n        if char not in char_count:\n            return False\n        char_count[char] -= 1\n        if char_count[char] == 0:\n            del char_count[char]\n    \n    return len(char_count) == 0\n\n# Approach 4: Array Counting (Most Efficient for lowercase letters)\ndef isAnagram(s, t):\n    if len(s) != len(t):\n        return False\n    \n    # Array for 26 lowercase letters\n    char_count = [0] * 26\n    \n    for i in range(len(s)):\n        char_count[ord(s[i]) - ord('a')] += 1\n        char_count[ord(t[i]) - ord('a')] -= 1\n    \n    return all(count == 0 for count in char_count)\n\n# Test cases\ntest_cases = [\n    (\"anagram\", \"nagaram\"),\n    (\"rat\", \"car\"),\n    (\"listen\", \"silent\")\n]\n\nfor s, t in test_cases:\n    result = isAnagram(s, t)\n    print(f\"'{s}' and '{t}': {result}\")",
          "timeComplexity": "• **Sorting**: O(n log n) where n is the length of the strings\n• **Counter/Hash Map**: O(n) to iterate through both strings\n• **Array Counting**: O(n) with better constants than hash map",
          "spaceComplexity": "• **Sorting**: O(1) if sorting in-place, O(n) otherwise\n• **Hash Map**: O(n) for storing character counts\n• **Array Counting**: O(1) since array size is fixed (26)",
          "keyInsights": "• Anagram problems involve character frequency analysis\n• Sorting provides simple but not most efficient solution\n• Array counting is most efficient for limited character sets\n• Early length check can save computation\n• This pattern applies to grouping anagrams and string permutation problems",
          "link": "https://leetcode.com/problems/valid-anagram/"
        },
        {
          "id": "ah_3",
          "title": "Two Sum",
          "routeName": "two_sum",
          "difficulty": "Easy",
          "leetcodeNumber": 1,
          "companies": ["Google", "Amazon", "Apple", "Microsoft", "Facebook"],
          "tags": ["Array", "Hash Table"],
          "description": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.",
          "detailedDescription": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\nYou can return the answer in any order.\n\nExample 1:\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n\nExample 2:\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\n\nExample 3:\nInput: nums = [3,3], target = 6\nOutput: [0,1]\n\nConstraints:\n• 2 <= nums.length <= 10^4\n• -10^9 <= nums[i] <= 10^9\n• -10^9 <= target <= 10^9\n• Only one valid answer exists",
          "approach": "Multiple approaches to solve this problem:\n\n1. **Hash Map (One Pass)**: Store complement and index as we iterate.\n\n2. **Hash Map (Two Pass)**: First pass to build hash map, second pass to find complement.\n\n3. **Brute Force**: Check all pairs (not recommended for large inputs).\n\n4. **Two Pointers**: Sort array first, then use two pointers (loses original indices).",
          "solution": "**Approach 1: Hash Map One Pass (Optimal)**\nUse hash map to store seen numbers and their indices, check for complement.\n\n**Approach 2: Brute Force**\nCheck all possible pairs until target sum is found.\n\n**Key Insight**: We need to find complement (target - current_number) in the array.",
          "code": "# Approach 1: Hash Map (One Pass) - Optimal\ndef twoSum(nums, target):\n    hashmap = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in hashmap:\n            return [hashmap[complement], i]\n        hashmap[num] = i\n    return []  # Should never reach here given constraints\n\n# Approach 2: Hash Map (Two Pass)\ndef twoSum(nums, target):\n    hashmap = {num: i for i, num in enumerate(nums)}\n    \n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in hashmap and hashmap[complement] != i:\n            return [i, hashmap[complement]]\n    return []\n\n# Approach 3: Brute Force\ndef twoSum(nums, target):\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[i] + nums[j] == target:\n                return [i, j]\n    return []\n\n# Test cases\ntest_cases = [\n    ([2, 7, 11, 15], 9),\n    ([3, 2, 4], 6),\n    ([3, 3], 6)\n]\n\nfor nums, target in test_cases:\n    result = twoSum(nums, target)\n    print(f\"nums: {nums}, target: {target} -> indices: {result}\")",
          "timeComplexity": "• **Hash Map**: O(n) single pass through the array\n• **Brute Force**: O(n²) checking all pairs",
          "spaceComplexity": "• **Hash Map**: O(n) for storing up to n elements\n• **Brute Force**: O(1) only using variables",
          "keyInsights": "• Hash map trades space for time to achieve O(n) solution\n• The key insight is looking for complement (target - current)\n• One-pass solution is more efficient than two-pass\n• This pattern applies to many sum-based problems\n• Consider edge cases like duplicate numbers",
          "link": "https://leetcode.com/problems/two-sum/"
        },
        {
          "id": "ah_4",
          "title": "Group Anagrams",
          "routeName": "group_anagrams",
          "difficulty": "Medium",
          "leetcodeNumber": 49,
          "companies": ["Amazon", "Facebook", "Google", "Bloomberg"],
          "tags": ["Array", "Hash Table", "String", "Sorting"],
          "description": "Given an array of strings strs, group the anagrams together. You can return the answer in any order.",
          "detailedDescription": "Given an array of strings strs, group the anagrams together. You can return the answer in any order.\n\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n\nExample 1:\nInput: strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\nOutput: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\n\nExample 2:\nInput: strs = [\"\"]\nOutput: [[\"\"]]\n\nExample 3:\nInput: strs = [\"a\"]\nOutput: [[\"a\"]]\n\nConstraints:\n• 1 <= strs.length <= 10^4\n• 0 <= strs[i].length <= 100\n• strs[i] consists of lowercase English letters",
          "approach": "Several approaches to solve this problem:\n\n1. **Sorting Key**: Use sorted string as key in hash map.\n\n2. **Character Count Key**: Use character frequency tuple as key.\n\n3. **Prime Number Encoding**: Assign prime numbers to each character (mathematical approach).",
          "solution": "**Approach 1: Sorting as Key**\nGroup strings by their sorted version as the key.\n\n**Approach 2: Character Count as Key**\nUse character frequency as the grouping key.\n\n**Key Insight**: Anagrams have the same characters with same frequencies.",
          "code": "from collections import defaultdict\n\n# Approach 1: Sorting as Key (Most Common)\ndef groupAnagrams(strs):\n    anagram_groups = defaultdict(list)\n    \n    for s in strs:\n        # Use sorted string as key\n        key = tuple(sorted(s))\n        anagram_groups[key].append(s)\n    \n    return list(anagram_groups.values())\n\n# Approach 2: Character Count as Key\ndef groupAnagrams(strs):\n    anagram_groups = defaultdict(list)\n    \n    for s in strs:\n        # Count characters and use as key\n        char_count = [0] * 26\n        for char in s:\n            char_count[ord(char) - ord('a')] += 1\n        \n        key = tuple(char_count)\n        anagram_groups[key].append(s)\n    \n    return list(anagram_groups.values())\n\n# Approach 3: Using Counter (Alternative)\nfrom collections import Counter, defaultdict\n\ndef groupAnagrams(strs):\n    anagram_groups = defaultdict(list)\n    \n    for s in strs:\n        # Use character frequency as key\n        key = tuple(sorted(Counter(s).items()))\n        anagram_groups[key].append(s)\n    \n    return list(anagram_groups.values())\n\n# Most concise version\ndef groupAnagrams(strs):\n    groups = defaultdict(list)\n    for s in strs:\n        groups[tuple(sorted(s))].append(s)\n    return list(groups.values())\n\n# Test cases\ntest_cases = [\n    [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"],\n    [\"\"],\n    [\"a\"]\n]\n\nfor strs in test_cases:\n    result = groupAnagrams(strs)\n    print(f\"Input: {strs}\")\n    print(f\"Output: {result}\\n\")",
          "timeComplexity": "• **Sorting approach**: O(n * m log m) where n is number of strings and m is average string length\n• **Character count approach**: O(n * m) where n is number of strings and m is average string length",
          "spaceComplexity": "• Both approaches: O(n * m) for storing all strings in hash map groups",
          "keyInsights": "• Hash map with computed keys is perfect for grouping problems\n• Sorted string serves as canonical representation of anagram group\n• Character count array can be more efficient than sorting for long strings\n• defaultdict simplifies group creation logic\n• This pattern applies to any grouping problem with equivalence relation",
          "link": "https://leetcode.com/problems/group-anagrams/"
        },
        {
          "id": "ah_5",
          "title": "Top K Frequent Elements",
          "routeName": "top_k_frequent_elements",
          "difficulty": "Medium",
          "leetcodeNumber": 347,
          "companies": ["Amazon", "Google", "Facebook", "Yelp"],
          "tags": [
            "Array",
            "Hash Table",
            "Divide and Conquer",
            "Sorting",
            "Heap",
            "Bucket Sort",
            "Counting",
            "Quickselect"
          ],
          "description": "Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.",
          "detailedDescription": "Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.\n\nExample 1:\nInput: nums = [1,1,1,2,2,3], k = 2\nOutput: [1,2]\n\nExample 2:\nInput: nums = [1], k = 1\nOutput: [1]\n\nConstraints:\n• 1 <= nums.length <= 10^5\n• k is in the range [1, the number of unique elements in the array]\n• It is guaranteed that the answer is unique\n\nFollow up: Your algorithm's time complexity must be better than O(n log n), where n is the array's size.",
          "approach": "Several approaches to solve this problem:\n\n1. **Heap**: Use min-heap of size k to track top k frequent elements.\n\n2. **Bucket Sort**: Use frequency as bucket index for O(n) solution.\n\n3. **Sorting**: Count frequencies then sort by frequency.\n\n4. **Quick Select**: Use quick select on frequency array.",
          "solution": "**Approach 1: Min Heap (Most Common)**\nUse Counter to get frequencies, then heap to get top k.\n\n**Approach 2: Bucket Sort (Optimal)**\nUse frequency as bucket index for linear time solution.\n\n**Approach 3: Sorting (Simple but not optimal)**\nSort by frequency and take top k.",
          "code": "import heapq\nfrom collections import Counter\n\n# Approach 1: Heap (Most Common Solution)\ndef topKFrequent(nums, k):\n    # Count frequencies\n    count = Counter(nums)\n    \n    # Use heap to get k most frequent\n    return heapq.nlargest(k, count.keys(), key=count.get)\n\n# Approach 2: Bucket Sort (Optimal O(n))\ndef topKFrequent(nums, k):\n    count = Counter(nums)\n    \n    # Create buckets for each possible frequency\n    buckets = [[] for _ in range(len(nums) + 1)]\n    \n    # Put elements in buckets based on frequency\n    for num, freq in count.items():\n        buckets[freq].append(num)\n    \n    # Collect top k elements from highest frequency buckets\n    result = []\n    for i in range(len(buckets) - 1, 0, -1):\n        for num in buckets[i]:\n            result.append(num)\n            if len(result) == k:\n                return result\n    \n    return result\n\n# Approach 3: Sorting\ndef topKFrequent(nums, k):\n    count = Counter(nums)\n    \n    # Sort by frequency in descending order\n    sorted_items = sorted(count.items(), key=lambda x: x[1], reverse=True)\n    \n    # Return top k elements\n    return [item[0] for item in sorted_items[:k]]\n\n# Approach 4: Min Heap (Manual Implementation)\ndef topKFrequent(nums, k):\n    count = Counter(nums)\n    \n    heap = []\n    for num, freq in count.items():\n        heapq.heappush(heap, (freq, num))\n        if len(heap) > k:\n            heapq.heappop(heap)\n    \n    return [num for freq, num in heap]\n\n# Test cases\ntest_cases = [\n    ([1,1,1,2,2,3], 2),\n    ([1], 1),\n    ([1,2,3,4,5], 3)\n]\n\nfor nums, k in test_cases:\n    result = topKFrequent(nums, k)\n    print(f\"nums: {nums}, k: {k} -> result: {result}\")",
          "timeComplexity": "• **Heap**: O(n log k) where n is array length\n• **Bucket Sort**: O(n) linear time\n• **Sorting**: O(n log n) for sorting frequencies\n• **Quick Select**: O(n) average case",
          "spaceComplexity": "• All approaches: O(n) for frequency counting and result storage",
          "keyInsights": "• Counter is essential for frequency-based problems\n• Heap provides good balance between time and space complexity\n• Bucket sort achieves optimal O(n) time when frequency range is limited\n• The follow-up constraint eliminates simple sorting solutions\n• This pattern applies to \"top k\" problems with frequency requirements",
          "link": "https://leetcode.com/problems/top-k-frequent-elements/"
        },
        {
          "id": "ah_6",
          "title": "Product of Array Except Self",
          "routeName": "product_of_array_except_self",
          "difficulty": "Medium",
          "leetcodeNumber": 238,
          "companies": ["Amazon", "Apple", "Facebook", "Microsoft"],
          "tags": ["Array", "Prefix Sum"],
          "description": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].",
          "detailedDescription": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].\n\nThe algorithm must run in O(n) time and without using the division operation.\n\nExample 1:\nInput: nums = [1,2,3,4]\nOutput: [24,12,8,6]\n\nExample 2:\nInput: nums = [-1,1,0,-3,3]\nOutput: [0,0,9,0,0]\n\nConstraints:\n• 2 <= nums.length <= 10^5\n• -30 <= nums[i] <= 30\n• The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer\n\nFollow up: Can you solve the problem in O(1) extra space complexity?",
          "approach": "Several approaches to solve this problem:\n\n1. **Left and Right Arrays**: Create separate arrays for left and right products.\n\n2. **Single Array with Two Passes**: Use output array to store left products, then multiply with right products.\n\n3. **Division Method**: Calculate total product and divide (not allowed in constraints).\n\n4. **Optimized Space**: Use the output array itself to store intermediate results.",
          "solution": "**Approach 1: Two Arrays (Conceptually Clear)**\nCreate left and right product arrays, then multiply corresponding elements.\n\n**Approach 2: Single Array Two Passes (Space Optimized)**\nUse output array for left products first, then multiply with right products in second pass.\n\n**Key Insight**: Product except self = (product of all left elements) × (product of all right elements).",
          "code": "# Approach 1: Left and Right Arrays (Conceptual)\ndef productExceptSelf(nums):\n    n = len(nums)\n    \n    # Calculate left products\n    left = [1] * n\n    for i in range(1, n):\n        left[i] = left[i-1] * nums[i-1]\n    \n    # Calculate right products\n    right = [1] * n\n    for i in range(n-2, -1, -1):\n        right[i] = right[i+1] * nums[i+1]\n    \n    # Multiply left and right products\n    result = []\n    for i in range(n):\n        result.append(left[i] * right[i])\n    \n    return result\n\n# Approach 2: Optimized Single Array (Most Efficient)\ndef productExceptSelf(nums):\n    n = len(nums)\n    output = [1] * n\n    \n    # First pass: calculate left products\n    prefix = 1\n    for i in range(n):\n        output[i] = prefix\n        prefix *= nums[i]\n    \n    # Second pass: multiply with right products\n    postfix = 1\n    for i in range(n-1, -1, -1):\n        output[i] *= postfix\n        postfix *= nums[i]\n    \n    return output\n\n# Approach 3: More Readable Version\ndef productExceptSelf(nums):\n    n = len(nums)\n    result = [1] * n\n    \n    # Fill result with left products\n    for i in range(1, n):\n        result[i] = result[i-1] * nums[i-1]\n    \n    # Multiply with right products\n    right_product = 1\n    for i in range(n-1, -1, -1):\n        result[i] *= right_product\n        right_product *= nums[i]\n    \n    return result\n\n# Test cases\ntest_cases = [\n    [1,2,3,4],\n    [-1,1,0,-3,3],\n    [2,3,4,5]\n]\n\nfor nums in test_cases:\n    result = productExceptSelf(nums)\n    print(f\"Input: {nums}\")\n    print(f\"Output: {result}\\n\")",
          "timeComplexity": "O(n) - Two passes through the array, each taking O(n) time",
          "spaceComplexity": "O(1) extra space (not counting the output array which is required by the problem)",
          "keyInsights": "• The key insight is that product except self = left_product × right_product\n• Two-pass approach avoids division operation requirement\n• Using output array for intermediate storage achieves O(1) extra space\n• Prefix and postfix product patterns are common in array problems\n• This technique applies to many \"except self\" type problems",
          "link": "https://leetcode.com/problems/product-of-array-except-self/"
        },
        {
          "id": "ah_7",
          "title": "Valid Sudoku",
          "routeName": "valid_sudoku",
          "difficulty": "Medium",
          "leetcodeNumber": 36,
          "companies": ["Apple", "Amazon", "Google", "Microsoft"],
          "tags": ["Array", "Hash Table", "Matrix"],
          "description": "Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules.",
          "detailedDescription": "Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:\n\n1. Each row must contain the digits 1-9 without repetition.\n2. Each column must contain the digits 1-9 without repetition.\n3. Each of the nine 3 x 3 sub-boxes must contain the digits 1-9 without repetition.\n\nNote:\n• A Sudoku board (partially filled) could be valid but is not necessarily solvable.\n• Only the filled cells need to be validated according to the mentioned rules.\n\nExample 1:\nInput: board = \n[[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],\n [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],\n [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],\n [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],\n [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],\n [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],\n [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],\n [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],\n [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\nOutput: true\n\nConstraints:\n• board.length == 9\n• board[i].length == 9\n• board[i][j] is a digit 1-9 or '.'",
          "approach": "Several approaches to solve this problem:\n\n1. **Three Separate Checks**: Check rows, columns, and 3x3 boxes separately.\n\n2. **Single Pass with Sets**: Use sets to track seen numbers in one pass.\n\n3. **Hash Map Tracking**: Use hash maps to track numbers in rows, columns, and boxes.\n\n4. **Bit Manipulation**: Use bit masks to track seen numbers (advanced).",
          "solution": "**Approach 1: Single Pass with Sets (Most Efficient)**\nUse sets to track seen numbers in rows, columns, and 3x3 boxes in one pass.\n\n**Approach 2: Three Separate Checks (More Readable)**\nCheck each constraint separately with helper functions.\n\n**Key Insight**: For 3x3 boxes, use (row//3, col//3) to identify which box a cell belongs to.",
          "code": "# Approach 1: Single Pass with Sets (Most Efficient)\ndef isValidSudoku(board):\n    rows = [set() for _ in range(9)]\n    cols = [set() for _ in range(9)]\n    boxes = [set() for _ in range(9)]\n    \n    for i in range(9):\n        for j in range(9):\n            val = board[i][j]\n            if val == '.':\n                continue\n            \n            # Calculate box index\n            box_index = (i // 3) * 3 + j // 3\n            \n            # Check if val already exists in row, col, or box\n            if val in rows[i] or val in cols[j] or val in boxes[box_index]:\n                return False\n            \n            # Add val to respective sets\n            rows[i].add(val)\n            cols[j].add(val)\n            boxes[box_index].add(val)\n    \n    return True\n\n# Approach 2: Three Separate Checks (More Readable)\ndef isValidSudoku(board):\n    def is_valid_group(group):\n        group = [val for val in group if val != '.']\n        return len(group) == len(set(group))\n    \n    # Check rows\n    for row in board:\n        if not is_valid_group(row):\n            return False\n    \n    # Check columns\n    for col in range(9):\n        column = [board[row][col] for row in range(9)]\n        if not is_valid_group(column):\n            return False\n    \n    # Check 3x3 boxes\n    for box_row in range(0, 9, 3):\n        for box_col in range(0, 9, 3):\n            box = []\n            for i in range(box_row, box_row + 3):\n                for j in range(box_col, box_col + 3):\n                    box.append(board[i][j])\n            if not is_valid_group(box):\n                return False\n    \n    return True\n\n# Approach 3: Using defaultdict for cleaner code\nfrom collections import defaultdict\n\ndef isValidSudoku(board):\n    rows = defaultdict(set)\n    cols = defaultdict(set)\n    boxes = defaultdict(set)\n    \n    for i in range(9):\n        for j in range(9):\n            val = board[i][j]\n            if val == '.':\n                continue\n            \n            box_id = (i // 3, j // 3)\n            \n            if val in rows[i] or val in cols[j] or val in boxes[box_id]:\n                return False\n            \n            rows[i].add(val)\n            cols[j].add(val)\n            boxes[box_id].add(val)\n    \n    return True\n\n# Test case\nboard = [\n    [\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],\n    [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],\n    [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],\n    [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],\n    [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],\n    [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],\n    [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],\n    [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],\n    [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]\n]\n\nresult = isValidSudoku(board)\nprint(f\"Is valid Sudoku: {result}\")",
          "timeComplexity": "O(1) - Since the board is always 9x9, we iterate through a constant 81 cells",
          "spaceComplexity": "O(1) - We use a constant amount of extra space (9 sets for rows, 9 for columns, 9 for boxes)",
          "keyInsights": "• Single pass with sets is more efficient than multiple separate checks\n• Box index calculation: (row//3) * 3 + col//3 maps 2D position to box number\n• Using sets for duplicate detection is the most natural approach\n• Sudoku validation is a classic application of constraint checking\n• This pattern applies to other grid-based constraint satisfaction problems",
          "link": "https://leetcode.com/problems/valid-sudoku/"
        },
        {
          "id": "ah_8",
          "title": "Encode and Decode Strings",
          "routeName": "encode_and_decode_strings",
          "difficulty": "Medium",
          "leetcodeNumber": 271,
          "companies": ["Google", "Facebook", "Amazon", "Microsoft"],
          "tags": ["Array", "String", "Design"],
          "description": "Design an algorithm to encode a list of strings to a string and decode it back.",
          "detailedDescription": "Design an algorithm to encode a list of strings to a string and decode it back.\n\nThe machine does not know the size of each individual string nor the overall size of the list of strings.\n\nNote: The string may contain any possible characters out of 256 valid ASCII characters. Your algorithm should be generalized enough to work on any possible characters.\n\nExample 1:\nInput: dummy_input = [\"Hello\",\"World\"]\nOutput: [\"Hello\",\"World\"]\nExplanation:\nMachine 1:\nCodec encoder = new Codec();\nString msg = encoder.encode(strs);\nMachine 1 ---msg---> Machine 2\n\nMachine 2:\nCodec decoder = new Codec();\nList<String> strs = decoder.decode(msg);\n\nExample 2:\nInput: dummy_input = [\"\"]\nOutput: [\"\"]\n\nConstraints:\n• 1 <= strs.length <= 200\n• 0 <= strs[i].length <= 200\n• strs[i] contains any possible characters out of 256 valid ASCII characters",
          "approach": "Several approaches to solve this problem:\n\n1. **Length Prefix**: Prefix each string with its length and a delimiter.\n\n2. **Escape Character**: Use escape sequences for special characters.\n\n3. **Fixed-Length Headers**: Use fixed-width length headers.\n\n4. **Base64 Encoding**: Encode strings to avoid delimiter conflicts.",
          "solution": "**Approach 1: Length Prefix (Most Robust)**\nPrefix each string with 'length:' to avoid delimiter conflicts.\n\n**Approach 2: Escape Character**\nUse escape sequences but can be complex with multiple special characters.\n\n**Key Insight**: Need to handle any possible character including delimiters used in encoding.",
          "code": "# Approach 1: Length Prefix (Most Common and Robust)\nclass Codec:\n    def encode(self, strs):\n        \"\"\"Encodes a list of strings to a single string.\"\"\"\n        encoded = \"\"\n        for s in strs:\n            # Format: \"length:string\"\n            encoded += str(len(s)) + \":\" + s\n        return encoded\n    \n    def decode(self, s):\n        \"\"\"Decodes a single string to a list of strings.\"\"\"\n        decoded = []\n        i = 0\n        \n        while i < len(s):\n            # Find the colon that separates length from string\n            colon_index = s.find(':', i)\n            \n            # Extract length\n            length = int(s[i:colon_index])\n            \n            # Extract string of that length\n            start = colon_index + 1\n            string = s[start:start + length]\n            decoded.append(string)\n            \n            # Move to next string\n            i = start + length\n        \n        return decoded\n\n# Approach 2: More Explicit Length Prefix\nclass Codec2:\n    def encode(self, strs):\n        encoded = \"\"\n        for s in strs:\n            # Use # as delimiter after length\n            encoded += str(len(s)) + \"#\" + s\n        return encoded\n    \n    def decode(self, s):\n        decoded = []\n        i = 0\n        \n        while i < len(s):\n            # Find delimiter\n            delimiter_index = s.find('#', i)\n            \n            # Extract length\n            length = int(s[i:delimiter_index])\n            \n            # Extract string\n            start = delimiter_index + 1\n            string = s[start:start + length]\n            decoded.append(string)\n            \n            # Move pointer\n            i = start + length\n        \n        return decoded\n\n# Approach 3: Using join/split with escape (Less Robust)\nclass Codec3:\n    def encode(self, strs):\n        # Replace delimiter in strings and join\n        return '|'.join(s.replace('|', '||') for s in strs)\n    \n    def decode(self, s):\n        # This approach has edge cases and is not recommended\n        # for production use due to complexity in handling escapes\n        decoded = []\n        current = \"\"\n        i = 0\n        \n        while i < len(s):\n            if s[i] == '|':\n                if i + 1 < len(s) and s[i + 1] == '|':\n                    current += '|'\n                    i += 2\n                else:\n                    decoded.append(current)\n                    current = \"\"\n                    i += 1\n            else:\n                current += s[i]\n                i += 1\n        \n        decoded.append(current)\n        return decoded\n\n# Test the codec\ncodec = Codec()\n\ntest_cases = [\n    [\"Hello\", \"World\"],\n    [\"\"],\n    [\"a\", \"b\", \"c\"],\n    [\"Hello:World\", \"Test#String\"],\n    [\"\"]\n]\n\nfor strs in test_cases:\n    encoded = codec.encode(strs)\n    decoded = codec.decode(encoded)\n    print(f\"Original: {strs}\")\n    print(f\"Encoded: {repr(encoded)}\")\n    print(f\"Decoded: {decoded}\")\n    print(f\"Success: {strs == decoded}\\n\")",
          "timeComplexity": "• **Encode**: O(n) where n is total length of all strings\n• **Decode**: O(n) for parsing the encoded string",
          "spaceComplexity": "O(n) for storing the encoded string and decoded list",
          "keyInsights": "• Length prefix approach handles any character including potential delimiters\n• Avoid using characters from input as delimiters to prevent conflicts\n• The colon approach is elegant because we know the format: length:content\n• This pattern is used in network protocols and serialization\n• Consider edge cases like empty strings and strings containing delimiter characters",
          "link": "https://leetcode.com/problems/encode-and-decode-strings/"
        },
        {
          "id": "ah_9",
          "title": "Longest Consecutive Sequence",
          "routeName": "longest_consecutive_sequence",
          "difficulty": "Medium",
          "leetcodeNumber": 128,
          "companies": ["Google", "Facebook", "Amazon", "Bloomberg"],
          "tags": ["Array", "Hash Table", "Union Find"],
          "description": "Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.",
          "detailedDescription": "Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.\n\nYou must write an algorithm that runs in O(n) time.\n\nExample 1:\nInput: nums = [100,4,200,1,3,2]\nOutput: 4\nExplanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.\n\nExample 2:\nInput: nums = [0,3,7,2,5,8,4,6,0,1]\nOutput: 9\n\nConstraints:\n• 0 <= nums.length <= 10^5\n• -10^9 <= nums[i] <= 10^9",
          "approach": "Several approaches to solve this problem:\n\n1. **Hash Set**: Convert to set and check for sequence starts.\n\n2. **Sorting**: Sort array and find longest consecutive sequence (O(n log n)).\n\n3. **Union Find**: Use union-find data structure.\n\n4. **Hash Map**: Track sequence lengths dynamically.",
          "solution": "**Approach 1: Hash Set with Sequence Start Detection (Optimal)**\nUse set for O(1) lookup and only start counting from sequence beginnings.\n\n**Approach 2: Sorting (Simple but not O(n))**\nSort array and iterate to find longest consecutive sequence.\n\n**Key Insight**: Only start counting from the beginning of a sequence (when num-1 is not in set).",
          "code": "# Approach 1: Hash Set (Optimal O(n))\ndef longestConsecutive(nums):\n    if not nums:\n        return 0\n    \n    num_set = set(nums)\n    longest_streak = 0\n    \n    for num in num_set:\n        # Check if this is the start of a sequence\n        if num - 1 not in num_set:\n            current_num = num\n            current_streak = 1\n            \n            # Count consecutive numbers\n            while current_num + 1 in num_set:\n                current_num += 1\n                current_streak += 1\n            \n            # Update longest streak\n            longest_streak = max(longest_streak, current_streak)\n    \n    return longest_streak\n\n# Approach 2: Sorting (O(n log n))\ndef longestConsecutive(nums):\n    if not nums:\n        return 0\n    \n    nums.sort()\n    longest_streak = 1\n    current_streak = 1\n    \n    for i in range(1, len(nums)):\n        # Skip duplicates\n        if nums[i] == nums[i-1]:\n            continue\n        \n        if nums[i] == nums[i-1] + 1:\n            current_streak += 1\n        else:\n            longest_streak = max(longest_streak, current_streak)\n            current_streak = 1\n    \n    return max(longest_streak, current_streak)\n\n# Approach 3: Hash Map (Dynamic Programming style)\ndef longestConsecutive(nums):\n    if not nums:\n        return 0\n    \n    num_to_length = {}\n    max_length = 0\n    \n    for num in nums:\n        if num in num_to_length:\n            continue\n        \n        # Get lengths of adjacent sequences\n        left_length = num_to_length.get(num - 1, 0)\n        right_length = num_to_length.get(num + 1, 0)\n        \n        # Calculate new sequence length\n        new_length = left_length + right_length + 1\n        \n        # Update the map\n        num_to_length[num] = new_length\n        \n        # Update endpoints of the sequence\n        num_to_length[num - left_length] = new_length\n        num_to_length[num + right_length] = new_length\n        \n        max_length = max(max_length, new_length)\n    \n    return max_length\n\n# Most concise version\ndef longestConsecutive(nums):\n    num_set = set(nums)\n    longest = 0\n    \n    for num in num_set:\n        if num - 1 not in num_set:  # Start of sequence\n            length = 1\n            while num + length in num_set:\n                length += 1\n            longest = max(longest, length)\n    \n    return longest\n\n# Test cases\ntest_cases = [\n    [100,4,200,1,3,2],\n    [0,3,7,2,5,8,4,6,0,1],\n    [1,2,0,1],\n    [],\n    [1]\n]\n\nfor nums in test_cases:\n    result = longestConsecutive(nums)\n    print(f\"Input: {nums}\")\n    print(f\"Longest consecutive sequence length: {result}\\n\")",
          "timeComplexity": "• **Hash Set**: O(n) - Each number is visited at most twice\n• **Sorting**: O(n log n) for sorting\n• **Hash Map**: O(n) average case",
          "spaceComplexity": "• **Hash Set**: O(n) for storing all numbers\n• **Sorting**: O(1) if sorting in-place\n• **Hash Map**: O(n) for the map",
          "keyInsights": "• The key optimization is only starting sequence counting from sequence beginnings\n• Converting to set enables O(1) lookup which is crucial for O(n) solution\n• Checking 'num - 1 not in set' ensures we don't double-count sequences\n• This problem demonstrates the power of hash sets for sequence problems\n• The pattern of 'finding sequence starts' applies to many consecutive element problems",
          "link": "https://leetcode.com/problems/longest-consecutive-sequence/"
        }
      ]
    },
    {
      "id": "two-pointers",
      "title": "Two Pointers",
      "description": "Two pointer technique for array and string problems",
      "questions": [
        {
          "id": "tp_1",
          "title": "Valid Palindrome",
          "routeName": "valid_palindrome",
          "difficulty": "Easy",
          "leetcodeNumber": 125,
          "companies": ["Facebook", "Microsoft", "Apple", "Amazon"],
          "tags": ["String", "Two Pointers"],
          "description": "A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward.",
          "detailedDescription": "A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.\n\nGiven a string s, return true if it is a palindrome, or false otherwise.\n\nExample 1:\nInput: s = \"A man, a plan, a canal: Panama\"\nOutput: true\nExplanation: \"amanaplanacanalpanama\" is a palindrome.\n\nExample 2:\nInput: s = \"race a car\"\nOutput: false\nExplanation: \"raceacar\" is not a palindrome.\n\nExample 3:\nInput: s = \" \"\nOutput: true\nExplanation: s is an empty string \"\" after removing non-alphanumeric characters.\n\nConstraints:\n• 1 <= s.length <= 2 * 10^5\n• s consists only of printable ASCII characters",
          "approach": "Multiple approaches to solve this problem:\n\n1. **Two Pointers with On-the-fly Cleaning**: Skip non-alphanumeric characters while comparing.\n\n2. **Two Pointers with Preprocessing**: Clean the string first, then use two pointers.\n\n3. **Reverse and Compare**: Clean the string, reverse it, and compare with original.\n\n4. **Recursive**: Clean the string and use recursion to check palindrome property.",
          "solution": "**Approach 1: Two Pointers with On-the-fly Processing (Optimal)**\nUse two pointers and skip invalid characters during comparison.\n\n**Approach 2: Two Pointers with Preprocessing**\nFirst clean the string by removing non-alphanumeric characters and converting to lowercase.\n\n**Key Insight**: Two pointers technique allows us to check palindrome in O(1) extra space.",
          "code": "# Approach 1: Two Pointers with On-the-fly Processing (Most Efficient)\ndef isPalindrome(s):\n    left, right = 0, len(s) - 1\n    \n    while left < right:\n        # Skip non-alphanumeric characters from left\n        while left < right and not s[left].isalnum():\n            left += 1\n        \n        # Skip non-alphanumeric characters from right\n        while left < right and not s[right].isalnum():\n            right -= 1\n        \n        # Compare characters (case-insensitive)\n        if s[left].lower() != s[right].lower():\n            return False\n        \n        left += 1\n        right -= 1\n    \n    return True\n\n# Approach 2: Two Pointers with Preprocessing\ndef isPalindrome(s):\n    # Clean the string: keep only alphanumeric and convert to lowercase\n    cleaned = ''.join(char.lower() for char in s if char.isalnum())\n    \n    # Two pointers approach\n    left, right = 0, len(cleaned) - 1\n    \n    while left < right:\n        if cleaned[left] != cleaned[right]:\n            return False\n        left += 1\n        right -= 1\n    \n    return True\n\n# Approach 3: Using Regular Expressions\nimport re\n\ndef isPalindrome(s):\n    # Remove non-alphanumeric characters and convert to lowercase\n    cleaned = re.sub(r'[^a-zA-Z0-9]', '', s).lower()\n    return cleaned == cleaned[::-1]\n\n# Approach 4: Functional Programming Style\ndef isPalindrome(s):\n    chars = [char.lower() for char in s if char.isalnum()]\n    return chars == chars[::-1]\n\n# Test cases\ntest_cases = [\n    \"A man, a plan, a canal: Panama\",\n    \"race a car\",\n    \" \",\n    \"Madam\",\n    \"No 'x' in Nixon\"\n]\n\nfor test in test_cases:\n    result = isPalindrome(test)\n    print(f\"'{test}' -> {result}\")",
          "timeComplexity": "• **On-the-fly approach**: O(n) single pass through the string\n• **Preprocessing approach**: O(n) for cleaning + O(n) for checking = O(n)\n• **Regex approach**: O(n) for regex processing + O(n) for comparison = O(n)",
          "spaceComplexity": "• **On-the-fly approach**: O(1) only using two pointers\n• **Preprocessing approach**: O(n) for storing the cleaned string\n• **Regex approach**: O(n) for storing cleaned string\n• **Functional approach**: O(n) for storing the character list",
          "keyInsights": "• Two pointers technique is ideal for palindrome problems\n• On-the-fly processing saves memory by avoiding string preprocessing\n• Case-insensitive comparison requires careful handling\n• The pattern of skipping invalid characters while maintaining two pointers is reusable\n• Consider memory constraints when choosing between preprocessing vs on-the-fly approaches",
          "link": "https://leetcode.com/problems/valid-palindrome/"
        },
        {
          "id": "tp_2",
          "title": "Two Sum II - Input Array Is Sorted",
          "routeName": "two_sum_ii_input_array_is_sorted",
          "difficulty": "Medium",
          "leetcodeNumber": 167,
          "companies": ["Amazon", "Google", "Microsoft", "Facebook"],
          "tags": ["Array", "Two Pointers", "Binary Search"],
          "description": "Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number.",
          "detailedDescription": "Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 <= index1 < index2 <= numbers.length.\n\nReturn the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2.\n\nThe tests are generated such that there is exactly one solution. You may not use the same element twice.\n\nYour solution must use only constant extra space.\n\nExample 1:\nInput: numbers = [2,7,11,15], target = 9\nOutput: [1,2]\nExplanation: The sum of 2 and 7 is 9. Therefore, index1 = 1, index2 = 2. We return [1, 2].\n\nExample 2:\nInput: numbers = [2,3,4], target = 6\nOutput: [1,3]\nExplanation: The sum of 2 and 4 is 6. Therefore, index1 = 1, index2 = 3. We return [1, 3].\n\nExample 3:\nInput: numbers = [-1,0], target = -1\nOutput: [1,2]\nExplanation: The sum of -1 and 0 is -1. Therefore, index1 = 1, index2 = 2. We return [1, 2].\n\nConstraints:\n• 2 <= numbers.length <= 3 * 10^4\n• -1000 <= numbers[i] <= 1000\n• numbers is sorted in non-decreasing order\n• -1000 <= target <= 1000\n• The tests are generated such that there is exactly one solution",
          "approach": "Multiple approaches to solve this problem:\n\n1. **Two Pointers**: Use left and right pointers, move based on sum comparison with target.\n\n2. **Binary Search**: For each element, binary search for the complement.\n\n3. **Hash Map**: Store elements in hash map (but violates O(1) space constraint).\n\n4. **Brute Force**: Check all pairs (not efficient for large inputs).",
          "solution": "**Approach 1: Two Pointers (Optimal)**\nLeverage the sorted property with two pointers from both ends.\n\n**Approach 2: Binary Search**\nFor each element, binary search for target - element.\n\n**Key Insight**: Sorted array allows us to use two pointers technique efficiently.",
          "code": "# Approach 1: Two Pointers (Optimal)\ndef twoSum(numbers, target):\n    left, right = 0, len(numbers) - 1\n    \n    while left < right:\n        current_sum = numbers[left] + numbers[right]\n        \n        if current_sum == target:\n            return [left + 1, right + 1]  # Convert to 1-indexed\n        elif current_sum < target:\n            left += 1  # Need larger sum\n        else:\n            right -= 1  # Need smaller sum\n    \n    return []  # Should never reach here given constraints\n\n# Approach 2: Binary Search\ndef twoSum(numbers, target):\n    def binary_search(nums, target, start):\n        left, right = start, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1\n    \n    for i in range(len(numbers) - 1):\n        complement = target - numbers[i]\n        complement_index = binary_search(numbers, complement, i + 1)\n        \n        if complement_index != -1:\n            return [i + 1, complement_index + 1]\n    \n    return []\n\n# Approach 3: Hash Map (Violates space constraint but shows alternative)\ndef twoSum(numbers, target):\n    num_to_index = {}\n    \n    for i, num in enumerate(numbers):\n        complement = target - num\n        if complement in num_to_index:\n            return [num_to_index[complement] + 1, i + 1]\n        num_to_index[num] = i\n    \n    return []\n\n# Most concise two pointers solution\ndef twoSum(numbers, target):\n    l, r = 0, len(numbers) - 1\n    while l < r:\n        s = numbers[l] + numbers[r]\n        if s == target:\n            return [l + 1, r + 1]\n        elif s < target:\n            l += 1\n        else:\n            r -= 1\n\n# Test cases\ntest_cases = [\n    ([2, 7, 11, 15], 9),\n    ([2, 3, 4], 6),\n    ([-1, 0], -1),\n    ([1, 2, 3, 4, 4, 9, 56, 90], 8)\n]\n\nfor numbers, target in test_cases:\n    result = twoSum(numbers, target)\n    print(f\"numbers: {numbers}, target: {target} -> indices: {result}\")",
          "timeComplexity": "• **Two Pointers**: O(n) single pass through the array\n• **Binary Search**: O(n log n) - O(n) iterations, each with O(log n) binary search\n• **Hash Map**: O(n) but uses O(n) extra space",
          "spaceComplexity": "• **Two Pointers**: O(1) only using two pointers\n• **Binary Search**: O(1) only using variables\n• **Hash Map**: O(n) for storing elements",
          "keyInsights": "• Sorted array property enables efficient two pointers approach\n• Two pointers technique reduces time complexity from O(n²) brute force to O(n)\n• Moving pointers based on sum comparison is the key insight\n• This pattern applies to many sorted array problems\n• Remember to convert to 1-indexed output as required",
          "link": "https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/"
        },
        {
          "id": "tp_3",
          "title": "3Sum",
          "routeName": "three_sum",
          "difficulty": "Medium",
          "leetcodeNumber": 15,
          "companies": ["Facebook", "Amazon", "Google", "Microsoft"],
          "tags": ["Array", "Two Pointers", "Sorting"],
          "description": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.",
          "detailedDescription": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\n\nNotice that the solution set must not contain duplicate triplets.\n\nExample 1:\nInput: nums = [-1,0,1,2,-1,-4]\nOutput: [[-1,-1,2],[-1,0,1]]\nExplanation: \nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.\nThe distinct triplets are [-1,0,1] and [-1,-1,2].\n\nExample 2:\nInput: nums = [0,1,1]\nOutput: []\nExplanation: The only possible triplet does not sum up to 0.\n\nExample 3:\nInput: nums = [0,0,0]\nOutput: [[0,0,0]]\nExplanation: The only possible triplet sums up to 0.\n\nConstraints:\n• 3 <= nums.length <= 3000\n• -10^5 <= nums[i] <= 10^5",
          "approach": "Multiple approaches to solve this problem:\n\n1. **Sort + Two Pointers**: Sort array, fix first element, use two pointers for remaining two.\n\n2. **Brute Force**: Check all possible triplets (O(n³) - not efficient).\n\n3. **Hash Set**: Use set to track seen pairs for each fixed element.\n\n4. **No Sort Approach**: Use hash map but handling duplicates becomes complex.",
          "solution": "**Approach 1: Sort + Two Pointers (Standard Solution)**\nSort array, iterate through first element, use two pointers for the rest.\n\n**Key Insights**: \n1. Sorting helps avoid duplicates and enables two pointers\n2. Skip duplicate first elements\n3. Skip duplicate pairs in two pointers section",
          "code": "# Approach 1: Sort + Two Pointers (Standard Solution)\ndef threeSum(nums):\n    nums.sort()\n    result = []\n    \n    for i in range(len(nums) - 2):\n        # Skip duplicate first elements\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n        \n        left, right = i + 1, len(nums) - 1\n        \n        while left < right:\n            current_sum = nums[i] + nums[left] + nums[right]\n            \n            if current_sum == 0:\n                result.append([nums[i], nums[left], nums[right]])\n                \n                # Skip duplicates for left pointer\n                while left < right and nums[left] == nums[left + 1]:\n                    left += 1\n                \n                # Skip duplicates for right pointer\n                while left < right and nums[right] == nums[right - 1]:\n                    right -= 1\n                \n                left += 1\n                right -= 1\n            \n            elif current_sum < 0:\n                left += 1  # Need larger sum\n            else:\n                right -= 1  # Need smaller sum\n    \n    return result\n\n# Approach 2: More Readable Version\ndef threeSum(nums):\n    nums.sort()\n    triplets = []\n    \n    for i in range(len(nums)):\n        # Skip duplicate first elements\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n        \n        # Use two pointers for remaining elements\n        target = -nums[i]\n        left, right = i + 1, len(nums) - 1\n        \n        while left < right:\n            two_sum = nums[left] + nums[right]\n            \n            if two_sum == target:\n                triplets.append([nums[i], nums[left], nums[right]])\n                \n                # Move both pointers and skip duplicates\n                left += 1\n                right -= 1\n                \n                while left < right and nums[left] == nums[left - 1]:\n                    left += 1\n                while left < right and nums[right] == nums[right + 1]:\n                    right -= 1\n            \n            elif two_sum < target:\n                left += 1\n            else:\n                right -= 1\n    \n    return triplets\n\n# Approach 3: Using Hash Set (Less Efficient)\ndef threeSum(nums):\n    nums.sort()\n    result = set()\n    \n    for i in range(len(nums) - 2):\n        seen = set()\n        for j in range(i + 1, len(nums)):\n            complement = -(nums[i] + nums[j])\n            if complement in seen:\n                triplet = tuple(sorted([nums[i], nums[j], complement]))\n                result.add(triplet)\n            seen.add(nums[j])\n    \n    return [list(triplet) for triplet in result]\n\n# Most concise version\ndef threeSum(nums):\n    nums.sort()\n    res = []\n    for i in range(len(nums)):\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n        l, r = i + 1, len(nums) - 1\n        while l < r:\n            s = nums[i] + nums[l] + nums[r]\n            if s == 0:\n                res.append([nums[i], nums[l], nums[r]])\n                while l < r and nums[l] == nums[l + 1]:\n                    l += 1\n                while l < r and nums[r] == nums[r - 1]:\n                    r -= 1\n                l += 1\n                r -= 1\n            elif s < 0:\n                l += 1\n            else:\n                r -= 1\n    return res\n\n# Test cases\ntest_cases = [\n    [-1, 0, 1, 2, -1, -4],\n    [0, 1, 1],\n    [0, 0, 0],\n    [-2, 0, 1, 1, 2]\n]\n\nfor nums in test_cases:\n    result = threeSum(nums)\n    print(f\"Input: {nums}\")\n    print(f\"Output: {result}\\n\")",
          "timeComplexity": "O(n²) where n is the length of the array. Sorting takes O(n log n), and the main loop with two pointers takes O(n²).",
          "spaceComplexity": "O(1) if we don't count the output array. The sorting is typically done in-place.",
          "keyInsights": "• Sorting is crucial for avoiding duplicates and enabling two pointers\n• The pattern is: fix one element, use two pointers for the remaining two\n• Careful duplicate handling at multiple levels: first element and both pointers\n• This extends the two pointers pattern from 2Sum to 3Sum\n• Can be generalized to kSum problems using recursion",
          "link": "https://leetcode.com/problems/3sum/"
        },
        {
          "id": "tp_4",
          "title": "Container With Most Water",
          "routeName": "container_with_most_water",
          "difficulty": "Medium",
          "leetcodeNumber": 11,
          "companies": ["Facebook", "Amazon", "Google", "Microsoft"],
          "tags": ["Array", "Two Pointers", "Greedy"],
          "description": "You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).",
          "detailedDescription": "You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).\n\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\n\nReturn the maximum amount of water a container can store.\n\nNotice that you may not slant the container.\n\nExample 1:\nInput: height = [1,8,6,2,5,4,8,3,7]\nOutput: 49\nExplanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.\n\nExample 2:\nInput: height = [1,1]\nOutput: 1\n\nConstraints:\n• n == height.length\n• 2 <= n <= 3 * 10^4\n• 0 <= height[i] <= 3 * 10^4",
          "approach": "Multiple approaches to solve this problem:\n\n1. **Two Pointers (Greedy)**: Start from both ends, move the pointer with smaller height.\n\n2. **Brute Force**: Try all possible pairs of lines (O(n²) - not efficient).\n\n3. **Dynamic Programming**: Not applicable here as we need global optimum.\n\nThe key insight is that moving the shorter line gives us the best chance to find a larger area.",
          "solution": "**Approach 1: Two Pointers (Optimal)**\nStart with widest possible container, then move the shorter line inward.\n\n**Approach 2: Brute Force**\nCheck all possible pairs to find maximum area.\n\n**Key Insight**: Always move the pointer with the smaller height because the container's height is limited by the shorter line.",
          "code": "# Approach 1: Two Pointers (Optimal)\ndef maxArea(height):\n    left, right = 0, len(height) - 1\n    max_water = 0\n    \n    while left < right:\n        # Calculate current area\n        width = right - left\n        current_height = min(height[left], height[right])\n        current_area = width * current_height\n        \n        # Update maximum area\n        max_water = max(max_water, current_area)\n        \n        # Move the pointer with smaller height\n        if height[left] < height[right]:\n            left += 1\n        else:\n            right -= 1\n    \n    return max_water\n\n# More concise version\ndef maxArea(height):\n    l, r, max_area = 0, len(height) - 1, 0\n    \n    while l < r:\n        # Calculate area and update maximum\n        max_area = max(max_area, min(height[l], height[r]) * (r - l))\n        \n        # Move pointer with smaller height\n        if height[l] < height[r]:\n            l += 1\n        else:\n            r -= 1\n    \n    return max_area\n\n# Approach 2: Brute Force (For Understanding)\ndef maxArea(height):\n    max_water = 0\n    n = len(height)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            width = j - i\n            container_height = min(height[i], height[j])\n            area = width * container_height\n            max_water = max(max_water, area)\n    \n    return max_water\n\n# Approach 3: Two Pointers with Detailed Logic\ndef maxArea(height):\n    left, right = 0, len(height) - 1\n    max_area = 0\n    \n    while left < right:\n        # The area is determined by the shorter line\n        left_height, right_height = height[left], height[right]\n        width = right - left\n        \n        if left_height < right_height:\n            area = left_height * width\n            left += 1  # Move left pointer since it's the limiting factor\n        else:\n            area = right_height * width\n            right -= 1  # Move right pointer since it's the limiting factor\n        \n        max_area = max(max_area, area)\n    \n    return max_area\n\n# Alternative implementation with early termination optimization\ndef maxArea(height):\n    left, right = 0, len(height) - 1\n    max_area = 0\n    \n    while left < right:\n        width = right - left\n        \n        if height[left] < height[right]:\n            area = height[left] * width\n            left += 1\n        else:\n            area = height[right] * width\n            right -= 1\n        \n        max_area = max(max_area, area)\n        \n        # Early termination: if remaining width * max possible height \n        # cannot beat current max, we can stop\n        if width <= max_area // max(height):\n            break\n    \n    return max_area\n\n# Test cases\ntest_cases = [\n    [1, 8, 6, 2, 5, 4, 8, 3, 7],\n    [1, 1],\n    [4, 3, 2, 1, 4],\n    [1, 2, 1]\n]\n\nfor heights in test_cases:\n    result = maxArea(heights)\n    print(f\"Input: {heights}\")\n    print(f\"Max water: {result}\\n\")",
          "timeComplexity": "• **Two Pointers**: O(n) single pass through the array\n• **Brute Force**: O(n²) checking all possible pairs",
          "spaceComplexity": "O(1) only using a few variables for both approaches",
          "keyInsights": "• The key insight is that the container's height is always limited by the shorter line\n• Moving the taller line inward won't increase the area (width decreases, height stays same)\n• Moving the shorter line gives a chance to find a taller line and increase area\n• This is a greedy approach that works because we explore all potentially optimal solutions\n• The two pointers technique reduces time complexity from O(n²) to O(n)",
          "link": "https://leetcode.com/problems/container-with-most-water/"
        },
        {
          "id": "tp_5",
          "title": "Trapping Rain Water",
          "routeName": "trapping_rain_water",
          "difficulty": "Hard",
          "leetcodeNumber": 42,
          "companies": ["Google", "Amazon", "Facebook", "Microsoft"],
          "tags": [
            "Array",
            "Two Pointers",
            "Dynamic Programming",
            "Stack",
            "Monotonic Stack"
          ],
          "description": "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.",
          "detailedDescription": "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.\n\nExample 1:\nInput: height = [0,1,0,2,1,0,1,3,2,1,2,1]\nOutput: 6\nExplanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.\n\nExample 2:\nInput: height = [4,2,0,3,2,5]\nOutput: 9\n\nConstraints:\n• n == height.length\n• 1 <= n <= 2 * 10^4\n• 0 <= height[i] <= 3 * 10^4",
          "approach": "Multiple approaches to solve this problem:\n\n1. **Two Pointers**: Track max heights from both sides, move pointer with smaller max.\n\n2. **Dynamic Programming**: Pre-compute left and right max arrays.\n\n3. **Stack**: Use monotonic stack to find trapped water.\n\n4. **Brute Force**: For each position, find max left and right heights.",
          "solution": "**Approach 1: Two Pointers (Optimal Space)**\nUse two pointers with left_max and right_max tracking.\n\n**Approach 2: Dynamic Programming (Easier to Understand)**\nPre-compute max heights on left and right for each position.\n\n**Key Insight**: Water at position i = min(max_left[i], max_right[i]) - height[i]",
          "code": "# Approach 1: Two Pointers (Optimal - O(1) Space)\ndef trap(height):\n    if not height or len(height) < 3:\n        return 0\n    \n    left, right = 0, len(height) - 1\n    left_max = right_max = 0\n    water = 0\n    \n    while left < right:\n        if height[left] < height[right]:\n            if height[left] >= left_max:\n                left_max = height[left]\n            else:\n                water += left_max - height[left]\n            left += 1\n        else:\n            if height[right] >= right_max:\n                right_max = height[right]\n            else:\n                water += right_max - height[right]\n            right -= 1\n    \n    return water\n\n# Approach 2: Dynamic Programming (Easier to Understand)\ndef trap(height):\n    if not height:\n        return 0\n    \n    n = len(height)\n    \n    # Compute left max for each position\n    left_max = [0] * n\n    left_max[0] = height[0]\n    for i in range(1, n):\n        left_max[i] = max(left_max[i-1], height[i])\n    \n    # Compute right max for each position\n    right_max = [0] * n\n    right_max[n-1] = height[n-1]\n    for i in range(n-2, -1, -1):\n        right_max[i] = max(right_max[i+1], height[i])\n    \n    # Calculate trapped water\n    water = 0\n    for i in range(n):\n        water_level = min(left_max[i], right_max[i])\n        if water_level > height[i]:\n            water += water_level - height[i]\n    \n    return water\n\n# Approach 3: Using Stack (Alternative Solution)\ndef trap(height):\n    stack = []\n    water = 0\n    \n    for i, h in enumerate(height):\n        while stack and height[stack[-1]] < h:\n            bottom = stack.pop()\n            if not stack:\n                break\n            \n            width = i - stack[-1] - 1\n            bounded_height = min(height[stack[-1]], h) - height[bottom]\n            water += width * bounded_height\n        \n        stack.append(i)\n    \n    return water\n\n# Approach 4: Brute Force (For Understanding)\ndef trap(height):\n    n = len(height)\n    water = 0\n    \n    for i in range(1, n - 1):  # Skip first and last positions\n        # Find max height on the left\n        left_max = max(height[:i+1])\n        \n        # Find max height on the right\n        right_max = max(height[i:])\n        \n        # Water level at position i\n        water_level = min(left_max, right_max)\n        \n        # Add trapped water if any\n        if water_level > height[i]:\n            water += water_level - height[i]\n    \n    return water\n\n# Most concise two pointers solution\ndef trap(height):\n    left, right = 0, len(height) - 1\n    left_max = right_max = water = 0\n    \n    while left < right:\n        if height[left] < height[right]:\n            if height[left] >= left_max:\n                left_max = height[left]\n            else:\n                water += left_max - height[left]\n            left += 1\n        else:\n            if height[right] >= right_max:\n                right_max = height[right]\n            else:\n                water += right_max - height[right]\n            right -= 1\n    \n    return water\n\n# Test cases\ntest_cases = [\n    [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1],\n    [4, 2, 0, 3, 2, 5],\n    [3, 0, 2, 0, 4],\n    []\n]\n\nfor heights in test_cases:\n    result = trap(heights)\n    print(f\"Input: {heights}\")\n    print(f\"Trapped water: {result}\\n\")",
          "timeComplexity": "• **Two Pointers**: O(n) single pass through the array\n• **Dynamic Programming**: O(n) with three passes\n• **Stack**: O(n) each element pushed and popped at most once\n• **Brute Force**: O(n²) for each position, scan left and right",
          "spaceComplexity": "• **Two Pointers**: O(1) only using a few variables\n• **Dynamic Programming**: O(n) for left_max and right_max arrays\n• **Stack**: O(n) for the stack in worst case\n• **Brute Force**: O(1) only using variables",
          "keyInsights": "• Water level at any position is determined by the minimum of max heights on left and right\n• Two pointers approach optimizes space by avoiding pre-computation of max arrays\n• The key insight is that we can process from both ends simultaneously\n• When left height < right height, we can safely calculate water at left position\n• This problem combines multiple algorithmic techniques: two pointers, DP, and stack",
          "link": "https://leetcode.com/problems/trapping-rain-water/"
        }
      ]
    },
    {
      "id": "sliding-window",
      "title": "Sliding Window",
      "description": "Sliding window technique for subarray and substring problems",
      "questions": [
        {
          "id": "sw_1",
          "title": "Best Time to Buy and Sell Stock",
          "routeName": "best_time_to_buy_and_sell_stock",
          "difficulty": "Easy",
          "leetcodeNumber": 121,
          "companies": ["Amazon", "Microsoft", "Facebook", "Apple"],
          "tags": ["Array", "Dynamic Programming"],
          "description": "You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.",
          "detailedDescription": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\n\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\n\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.\n\nExample 1:\nInput: prices = [7,1,5,3,6,4]\nOutput: 5\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\n\nExample 2:\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: In this case, no transactions are done and the max profit = 0.\n\nConstraints:\n• 1 <= prices.length <= 10^5\n• 0 <= prices[i] <= 10^4",
          "approach": "Multiple approaches to solve this problem:\n\n1. **One Pass (Sliding Window)**: Track minimum price seen so far and maximum profit.\n\n2. **Brute Force**: Check all possible buy-sell combinations (O(n²) - not efficient).\n\n3. **Dynamic Programming**: Define states for holding and not holding stock.\n\n4. **Kadane's Algorithm Variant**: Transform to maximum subarray problem.",
          "solution": "**Approach 1: One Pass (Optimal)**\nTrack the minimum price encountered and calculate profit at each step.\n\n**Approach 2: Kadane's Algorithm**\nTransform the problem into finding maximum subarray sum of price differences.\n\n**Key Insight**: At each day, we either buy (if current price is minimum so far) or sell (if profit is maximum so far).",
          "code": "# Approach 1: One Pass - Sliding Window (Most Efficient)\ndef maxProfit(prices):\n    min_price = float('inf')\n    max_profit = 0\n    \n    for price in prices:\n        # Update minimum price seen so far\n        min_price = min(min_price, price)\n        \n        # Calculate profit if we sell at current price\n        current_profit = price - min_price\n        \n        # Update maximum profit\n        max_profit = max(max_profit, current_profit)\n    \n    return max_profit\n\n# Approach 2: More Explicit Version\ndef maxProfit(prices):\n    if not prices or len(prices) < 2:\n        return 0\n    \n    min_price = prices[0]\n    max_profit = 0\n    \n    for i in range(1, len(prices)):\n        # If current price is lower, update min_price\n        if prices[i] < min_price:\n            min_price = prices[i]\n        else:\n            # Calculate profit and update max_profit\n            profit = prices[i] - min_price\n            max_profit = max(max_profit, profit)\n    \n    return max_profit\n\n# Approach 3: Kadane's Algorithm Variant\ndef maxProfit(prices):\n    max_profit = 0\n    min_price = float('inf')\n    \n    for price in prices:\n        min_price = min(min_price, price)\n        max_profit = max(max_profit, price - min_price)\n    \n    return max_profit\n\n# Approach 4: Dynamic Programming\ndef maxProfit(prices):\n    if not prices:\n        return 0\n    \n    # hold[i] = max profit on day i when holding stock\n    # sold[i] = max profit on day i when not holding stock\n    hold = -prices[0]  # Buy on first day\n    sold = 0           # No stock on first day\n    \n    for i in range(1, len(prices)):\n        hold = max(hold, -prices[i])  # Buy today or keep previous\n        sold = max(sold, hold + prices[i])  # Sell today or keep previous\n    \n    return sold\n\n# Approach 5: Brute Force (For Understanding)\ndef maxProfit(prices):\n    max_profit = 0\n    \n    for i in range(len(prices)):\n        for j in range(i + 1, len(prices)):\n            profit = prices[j] - prices[i]\n            max_profit = max(max_profit, profit)\n    \n    return max_profit\n\n# Test cases\ntest_cases = [\n    [7, 1, 5, 3, 6, 4],\n    [7, 6, 4, 3, 1],\n    [1, 2, 3, 4, 5],\n    [5],\n    []\n]\n\nfor prices in test_cases:\n    result = maxProfit(prices)\n    print(f\"Prices: {prices} -> Max Profit: {result}\")",
          "timeComplexity": "• **One Pass**: O(n) single pass through the array\n• **Dynamic Programming**: O(n) single pass\n• **Brute Force**: O(n²) checking all pairs",
          "spaceComplexity": "• **One Pass**: O(1) only using two variables\n• **Dynamic Programming**: O(1) using constant space\n• **Brute Force**: O(1) only using variables",
          "keyInsights": "• The key insight is that we need to track the minimum price seen so far\n• At each price, calculate the profit if we sell at that price\n• This is essentially a sliding window where we expand the right boundary and shrink from left when beneficial\n• The problem can be transformed into finding maximum subarray sum\n• Only one transaction is allowed, making the solution simpler than multiple transactions",
          "link": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock/"
        },
        {
          "id": "sw_2",
          "title": "Longest Substring Without Repeating Characters",
          "routeName": "longest_substring_without_repeating_characters",
          "difficulty": "Medium",
          "leetcodeNumber": 3,
          "companies": ["Amazon", "Facebook", "Google", "Microsoft"],
          "tags": ["Hash Table", "String", "Sliding Window"],
          "description": "Given a string s, find the length of the longest substring without repeating characters.",
          "detailedDescription": "Given a string s, find the length of the longest substring without repeating characters.\n\nExample 1:\nInput: s = \"abcabcbb\"\nOutput: 3\nExplanation: The answer is \"abc\", with the length of 3.\n\nExample 2:\nInput: s = \"bbbbb\"\nOutput: 1\nExplanation: The answer is \"b\", with the length of 1.\n\nExample 3:\nInput: s = \"pwwkew\"\nOutput: 3\nExplanation: The answer is \"wke\", with the length of 3.\nNotice that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\n\nConstraints:\n• 0 <= s.length <= 5 * 10^4\n• s consists of English letters, digits, symbols and spaces.",
          "approach": "Multiple approaches to solve this problem:\n\n1. **Sliding Window with Hash Map**: Use two pointers and hash map to track character positions.\n\n2. **Sliding Window with Set**: Use set to track characters in current window.\n\n3. **Brute Force**: Check all possible substrings (O(n³) - not efficient).\n\n4. **Optimized Sliding Window**: Jump directly to the next valid position when duplicate found.",
          "solution": "**Approach 1: Sliding Window with Hash Map (Optimal)**\nUse hash map to store character positions and jump start pointer efficiently.\n\n**Approach 2: Sliding Window with Set**\nUse set to track characters and shrink window when duplicate found.\n\n**Key Insight**: Maintain a sliding window and expand/shrink based on character uniqueness.",
          "code": "# Approach 1: Sliding Window with Hash Map (Most Efficient)\ndef lengthOfLongestSubstring(s):\n    char_map = {}  # char -> last seen index\n    start = 0\n    max_length = 0\n    \n    for end, char in enumerate(s):\n        # If character is in current window, move start\n        if char in char_map and char_map[char] >= start:\n            start = char_map[char] + 1\n        \n        # Update character position\n        char_map[char] = end\n        \n        # Update max length\n        max_length = max(max_length, end - start + 1)\n    \n    return max_length\n\n# Approach 2: Sliding Window with Set\ndef lengthOfLongestSubstring(s):\n    char_set = set()\n    start = 0\n    max_length = 0\n    \n    for end in range(len(s)):\n        # Shrink window until no duplicate\n        while s[end] in char_set:\n            char_set.remove(s[start])\n            start += 1\n        \n        # Add current character\n        char_set.add(s[end])\n        \n        # Update max length\n        max_length = max(max_length, end - start + 1)\n    \n    return max_length\n\n# Approach 3: More Explicit Sliding Window\ndef lengthOfLongestSubstring(s):\n    if not s:\n        return 0\n    \n    seen = {}\n    left = 0\n    max_len = 0\n    \n    for right in range(len(s)):\n        char = s[right]\n        \n        # If character seen before and within current window\n        if char in seen and seen[char] >= left:\n            left = seen[char] + 1\n        \n        seen[char] = right\n        max_len = max(max_len, right - left + 1)\n    \n    return max_len\n\n# Approach 4: Using collections.defaultdict\nfrom collections import defaultdict\n\ndef lengthOfLongestSubstring(s):\n    char_count = defaultdict(int)\n    left = 0\n    max_length = 0\n    \n    for right in range(len(s)):\n        char_count[s[right]] += 1\n        \n        # Shrink window if we have duplicates\n        while char_count[s[right]] > 1:\n            char_count[s[left]] -= 1\n            if char_count[s[left]] == 0:\n                del char_count[s[left]]\n            left += 1\n        \n        max_length = max(max_length, right - left + 1)\n    \n    return max_length\n\n# Approach 5: Brute Force (For Understanding)\ndef lengthOfLongestSubstring(s):\n    def has_duplicate(substr):\n        return len(set(substr)) != len(substr)\n    \n    n = len(s)\n    max_length = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            substr = s[i:j]\n            if not has_duplicate(substr):\n                max_length = max(max_length, len(substr))\n    \n    return max_length\n\n# Test cases\ntest_cases = [\n    \"abcabcbb\",\n    \"bbbbb\",\n    \"pwwkew\",\n    \"\",\n    \"au\",\n    \"dvdf\"\n]\n\nfor s in test_cases:\n    result = lengthOfLongestSubstring(s)\n    print(f\"Input: '{s}' -> Length: {result}\")",
          "timeComplexity": "• **Sliding Window with Hash Map**: O(n) each character visited at most twice\n• **Sliding Window with Set**: O(n) amortized, O(2n) worst case\n• **Brute Force**: O(n³) checking all substrings",
          "spaceComplexity": "• **Hash Map approach**: O(min(m, n)) where m is character set size\n• **Set approach**: O(min(m, n)) for the set\n• **Brute Force**: O(min(m, n)) for duplicate checking",
          "keyInsights": "• Sliding window technique is perfect for contiguous subarray/substring problems\n• Hash map optimization allows jumping directly to next valid position\n• The key is maintaining a window of unique characters\n• Two pointers represent the current window boundaries\n• This pattern applies to many substring optimization problems",
          "link": "https://leetcode.com/problems/longest-substring-without-repeating-characters/"
        },
        {
          "id": "sw_3",
          "title": "Longest Repeating Character Replacement",
          "routeName": "longest_repeating_character_replacement",
          "difficulty": "Medium",
          "leetcodeNumber": 424,
          "companies": ["Google", "Amazon", "Microsoft", "Facebook"],
          "tags": ["Hash Table", "String", "Sliding Window"],
          "description": "You are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English letter. You can perform this operation at most k times.",
          "detailedDescription": "You are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English letter. You can perform this operation at most k times.\n\nReturn the length of the longest substring containing the same letter you can get after performing the above operations.\n\nExample 1:\nInput: s = \"ABAB\", k = 2\nOutput: 4\nExplanation: Replace the two 'A's with two 'B's or vice versa.\n\nExample 2:\nInput: s = \"AABABBA\", k = 1\nOutput: 4\nExplanation: Replace the one 'A' in the middle with 'B' and form \"AABBBBA\".\nThe substring \"BBBB\" has the longest repeating letters, which is 4.\n\nConstraints:\n• 1 <= s.length <= 10^5\n• s consists of only uppercase English letters.\n• 0 <= k <= s.length",
          "approach": "Multiple approaches to solve this problem:\n\n1. **Sliding Window with Character Count**: Track character frequencies and maintain valid window.\n\n2. **Sliding Window with Max Count Optimization**: Track the maximum frequency character.\n\n3. **Brute Force**: Check all possible substrings (O(n²) - not efficient).",
          "solution": "**Approach 1: Sliding Window with Character Count**\nMaintain a window where (window_size - max_frequency) <= k.\n\n**Approach 2: Optimized Sliding Window**\nTrack maximum frequency to avoid recalculating each time.\n\n**Key Insight**: A window is valid if we can change at most k characters to make all characters the same.",
          "code": "# Approach 1: Sliding Window with Character Count (Most Efficient)\ndef characterReplacement(s, k):\n    count = {}  # character frequency in current window\n    left = 0\n    max_length = 0\n    max_count = 0  # maximum frequency of any character in current window\n    \n    for right in range(len(s)):\n        # Add current character to window\n        count[s[right]] = count.get(s[right], 0) + 1\n        max_count = max(max_count, count[s[right]])\n        \n        # Check if current window is valid\n        # Window is valid if: window_size - max_frequency <= k\n        window_size = right - left + 1\n        if window_size - max_count > k:\n            # Shrink window from left\n            count[s[left]] -= 1\n            left += 1\n        \n        # Update maximum length\n        max_length = max(max_length, right - left + 1)\n    \n    return max_length\n\n# Approach 2: More Explicit Version\ndef characterReplacement(s, k):\n    char_count = {}\n    left = 0\n    max_len = 0\n    \n    for right in range(len(s)):\n        # Expand window by including s[right]\n        char_count[s[right]] = char_count.get(s[right], 0) + 1\n        \n        # Find the maximum frequency in current window\n        max_freq = max(char_count.values())\n        \n        # Current window size\n        window_size = right - left + 1\n        \n        # If we need to change more than k characters, shrink window\n        if window_size - max_freq > k:\n            char_count[s[left]] -= 1\n            if char_count[s[left]] == 0:\n                del char_count[s[left]]\n            left += 1\n        \n        # Update maximum length\n        max_len = max(max_len, right - left + 1)\n    \n    return max_len\n\n# Approach 3: Using collections.defaultdict\nfrom collections import defaultdict\n\ndef characterReplacement(s, k):\n    count = defaultdict(int)\n    left = 0\n    max_count = 0\n    result = 0\n    \n    for right in range(len(s)):\n        count[s[right]] += 1\n        max_count = max(max_count, count[s[right]])\n        \n        # If current window is invalid, shrink it\n        while (right - left + 1) - max_count > k:\n            count[s[left]] -= 1\n            left += 1\n            # Note: We don't update max_count here for efficiency\n            # It's still correct because max_count will only affect\n            # the window size, and we'll get the right answer\n        \n        result = max(result, right - left + 1)\n    \n    return result\n\n# Approach 4: Brute Force (For Understanding)\ndef characterReplacement(s, k):\n    def can_make_same(substr, k):\n        char_count = {}\n        for char in substr:\n            char_count[char] = char_count.get(char, 0) + 1\n        \n        max_freq = max(char_count.values())\n        return len(substr) - max_freq <= k\n    \n    max_length = 0\n    n = len(s)\n    \n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            substr = s[i:j]\n            if can_make_same(substr, k):\n                max_length = max(max_length, len(substr))\n    \n    return max_length\n\n# Optimized version with early max_count tracking\ndef characterReplacement(s, k):\n    count = {}\n    left = max_count = max_len = 0\n    \n    for right in range(len(s)):\n        count[s[right]] = count.get(s[right], 0) + 1\n        max_count = max(max_count, count[s[right]])\n        \n        if (right - left + 1) - max_count > k:\n            count[s[left]] -= 1\n            left += 1\n        \n        max_len = max(max_len, right - left + 1)\n    \n    return max_len\n\n# Test cases\ntest_cases = [\n    (\"ABAB\", 2),\n    (\"AABABBA\", 1),\n    (\"AAAA\", 2),\n    (\"ABCDE\", 1),\n    (\"KRSCDCSONAJNHLBMDQGIFCPEKPOHQIHLTDIQGEKLRLCQNBOHNDQGHJPNDQPERNFSSSRDEQLFPCCCARFMDLHADJADAGNNSBNCJQOF\", 4)\n]\n\nfor s, k in test_cases:\n    result = characterReplacement(s, k)\n    print(f\"String: '{s}', k: {k} -> Max Length: {result}\")",
          "timeComplexity": "O(n) where n is the length of the string. Each character is visited at most twice (once by right pointer, once by left pointer).",
          "spaceComplexity": "O(1) since we're dealing with at most 26 uppercase English letters, the hash map size is constant.",
          "keyInsights": "• The key insight is that a window is valid if (window_size - max_frequency) <= k\n• We don't need to recalculate max_count when shrinking window for efficiency\n• Sliding window technique helps maintain the longest valid substring\n• The max_count optimization prevents us from recalculating the maximum frequency every time\n• This problem demonstrates how sliding window can handle constraint-based optimization",
          "link": "https://leetcode.com/problems/longest-repeating-character-replacement/"
        },
        {
          "id": "sw_4",
          "title": "Permutation in String",
          "routeName": "permutation_in_string",
          "difficulty": "Medium",
          "leetcodeNumber": 567,
          "companies": ["Microsoft", "Facebook", "Amazon", "Google"],
          "tags": ["Hash Table", "Two Pointers", "String", "Sliding Window"],
          "description": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.",
          "detailedDescription": "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.\n\nExample 1:\nInput: s1 = \"ab\", s2 = \"eidbaooo\"\nOutput: true\nExplanation: s2 contains one permutation of s1 (\"ba\").\n\nExample 2:\nInput: s1 = \"ab\", s2 = \"eidboaoo\"\nOutput: false\n\nConstraints:\n• 1 <= s1.length, s2.length <= 10^4\n• s1 and s2 consist of lowercase English letters.",
          "approach": "Multiple approaches to solve this problem:\n\n1. **Sliding Window with Counter**: Use sliding window of s1 length and compare character counts.\n\n2. **Sliding Window with Hash Map**: Maintain character frequencies in current window.\n\n3. **Sorting**: Sort s1 and check if any substring of s2 with same length has same sorted characters.\n\n4. **Brute Force**: Generate all permutations of s1 and check if any exists in s2.",
          "solution": "**Approach 1: Sliding Window with Counter (Optimal)**\nMaintain a sliding window of s1's length and compare character frequencies.\n\n**Approach 2: Hash Map Sliding Window**\nTrack character counts and adjust window dynamically.\n\n**Key Insight**: Two strings are permutations if they have the same character frequencies.",
          "code": "# Approach 1: Sliding Window with Counter (Most Efficient)\nfrom collections import Counter\n\ndef checkInclusion(s1, s2):\n    if len(s1) > len(s2):\n        return False\n    \n    s1_count = Counter(s1)\n    window_size = len(s1)\n    \n    # Initialize window\n    window_count = Counter(s2[:window_size])\n    \n    # Check first window\n    if s1_count == window_count:\n        return True\n    \n    # Slide the window\n    for i in range(window_size, len(s2)):\n        # Add new character\n        window_count[s2[i]] += 1\n        \n        # Remove old character\n        left_char = s2[i - window_size]\n        window_count[left_char] -= 1\n        if window_count[left_char] == 0:\n            del window_count[left_char]\n        \n        # Check if current window matches\n        if s1_count == window_count:\n            return True\n    \n    return False\n\n# Approach 2: Sliding Window with Manual Counter\ndef checkInclusion(s1, s2):\n    if len(s1) > len(s2):\n        return False\n    \n    # Count characters in s1\n    s1_count = {}\n    for char in s1:\n        s1_count[char] = s1_count.get(char, 0) + 1\n    \n    window_size = len(s1)\n    window_count = {}\n    left = 0\n    \n    for right in range(len(s2)):\n        # Add character to window\n        char = s2[right]\n        window_count[char] = window_count.get(char, 0) + 1\n        \n        # Maintain window size\n        if right - left + 1 > window_size:\n            left_char = s2[left]\n            window_count[left_char] -= 1\n            if window_count[left_char] == 0:\n                del window_count[left_char]\n            left += 1\n        \n        # Check if window matches s1\n        if window_count == s1_count:\n            return True\n    \n    return False\n\n# Approach 3: Using Array for Character Counting (For lowercase letters only)\ndef checkInclusion(s1, s2):\n    if len(s1) > len(s2):\n        return False\n    \n    # Character count arrays\n    s1_count = [0] * 26\n    window_count = [0] * 26\n    \n    # Count characters in s1\n    for char in s1:\n        s1_count[ord(char) - ord('a')] += 1\n    \n    window_size = len(s1)\n    \n    # Process first window\n    for i in range(window_size):\n        window_count[ord(s2[i]) - ord('a')] += 1\n    \n    # Check first window\n    if s1_count == window_count:\n        return True\n    \n    # Slide the window\n    for i in range(window_size, len(s2)):\n        # Add new character\n        window_count[ord(s2[i]) - ord('a')] += 1\n        \n        # Remove old character\n        window_count[ord(s2[i - window_size]) - ord('a')] -= 1\n        \n        # Check current window\n        if s1_count == window_count:\n            return True\n    \n    return False\n\n# Approach 4: Sorting Approach\ndef checkInclusion(s1, s2):\n    if len(s1) > len(s2):\n        return False\n    \n    s1_sorted = ''.join(sorted(s1))\n    window_size = len(s1)\n    \n    for i in range(len(s2) - window_size + 1):\n        window = s2[i:i + window_size]\n        if ''.join(sorted(window)) == s1_sorted:\n            return True\n    \n    return False\n\n# Approach 5: Optimized with matches count\ndef checkInclusion(s1, s2):\n    if len(s1) > len(s2):\n        return False\n    \n    s1_count = Counter(s1)\n    window_count = Counter()\n    \n    left = 0\n    required = len(s1_count)\n    formed = 0\n    \n    for right in range(len(s2)):\n        char = s2[right]\n        window_count[char] += 1\n        \n        if char in s1_count and window_count[char] == s1_count[char]:\n            formed += 1\n        \n        # Maintain window size\n        while right - left + 1 > len(s1):\n            char = s2[left]\n            if char in s1_count and window_count[char] == s1_count[char]:\n                formed -= 1\n            window_count[char] -= 1\n            if window_count[char] == 0:\n                del window_count[char]\n            left += 1\n        \n        if formed == required and right - left + 1 == len(s1):\n            return True\n    \n    return False\n\n# Test cases\ntest_cases = [\n    (\"ab\", \"eidbaooo\"),\n    (\"ab\", \"eidboaoo\"),\n    (\"adc\", \"dcda\"),\n    (\"hello\", \"ooolleoooleh\"),\n    (\"abc\", \"bbbca\")\n]\n\nfor s1, s2 in test_cases:\n    result = checkInclusion(s1, s2)\n    print(f\"s1: '{s1}', s2: '{s2}' -> {result}\")",
          "timeComplexity": "• **Sliding Window**: O(|s1| + |s2|) single pass through s2 with constant time operations\n• **Sorting Approach**: O(|s1| * log|s1| * (|s2| - |s1|)) sorting each window\n• **Array Counting**: O(|s1| + |s2|) with O(1) comparison for each window",
          "spaceComplexity": "• **Counter/Hash Map**: O(|s1|) for storing character frequencies\n• **Array Counting**: O(1) since we only need arrays of size 26\n• **Sorting**: O(|s1|) for sorted strings",
          "keyInsights": "• Two strings are permutations if they have identical character frequencies\n• Sliding window of fixed size |s1| is perfect for this problem\n• Counter comparison in Python is efficient for this use case\n• Array-based counting is more space-efficient for known character sets\n• The key optimization is maintaining window size and sliding efficiently",
          "link": "https://leetcode.com/problems/permutation-in-string/"
        },
        {
          "id": "sw_5",
          "title": "Minimum Window Substring",
          "routeName": "minimum_window_substring",
          "difficulty": "Hard",
          "leetcodeNumber": 76,
          "companies": ["Facebook", "Amazon", "Google", "Microsoft"],
          "tags": ["Hash Table", "String", "Sliding Window"],
          "description": "Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window.",
          "detailedDescription": "Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such window in s that covers all characters in t, return the empty string \"\".\n\nNote that If there is such a window, it is guaranteed that there will always be only one unique minimum window in s.\n\nExample 1:\nInput: s = \"ADOBECODEBANC\", t = \"ABC\"\nOutput: \"BANC\"\nExplanation: The minimum window substring \"BANC\" includes 'A', 'B', and 'C' from string t.\n\nExample 2:\nInput: s = \"a\", t = \"a\"\nOutput: \"a\"\nExplanation: The entire string s is the minimum window.\n\nExample 3:\nInput: s = \"a\", t = \"aa\"\nOutput: \"\"\nExplanation: Both 'a's from t must be included in the window.\nSince the largest window of s only has one 'a', return empty string.\n\nConstraints:\n• m == s.length\n• n == t.length\n• 1 <= m, n <= 10^5\n• s and t consist of uppercase and lowercase English letters.",
          "approach": "Multiple approaches to solve this problem:\n\n1. **Sliding Window with Two Pointers**: Expand right to include all characters, then shrink from left.\n\n2. **Sliding Window with Counter**: Track required and formed character counts.\n\n3. **Brute Force**: Check all possible substrings (O(n³) - not efficient).",
          "solution": "**Approach 1: Sliding Window with Two Pointers**\nExpand window until all characters are included, then try to shrink from left.\n\n**Approach 2: Optimized with Character Tracking**\nTrack how many unique characters from t are satisfied in current window.\n\n**Key Insight**: Use expandable-shrinkable sliding window pattern.",
          "code": "# Approach 1: Sliding Window with Counter (Most Efficient)\nfrom collections import Counter\n\ndef minWindow(s, t):\n    if not s or not t or len(s) < len(t):\n        return \"\"\n    \n    # Character frequency in t\n    required = Counter(t)\n    required_count = len(required)\n    \n    # Sliding window variables\n    left = right = 0\n    formed = 0  # Number of unique chars in window with desired frequency\n    \n    # Window character frequency\n    window_counts = {}\n    \n    # Result\n    min_len = float('inf')\n    min_left = 0\n    \n    while right < len(s):\n        # Add character from right to window\n        char = s[right]\n        window_counts[char] = window_counts.get(char, 0) + 1\n        \n        # Check if frequency matches required frequency\n        if char in required and window_counts[char] == required[char]:\n            formed += 1\n        \n        # Try to shrink window from left\n        while left <= right and formed == required_count:\n            char = s[left]\n            \n            # Update result if this window is smaller\n            if right - left + 1 < min_len:\n                min_len = right - left + 1\n                min_left = left\n            \n            # Remove leftmost character\n            window_counts[char] -= 1\n            if char in required and window_counts[char] < required[char]:\n                formed -= 1\n            \n            left += 1\n        \n        right += 1\n    \n    return \"\" if min_len == float('inf') else s[min_left:min_left + min_len]\n\n# Approach 2: Alternative Implementation\ndef minWindow(s, t):\n    from collections import defaultdict\n    \n    if not s or not t:\n        return \"\"\n    \n    # Dictionary to keep count of all unique characters in t\n    dict_t = defaultdict(int)\n    for char in t:\n        dict_t[char] += 1\n    \n    required = len(dict_t)\n    left = right = 0\n    formed = 0\n    window_counts = defaultdict(int)\n    \n    # ans list: (window length, left, right)\n    ans = float('inf'), None, None\n    \n    while right < len(s):\n        # Add one character from the right to the window\n        character = s[right]\n        window_counts[character] += 1\n        \n        # If the frequency of the current character added equals to the\n        # desired count in t then increment the formed count by 1\n        if character in dict_t and window_counts[character] == dict_t[character]:\n            formed += 1\n        \n        # Try to contract the window till it ceases to be 'desirable'\n        while left <= right and formed == required:\n            character = s[left]\n            \n            # Save the smallest window until now\n            if right - left + 1 < ans[0]:\n                ans = (right - left + 1, left, right)\n            \n            # The character at the left pointer is no longer part of the window\n            window_counts[character] -= 1\n            if character in dict_t and window_counts[character] < dict_t[character]:\n                formed -= 1\n            \n            # Move the left pointer ahead for the next iteration\n            left += 1\n        \n        # Keep expanding the window by moving right pointer\n        right += 1\n    \n    return \"\" if ans[0] == float('inf') else s[ans[1]:ans[2] + 1]\n\n# Approach 3: Simplified Version\ndef minWindow(s, t):\n    if len(s) < len(t):\n        return \"\"\n    \n    need = Counter(t)\n    missing = len(t)\n    left = start = end = 0\n    \n    for right, char in enumerate(s):\n        # Expand window\n        if need[char] > 0:\n            missing -= 1\n        need[char] -= 1\n        \n        # Contract window\n        while missing == 0:\n            if end == 0 or right - left + 1 < end - start + 1:\n                start, end = left, right + 1\n            \n            need[s[left]] += 1\n            if need[s[left]] > 0:\n                missing += 1\n            left += 1\n    \n    return s[start:end]\n\n# Approach 4: Brute Force (For Understanding)\ndef minWindow(s, t):\n    def contains_all(window, target):\n        target_count = Counter(target)\n        window_count = Counter(window)\n        \n        for char, count in target_count.items():\n            if window_count[char] < count:\n                return False\n        return True\n    \n    min_window = \"\"\n    min_len = float('inf')\n    \n    for i in range(len(s)):\n        for j in range(i + len(t), len(s) + 1):\n            window = s[i:j]\n            if contains_all(window, t) and len(window) < min_len:\n                min_len = len(window)\n                min_window = window\n    \n    return min_window\n\n# Test cases\ntest_cases = [\n    (\"ADOBECODEBANC\", \"ABC\"),\n    (\"a\", \"a\"),\n    (\"a\", \"aa\"),\n    (\"ab\", \"b\"),\n    (\"bba\", \"ab\")\n]\n\nfor s, t in test_cases:\n    result = minWindow(s, t)\n    print(f\"s: '{s}', t: '{t}' -> Minimum window: '{result}'\")",
          "timeComplexity": "O(|s| + |t|) where each character in s and t is visited at most twice (once by right pointer, once by left pointer).",
          "spaceComplexity": "O(|s| + |t|) for the hash maps storing character frequencies. In the worst case, we might store all unique characters from both strings.",
          "keyInsights": "• Use expandable-shrinkable sliding window: expand to include all characters, then shrink to find minimum\n• Track 'formed' count to know when window contains all required characters\n• The key insight is that we only shrink when we have a valid window\n• Counter/hash map comparison is essential for checking character requirements\n• This pattern applies to many substring problems with character constraints",
          "link": "https://leetcode.com/problems/minimum-window-substring/"
        },
        {
          "id": "sw_6",
          "title": "Sliding Window Maximum",
          "routeName": "sliding_window_maximum",
          "difficulty": "Hard",
          "leetcodeNumber": 239,
          "companies": ["Amazon", "Google", "Facebook", "Microsoft"],
          "tags": [
            "Array",
            "Queue",
            "Sliding Window",
            "Heap",
            "Monotonic Queue"
          ],
          "description": "You are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right.",
          "detailedDescription": "You are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.\n\nReturn the max sliding window.\n\nExample 1:\nInput: nums = [1,3,-1,-3,5,3,6,7], k = 3\nOutput: [3,3,5,5,6,7]\nExplanation: \nWindow position                Max\n---------------               -----\n[1  3  -1] -3  5  3  6  7       3\n 1 [3  -1  -3] 5  3  6  7       3\n 1  3 [-1  -3  5] 3  6  7       5\n 1  3  -1 [-3  5  3] 6  7       5\n 1  3  -1  -3 [5  3  6] 7       6\n 1  3  -1  -3  5 [3  6  7]      7\n\nExample 2:\nInput: nums = [1], k = 1\nOutput: [1]\n\nConstraints:\n• 1 <= nums.length <= 10^5\n• -10^4 <= nums[i] <= 10^4\n• 1 <= k <= nums.length",
          "approach": "Multiple approaches to solve this problem:\n\n1. **Monotonic Deque**: Use deque to maintain elements in decreasing order.\n\n2. **Max Heap**: Use priority queue to track maximum elements.\n\n3. **Brute Force**: For each window, find maximum (O(nk) - not efficient).\n\n4. **Segment Tree**: Build segment tree for range maximum queries.",
          "solution": "**Approach 1: Monotonic Deque (Optimal)**\nMaintain a deque with indices in decreasing order of their values.\n\n**Approach 2: Max Heap**\nUse heap to track maximum, but need to handle stale elements.\n\n**Key Insight**: Monotonic deque ensures the front always contains the maximum of current window.",
          "code": "# Approach 1: Monotonic Deque (Most Efficient)\nfrom collections import deque\n\ndef maxSlidingWindow(nums, k):\n    if not nums or k <= 0:\n        return []\n    \n    dq = deque()  # Store indices\n    result = []\n    \n    for i in range(len(nums)):\n        # Remove indices that are out of current window\n        while dq and dq[0] <= i - k:\n            dq.popleft()\n        \n        # Remove indices whose corresponding values are smaller than nums[i]\n        while dq and nums[dq[-1]] < nums[i]:\n            dq.pop()\n        \n        # Add current index\n        dq.append(i)\n        \n        # Add maximum of current window to result\n        if i >= k - 1:\n            result.append(nums[dq[0]])\n    \n    return result\n\n# Approach 2: Using Max Heap\nimport heapq\n\ndef maxSlidingWindow(nums, k):\n    if not nums or k <= 0:\n        return []\n    \n    # Max heap (negate values for max heap behavior)\n    heap = []\n    result = []\n    \n    for i in range(len(nums)):\n        # Add current element to heap\n        heapq.heappush(heap, (-nums[i], i))\n        \n        # Remove elements outside current window\n        while heap and heap[0][1] <= i - k:\n            heapq.heappop(heap)\n        \n        # Add maximum of current window to result\n        if i >= k - 1:\n            result.append(-heap[0][0])\n    \n    return result\n\n# Approach 3: Brute Force (For Understanding)\ndef maxSlidingWindow(nums, k):\n    if not nums or k <= 0:\n        return []\n    \n    result = []\n    \n    for i in range(len(nums) - k + 1):\n        window_max = max(nums[i:i+k])\n        result.append(window_max)\n    \n    return result\n\n# Approach 4: Optimized Deque with Clean Logic\ndef maxSlidingWindow(nums, k):\n    dq = deque()\n    result = []\n    \n    for i, num in enumerate(nums):\n        # Remove elements outside window\n        if dq and dq[0] == i - k:\n            dq.popleft()\n        \n        # Maintain decreasing order in deque\n        while dq and nums[dq[-1]] <= num:\n            dq.pop()\n        \n        dq.append(i)\n        \n        # Add to result when window is complete\n        if i >= k - 1:\n            result.append(nums[dq[0]])\n    \n    return result\n\n# Approach 5: Using Segment Tree (Advanced)\nclass SegmentTree:\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.arr = arr\n        self.build(1, 0, self.n - 1)\n    \n    def build(self, v, tl, tr):\n        if tl == tr:\n            self.tree[v] = self.arr[tl]\n        else:\n            tm = (tl + tr) // 2\n            self.build(2*v, tl, tm)\n            self.build(2*v+1, tm+1, tr)\n            self.tree[v] = max(self.tree[2*v], self.tree[2*v+1])\n    \n    def query(self, v, tl, tr, l, r):\n        if l > r:\n            return float('-inf')\n        if l == tl and r == tr:\n            return self.tree[v]\n        tm = (tl + tr) // 2\n        return max(\n            self.query(2*v, tl, tm, l, min(r, tm)),\n            self.query(2*v+1, tm+1, tr, max(l, tm+1), r)\n        )\n    \n    def range_max(self, l, r):\n        return self.query(1, 0, self.n - 1, l, r)\n\ndef maxSlidingWindow(nums, k):\n    if not nums or k <= 0:\n        return []\n    \n    st = SegmentTree(nums)\n    result = []\n    \n    for i in range(len(nums) - k + 1):\n        result.append(st.range_max(i, i + k - 1))\n    \n    return result\n\n# Test cases\ntest_cases = [\n    ([1, 3, -1, -3, 5, 3, 6, 7], 3),\n    ([1], 1),\n    ([1, -1], 1),\n    ([9, 11], 2),\n    ([4, -2, -3, 11, 2, -1, 4, 5], 4)\n]\n\nfor nums, k in test_cases:\n    result = maxSlidingWindow(nums, k)\n    print(f\"nums: {nums}, k: {k} -> {result}\")",
          "timeComplexity": "• **Monotonic Deque**: O(n) each element is added and removed at most once\n• **Max Heap**: O(n log n) heap operations for n elements\n• **Brute Force**: O(nk) finding max in each window\n• **Segment Tree**: O(n log n) for build + O(n log n) for queries",
          "spaceComplexity": "• **Monotonic Deque**: O(k) deque can store at most k elements\n• **Max Heap**: O(n) heap can grow to size n\n• **Brute Force**: O(1) only using variables\n• **Segment Tree**: O(n) for the tree structure",
          "keyInsights": "• Monotonic deque maintains elements in decreasing order for O(1) maximum access\n• The front of deque always contains the index of maximum element in current window\n• Remove indices outside current window and smaller elements to maintain monotonic property\n• This technique is powerful for sliding window problems requiring range queries\n• Deque operations ensure each element is processed at most twice (added once, removed once)",
          "link": "https://leetcode.com/problems/sliding-window-maximum/"
        }
      ]
    },
    {
      "id": "stack",
      "title": "Stack",
      "description": "Stack data structure and its applications in solving algorithmic problems",
      "questions": [
        {
          "id": "st_1",
          "title": "Valid Parentheses",
          "routeName": "valid_parentheses",
          "difficulty": "Easy",
          "leetcodeNumber": 20,
          "companies": ["Amazon", "Google", "Facebook", "Microsoft"],
          "tags": ["String", "Stack"],
          "description": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.",
          "detailedDescription": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n\nAn input string is valid if:\n1. Open brackets must be closed by the same type of brackets.\n2. Open brackets must be closed in the correct order.\n3. Every close bracket has a corresponding open bracket of the same type.\n\nExample 1:\nInput: s = \"()\"\nOutput: true\n\nExample 2:\nInput: s = \"()[]{}\"\nOutput: true\n\nExample 3:\nInput: s = \"(]\"\nOutput: false\n\nConstraints:\n• 1 <= s.length <= 10^4\n• s consists of parentheses only '()[]{}'.",
          "approach": "Multiple approaches to solve this problem:\n\n1. **Stack with Mapping**: Use stack and hash map for bracket matching.\n\n2. **Stack with Conditional Logic**: Use if-else conditions for bracket types.\n\n3. **Counter Method**: Count open and close brackets (limited to single bracket type).\n\n4. **Replace Method**: Repeatedly replace valid pairs until none left.",
          "solution": "**Approach 1: Stack with Hash Map (Most Elegant)**\nUse hash map to store bracket mappings and stack for tracking.\n\n**Approach 2: Stack with Conditional Logic**\nUse explicit conditions for each bracket type.\n\n**Key Insight**: Stack is perfect for matching nested structures like parentheses.",
          "code": "# Approach 1: Stack with Hash Map (Most Elegant)\ndef isValid(s):\n    stack = []\n    mapping = {')': '(', ']': '[', '}': '{'}\n    \n    for char in s:\n        if char in mapping:  # Closing bracket\n            top_element = stack.pop() if stack else '#'\n            if mapping[char] != top_element:\n                return False\n        else:  # Opening bracket\n            stack.append(char)\n    \n    return not stack\n\n# Approach 2: Stack with Conditional Logic\ndef isValid(s):\n    stack = []\n    \n    for char in s:\n        if char in '([{':\n            stack.append(char)\n        elif char in ')]}':\n            if not stack:\n                return False\n            \n            top = stack.pop()\n            if (char == ')' and top != '(' or\n                char == ']' and top != '[' or\n                char == '}' and top != '{'):\n                return False\n    \n    return len(stack) == 0\n\n# Approach 3: More Explicit Version\ndef isValid(s):\n    stack = []\n    pairs = {'(': ')', '[': ']', '{': '}'}\n    \n    for char in s:\n        if char in pairs:  # Opening bracket\n            stack.append(char)\n        else:  # Closing bracket\n            if not stack or pairs[stack.pop()] != char:\n                return False\n    \n    return not stack\n\n# Approach 4: Using Dictionary for Both Directions\ndef isValid(s):\n    stack = []\n    brackets = {\n        '(': ')', '[': ']', '{': '}',\n        ')': '(', ']': '[', '}': '{'\n    }\n    opening = set('([{')\n    \n    for char in s:\n        if char in opening:\n            stack.append(char)\n        else:\n            if not stack or stack.pop() != brackets[char]:\n                return False\n    \n    return not stack\n\n# Approach 5: Replace Method (Alternative but Less Efficient)\ndef isValid(s):\n    while '()' in s or '[]' in s or '{}' in s:\n        s = s.replace('()', '').replace('[]', '').replace('{}', '')\n    return s == ''\n\n# Approach 6: Counter Method (Only for Single Bracket Type)\ndef isValid(s):\n    # This only works if s contains only one type of bracket\n    if len(set(s)) > 2:\n        return False  # More than one bracket type\n    \n    count = 0\n    for char in s:\n        if char in '([{':\n            count += 1\n        else:\n            count -= 1\n            if count < 0:  # More closing than opening\n                return False\n    \n    return count == 0\n\n# Test cases\ntest_cases = [\n    \"()\",\n    \"()[]{}\",\n    \"(]\",\n    \"([)]\",\n    \"{[]}\",\n    \"\",\n    \"(((\",\n    \")))\"\n]\n\nfor test in test_cases:\n    result = isValid(test)\n    print(f\"'{test}' -> {result}\")",
          "timeComplexity": "• **Stack approaches**: O(n) single pass through the string\n• **Replace method**: O(n²) in worst case due to multiple string replacements",
          "spaceComplexity": "• **Stack approaches**: O(n) in worst case when all characters are opening brackets\n• **Replace method**: O(n) for string operations",
          "keyInsights": "• Stack is the natural data structure for matching nested structures\n• Hash map mapping makes the code cleaner and more maintainable\n• The key insight is that every closing bracket must match the most recent unmatched opening bracket\n• This pattern applies to many nested structure problems\n• Early termination when stack is empty but we encounter closing bracket optimizes performance",
          "link": "https://leetcode.com/problems/valid-parentheses/"
        },
        {
          "id": "st_2",
          "title": "Min Stack",
          "routeName": "min_stack",
          "difficulty": "Medium",
          "leetcodeNumber": 155,
          "companies": ["Amazon", "Google", "Bloomberg", "Microsoft"],
          "tags": ["Stack", "Design"],
          "description": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.",
          "detailedDescription": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\n\nImplement the MinStack class:\n• MinStack() initializes the stack object.\n• void push(int val) pushes the element val onto the stack.\n• void pop() removes the element on the top of the stack.\n• int top() gets the top element of the stack.\n• int getMin() retrieves the minimum element in the stack.\n\nYou must implement a solution with O(1) time complexity for each function.\n\nExample 1:\nInput\n[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"]\n[[],[-2],[0],[-3],[],[],[],[]]\n\nOutput\n[null,null,null,null,-3,null,0,-2]\n\nExplanation\nMinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.getMin(); // return -3\nminStack.pop();\nminStack.top();    // return 0\nminStack.getMin(); // return -2\n\nConstraints:\n• -2^31 <= val <= 2^31 - 1\n• Methods pop, top and getMin operations will always be called on non-empty stacks.\n• At most 3 * 10^4 calls will be made to push, pop, top, and getMin.",
          "approach": "Multiple approaches to solve this problem:\n\n1. **Two Stacks**: Use one stack for values, another for minimums.\n\n2. **Stack with Pairs**: Store (value, min_so_far) pairs in single stack.\n\n3. **Single Stack with Min Tracking**: Store differences and track minimum separately.\n\n4. **Linked List**: Use linked list with min tracking at each node.",
          "solution": "**Approach 1: Stack with Pairs (Most Intuitive)**\nStore (value, current_minimum) pairs in the stack.\n\n**Approach 2: Two Stacks**\nMaintain separate stacks for values and minimums.\n\n**Key Insight**: Track minimum at each level to enable O(1) access after pop operations.",
          "code": "# Approach 1: Stack with Pairs (Most Intuitive)\nclass MinStack:\n    def __init__(self):\n        self.stack = []\n    \n    def push(self, val):\n        # Store (value, min_value_at_this_level)\n        if not self.stack:\n            self.stack.append((val, val))\n        else:\n            current_min = min(val, self.stack[-1][1])\n            self.stack.append((val, current_min))\n    \n    def pop(self):\n        self.stack.pop()\n    \n    def top(self):\n        return self.stack[-1][0]\n    \n    def getMin(self):\n        return self.stack[-1][1]\n\n# Approach 2: Two Stacks\nclass MinStack:\n    def __init__(self):\n        self.stack = []\n        self.min_stack = []\n    \n    def push(self, val):\n        self.stack.append(val)\n        \n        # Only push to min_stack if it's empty or val is <= current min\n        if not self.min_stack or val <= self.min_stack[-1]:\n            self.min_stack.append(val)\n    \n    def pop(self):\n        if self.stack:\n            popped = self.stack.pop()\n            # Only pop from min_stack if popped value was the minimum\n            if popped == self.min_stack[-1]:\n                self.min_stack.pop()\n    \n    def top(self):\n        return self.stack[-1]\n    \n    def getMin(self):\n        return self.min_stack[-1]\n\n# Approach 3: Single Stack with Difference Tracking\nclass MinStack:\n    def __init__(self):\n        self.stack = []\n        self.min_val = None\n    \n    def push(self, val):\n        if not self.stack:\n            self.stack.append(0)\n            self.min_val = val\n        else:\n            # Store difference from minimum\n            self.stack.append(val - self.min_val)\n            if val < self.min_val:\n                self.min_val = val\n    \n    def pop(self):\n        if self.stack:\n            popped = self.stack.pop()\n            if popped < 0:\n                # Restore previous minimum\n                self.min_val = self.min_val - popped\n    \n    def top(self):\n        top_diff = self.stack[-1]\n        if top_diff < 0:\n            return self.min_val\n        else:\n            return self.min_val + top_diff\n    \n    def getMin(self):\n        return self.min_val\n\n# Approach 4: Linked List Implementation\nclass ListNode:\n    def __init__(self, val, min_val, next_node=None):\n        self.val = val\n        self.min = min_val\n        self.next = next_node\n\nclass MinStack:\n    def __init__(self):\n        self.head = None\n    \n    def push(self, val):\n        if self.head is None:\n            self.head = ListNode(val, val)\n        else:\n            min_val = min(val, self.head.min)\n            self.head = ListNode(val, min_val, self.head)\n    \n    def pop(self):\n        self.head = self.head.next\n    \n    def top(self):\n        return self.head.val\n    \n    def getMin(self):\n        return self.head.min\n\n# Approach 5: Using Python List with Min Tracking\nclass MinStack:\n    def __init__(self):\n        self.data = []\n    \n    def push(self, val):\n        if not self.data:\n            self.data.append([val, val])\n        else:\n            self.data.append([val, min(val, self.data[-1][1])])\n    \n    def pop(self):\n        self.data.pop()\n    \n    def top(self):\n        return self.data[-1][0]\n    \n    def getMin(self):\n        return self.data[-1][1]\n\n# Usage example and testing\ndef test_min_stack():\n    # Test with Approach 1\n    min_stack = MinStack()\n    \n    min_stack.push(-2)\n    min_stack.push(0)\n    min_stack.push(-3)\n    \n    print(f\"getMin(): {min_stack.getMin()}\")  # -3\n    min_stack.pop()\n    print(f\"top(): {min_stack.top()}\")        # 0\n    print(f\"getMin(): {min_stack.getMin()}\")  # -2\n    \n    # Additional test cases\n    min_stack.push(-1)\n    print(f\"getMin(): {min_stack.getMin()}\")  # -2\n    print(f\"top(): {min_stack.top()}\")        # -1\n\ntest_min_stack()",
          "timeComplexity": "• **All operations**: O(1) constant time for push, pop, top, and getMin\n• **All approaches**: Maintain O(1) time complexity requirement",
          "spaceComplexity": "• **Stack with pairs**: O(n) storing value and min for each element\n• **Two stacks**: O(n) in worst case, O(1) amortized for min_stack\n• **Difference tracking**: O(n) for stack, O(1) additional space\n• **Linked list**: O(n) for nodes with min tracking",
          "keyInsights": "• The key insight is to track minimum at each stack level to handle pop operations\n• Storing pairs (value, min) is the most intuitive approach\n• Two stacks approach optimizes space by only storing mins when necessary\n• Difference tracking is space-efficient but more complex to implement\n• This pattern applies to other stack problems requiring auxiliary information",
          "link": "https://leetcode.com/problems/min-stack/"
        },
        {
          "id": "st_3",
          "title": "Evaluate Reverse Polish Notation",
          "routeName": "evaluate_reverse_polish_notation",
          "difficulty": "Medium",
          "leetcodeNumber": 150,
          "companies": ["Amazon", "Google", "Facebook", "LinkedIn"],
          "tags": ["Array", "Math", "Stack"],
          "description": "You are given an array of strings tokens that represents an arithmetic expression in Reverse Polish Notation.",
          "detailedDescription": "You are given an array of strings tokens that represents an arithmetic expression in Reverse Polish Notation.\n\nEvaluate the expression. Return an integer that represents the value of the expression.\n\nNote that:\n• The valid operators are '+', '-', '*', and '/'.\n• Each operand may be an integer or another expression.\n• The division between two integers always truncates toward zero.\n• There will not be any division by zero.\n• The input represents a valid arithmetic expression in a reverse polish notation.\n• The answer and all the intermediate calculations can be represented in a 32-bit integer.\n\nExample 1:\nInput: tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"]\nOutput: 9\nExplanation: ((2 + 1) * 3) = 9\n\nExample 2:\nInput: tokens = [\"4\",\"13\",\"5\",\"/\",\"+\"]\nOutput: 6\nExplanation: (4 + (13 / 5)) = 6\n\nExample 3:\nInput: tokens = [\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"]\nOutput: 22\nExplanation: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5 = 22\n\nConstraints:\n• 1 <= tokens.length <= 10^4\n• tokens[i] is either an operator: \"+\", \"-\", \"*\", or \"/\", or an integer in the range [-200, 200].",
          "approach": "Multiple approaches to solve this problem:\n\n1. **Stack with Operator Set**: Use stack and check if token is operator.\n\n2. **Stack with Try-Except**: Try to convert to int, handle operators in except.\n\n3. **Stack with Dictionary**: Use dictionary to map operators to functions.\n\n4. **Recursive Approach**: Recursively evaluate sub-expressions.",
          "solution": "**Approach 1: Stack with Operator Set (Most Common)**\nUse stack and predefined set of operators for evaluation.\n\n**Approach 2: Stack with Dictionary Mapping**\nMap operators to lambda functions for cleaner code.\n\n**Key Insight**: RPN evaluation naturally fits stack operations - operands go in, operators pop and compute.",
          "code": "# Approach 1: Stack with Operator Set (Most Efficient)\ndef evalRPN(tokens):\n    stack = []\n    operators = {'+', '-', '*', '/'}\n    \n    for token in tokens:\n        if token in operators:\n            # Pop two operands (order matters for - and /)\n            b = stack.pop()\n            a = stack.pop()\n            \n            if token == '+':\n                result = a + b\n            elif token == '-':\n                result = a - b\n            elif token == '*':\n                result = a * b\n            else:  # token == '/'\n                # Truncate toward zero\n                result = int(a / b)\n            \n            stack.append(result)\n        else:\n            # Token is a number\n            stack.append(int(token))\n    \n    return stack[0]\n\n# Approach 2: Stack with Dictionary Mapping\ndef evalRPN(tokens):\n    stack = []\n    \n    operations = {\n        '+': lambda a, b: a + b,\n        '-': lambda a, b: a - b,\n        '*': lambda a, b: a * b,\n        '/': lambda a, b: int(a / b)  # Truncate toward zero\n    }\n    \n    for token in tokens:\n        if token in operations:\n            b = stack.pop()\n            a = stack.pop()\n            result = operations[token](a, b)\n            stack.append(result)\n        else:\n            stack.append(int(token))\n    \n    return stack[0]\n\n# Approach 3: Using Try-Except\ndef evalRPN(tokens):\n    stack = []\n    \n    for token in tokens:\n        try:\n            # Try to convert to integer\n            num = int(token)\n            stack.append(num)\n        except ValueError:\n            # Token is an operator\n            b = stack.pop()\n            a = stack.pop()\n            \n            if token == '+':\n                stack.append(a + b)\n            elif token == '-':\n                stack.append(a - b)\n            elif token == '*':\n                stack.append(a * b)\n            elif token == '/':\n                stack.append(int(a / b))\n    \n    return stack[0]\n\n# Approach 4: More Explicit Division Handling\ndef evalRPN(tokens):\n    stack = []\n    \n    for token in tokens:\n        if token not in '+-*/':\n            stack.append(int(token))\n        else:\n            b, a = stack.pop(), stack.pop()\n            \n            if token == '+':\n                stack.append(a + b)\n            elif token == '-':\n                stack.append(a - b)\n            elif token == '*':\n                stack.append(a * b)\n            elif token == '/':\n                # Handle division with proper truncation\n                if a * b < 0 and a % b != 0:\n                    stack.append(a // b + 1)\n                else:\n                    stack.append(a // b)\n    \n    return stack[0]\n\n# Approach 5: Using operator module\nimport operator\n\ndef evalRPN(tokens):\n    stack = []\n    \n    ops = {\n        '+': operator.add,\n        '-': operator.sub,\n        '*': operator.mul,\n        '/': lambda a, b: int(operator.truediv(a, b))\n    }\n    \n    for token in tokens:\n        if token in ops:\n            b = stack.pop()\n            a = stack.pop()\n            stack.append(ops[token](a, b))\n        else:\n            stack.append(int(token))\n    \n    return stack[0]\n\n# Approach 6: Recursive Solution (Alternative)\ndef evalRPN(tokens):\n    def evaluate():\n        token = tokens.pop()\n        \n        if token in '+-*/':\n            b = evaluate()\n            a = evaluate()\n            \n            if token == '+':\n                return a + b\n            elif token == '-':\n                return a - b\n            elif token == '*':\n                return a * b\n            else:  # token == '/'\n                return int(a / b)\n        else:\n            return int(token)\n    \n    # Reverse tokens for proper order in recursion\n    tokens.reverse()\n    return evaluate()\n\n# Test cases\ntest_cases = [\n    [\"2\", \"1\", \"+\", \"3\", \"*\"],\n    [\"4\", \"13\", \"5\", \"/\", \"+\"],\n    [\"10\", \"6\", \"9\", \"3\", \"+\", \"-11\", \"*\", \"/\", \"*\", \"17\", \"+\", \"5\", \"+\"],\n    [\"18\"],\n    [\"-3\", \"4\", \"+\"]\n]\n\nfor tokens in test_cases:\n    result = evalRPN(tokens.copy())  # Use copy to preserve original\n    print(f\"tokens: {tokens} -> result: {result}\")",
          "timeComplexity": "O(n) where n is the number of tokens. Each token is processed exactly once.",
          "spaceComplexity": "O(n) in worst case when all tokens are operands, stack grows to size n.",
          "keyInsights": "• RPN evaluation is a perfect application of stack data structure\n• Each operator pops two operands and pushes one result back\n• Order matters when popping operands for non-commutative operations (- and /)\n• Python's division truncation toward zero requires int(a/b) not a//b for negative results\n• The final result is the only element left in the stack",
          "link": "https://leetcode.com/problems/evaluate-reverse-polish-notation/"
        },
        {
          "id": "st_4",
          "title": "Generate Parentheses",
          "routeName": "generate_parentheses",
          "difficulty": "Medium",
          "leetcodeNumber": 22,
          "companies": ["Google", "Amazon", "Facebook", "Microsoft"],
          "tags": ["String", "Dynamic Programming", "Backtracking"],
          "description": "Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.",
          "detailedDescription": "Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\n\nExample 1:\nInput: n = 3\nOutput: [\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\n\nExample 2:\nInput: n = 1\nOutput: [\"()\"]\n\nConstraints:\n• 1 <= n <= 8",
          "approach": "Multiple approaches to solve this problem:\n\n1. **Backtracking**: Build strings by adding '(' and ')' with constraints.\n\n2. **Dynamic Programming**: Build solutions from smaller subproblems.\n\n3. **BFS**: Use queue to generate all valid combinations level by level.\n\n4. **Recursive with Memoization**: Cache results for repeated subproblems.",
          "solution": "**Approach 1: Backtracking (Most Common)**\nRecursively build valid parentheses by tracking open and close counts.\n\n**Approach 2: Dynamic Programming**\nBuild solutions for n from solutions of smaller values.\n\n**Key Insight**: At any point, we can add '(' if we haven't used all n, and ')' if it won't make string invalid.",
          "code": "# Approach 1: Backtracking (Most Efficient)\ndef generateParenthesis(n):\n    result = []\n    \n    def backtrack(current_string, open_count, close_count):\n        # Base case: we've used all n pairs\n        if len(current_string) == 2 * n:\n            result.append(current_string)\n            return\n        \n        # Add opening parenthesis if we haven't used all n\n        if open_count < n:\n            backtrack(current_string + '(', open_count + 1, close_count)\n        \n        # Add closing parenthesis if it won't make string invalid\n        if close_count < open_count:\n            backtrack(current_string + ')', open_count, close_count + 1)\n    \n    backtrack('', 0, 0)\n    return result\n\n# Approach 2: Backtracking with Different Parameters\ndef generateParenthesis(n):\n    result = []\n    \n    def generate(s='', left=0, right=0):\n        if len(s) == 2 * n:\n            result.append(s)\n            return\n        \n        if left < n:\n            generate(s + '(', left + 1, right)\n        \n        if right < left:\n            generate(s + ')', left, right + 1)\n    \n    generate()\n    return result\n\n# Approach 3: Dynamic Programming\ndef generateParenthesis(n):\n    if n == 0:\n        return ['']\n    \n    dp = [[] for _ in range(n + 1)]\n    dp[0] = ['']\n    \n    for i in range(1, n + 1):\n        for j in range(i):\n            # For each way to split i pairs:\n            # j pairs inside first parentheses, (i-1-j) pairs after\n            for left in dp[j]:\n                for right in dp[i - 1 - j]:\n                    dp[i].append('(' + left + ')' + right)\n    \n    return dp[n]\n\n# Approach 4: BFS Approach\nfrom collections import deque\n\ndef generateParenthesis(n):\n    if n == 0:\n        return ['']\n    \n    queue = deque([('', 0, 0)])  # (current_string, open_count, close_count)\n    result = []\n    \n    while queue:\n        current, open_count, close_count = queue.popleft()\n        \n        if len(current) == 2 * n:\n            result.append(current)\n            continue\n        \n        # Add opening parenthesis\n        if open_count < n:\n            queue.append((current + '(', open_count + 1, close_count))\n        \n        # Add closing parenthesis\n        if close_count < open_count:\n            queue.append((current + ')', open_count, close_count + 1))\n    \n    return result\n\n# Approach 5: Recursive with Memoization\ndef generateParenthesis(n):\n    memo = {}\n    \n    def generate(remaining_open, remaining_close):\n        if remaining_open == 0 and remaining_close == 0:\n            return ['']\n        \n        if (remaining_open, remaining_close) in memo:\n            return memo[(remaining_open, remaining_close)]\n        \n        result = []\n        \n        # Add opening parenthesis\n        if remaining_open > 0:\n            for s in generate(remaining_open - 1, remaining_close):\n                result.append('(' + s)\n        \n        # Add closing parenthesis\n        if remaining_close > remaining_open:\n            for s in generate(remaining_open, remaining_close - 1):\n                result.append(')' + s)\n        \n        memo[(remaining_open, remaining_close)] = result\n        return result\n    \n    return generate(n, n)\n\n# Approach 6: Iterative with Stack\ndef generateParenthesis(n):\n    stack = [('', 0, 0)]  # (current_string, open_count, close_count)\n    result = []\n    \n    while stack:\n        current, open_count, close_count = stack.pop()\n        \n        if len(current) == 2 * n:\n            result.append(current)\n            continue\n        \n        # Add closing parenthesis first (due to stack LIFO)\n        if close_count < open_count:\n            stack.append((current + ')', open_count, close_count + 1))\n        \n        # Add opening parenthesis\n        if open_count < n:\n            stack.append((current + '(', open_count + 1, close_count))\n    \n    return result\n\n# Approach 7: Mathematical Approach using Catalan Numbers\ndef generateParenthesis(n):\n    if n == 0:\n        return ['']\n    \n    result = []\n    \n    for i in range(n):\n        # Split into i pairs inside first parentheses, n-1-i pairs outside\n        for left in generateParenthesis(i):\n            for right in generateParenthesis(n - 1 - i):\n                result.append('(' + left + ')' + right)\n    \n    return result\n\n# Test cases\ntest_cases = [1, 2, 3, 4]\n\nfor n in test_cases:\n    result = generateParenthesis(n)\n    print(f\"n = {n}:\")\n    for combo in result:\n        print(f\"  {combo}\")\n    print(f\"Total combinations: {len(result)}\\n\")",
          "timeComplexity": "• **Backtracking**: O(4^n / √n) which is the nth Catalan number\n• **Dynamic Programming**: O(4^n / √n) same complexity but with different constant factors\n• **BFS**: O(4^n / √n) same as backtracking but with queue overhead",
          "spaceComplexity": "• **Backtracking**: O(4^n / √n) for the result list + O(n) for recursion stack\n• **Dynamic Programming**: O(4^n / √n) for storing all intermediate results\n• **Memoization**: O(4^n / √n) for memoization table plus recursion stack",
          "keyInsights": "• This problem generates the nth Catalan number of combinations\n• Backtracking with constraints (open_count < n, close_count < open_count) ensures validity\n• Dynamic programming approach shows the recursive structure of the problem\n• The key insight is that at any position we can only add '(' or ')' based on current counts\n• This pattern applies to many constraint-based string generation problems",
          "link": "https://leetcode.com/problems/generate-parentheses/"
        },
        {
          "id": "st_5",
          "title": "Daily Temperatures",
          "routeName": "daily_temperatures",
          "difficulty": "Medium",
          "leetcodeNumber": 739,
          "companies": ["Amazon", "Google", "Facebook", "Microsoft"],
          "tags": ["Array", "Stack", "Monotonic Stack"],
          "description": "Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature.",
          "detailedDescription": "Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0.\n\nExample 1:\nInput: temperatures = [73,74,75,71,69,72,76,73]\nOutput: [1,1,4,2,1,1,0,0]\n\nExample 2:\nInput: temperatures = [30,40,50,60]\nOutput: [1,1,1,0]\n\nExample 3:\nInput: temperatures = [30,60,90]\nOutput: [1,1,0]\n\nConstraints:\n• 1 <= temperatures.length <= 10^5\n• 30 <= temperatures[i] <= 100",
          "approach": "Multiple approaches to solve this problem:\n\n1. **Monotonic Stack**: Use stack to store indices of decreasing temperatures.\n\n2. **Brute Force**: For each day, search forward for warmer temperature.\n\n3. **Backward Iteration**: Iterate backward and use precomputed results.\n\n4. **Hash Map with Stacks**: Group by temperature and use stacks for each.",
          "solution": "**Approach 1: Monotonic Stack (Optimal)**\nUse stack to maintain indices in decreasing order of temperatures.\n\n**Approach 2: Brute Force**\nFor each temperature, linearly search for next warmer day.\n\n**Key Insight**: Monotonic stack helps find the next greater element efficiently.",
          "code": "# Approach 1: Monotonic Stack (Most Efficient)\ndef dailyTemperatures(temperatures):\n    stack = []  # Store indices\n    result = [0] * len(temperatures)\n    \n    for i, temp in enumerate(temperatures):\n        # While current temp is warmer than temps at indices in stack\n        while stack and temperatures[stack[-1]] < temp:\n            prev_index = stack.pop()\n            result[prev_index] = i - prev_index\n        \n        stack.append(i)\n    \n    return result\n\n# Approach 2: Brute Force (Less Efficient)\ndef dailyTemperatures(temperatures):\n    result = [0] * len(temperatures)\n    \n    for i in range(len(temperatures)):\n        for j in range(i + 1, len(temperatures)):\n            if temperatures[j] > temperatures[i]:\n                result[i] = j - i\n                break\n    \n    return result\n\n# Approach 3: Backward Iteration with Optimization\ndef dailyTemperatures(temperatures):\n    n = len(temperatures)\n    result = [0] * n\n    \n    for i in range(n - 2, -1, -1):\n        j = i + 1\n        \n        # Use previously computed results to skip ahead\n        while j < n and temperatures[j] <= temperatures[i]:\n            if result[j] == 0:\n                j = n  # No warmer day exists\n            else:\n                j += result[j]\n        \n        if j < n:\n            result[i] = j - i\n    \n    return result\n\n# Approach 4: Stack with Explicit Temperature Checking\ndef dailyTemperatures(temperatures):\n    stack = []\n    answer = [0] * len(temperatures)\n    \n    for current_day, current_temp in enumerate(temperatures):\n        # Pop from stack while current temp is warmer\n        while stack and current_temp > temperatures[stack[-1]]:\n            prev_day = stack.pop()\n            answer[prev_day] = current_day - prev_day\n        \n        # Add current day to stack\n        stack.append(current_day)\n    \n    return answer\n\n# Approach 5: Using Deque (Alternative)\nfrom collections import deque\n\ndef dailyTemperatures(temperatures):\n    stack = deque()\n    result = [0] * len(temperatures)\n    \n    for i, temp in enumerate(temperatures):\n        while stack and temperatures[stack[-1]] < temp:\n            idx = stack.pop()\n            result[idx] = i - idx\n        stack.append(i)\n    \n    return result\n\n# Approach 6: Hash Map Approach (Less Efficient)\ndef dailyTemperatures(temperatures):\n    result = [0] * len(temperatures)\n    temp_to_indices = {}\n    \n    for i, temp in enumerate(temperatures):\n        # Check all lower temperatures and update their results\n        for t in range(30, temp):  # Temperature range constraint\n            if t in temp_to_indices:\n                while temp_to_indices[t]:\n                    idx = temp_to_indices[t].pop(0)\n                    if result[idx] == 0:  # Not yet found\n                        result[idx] = i - idx\n        \n        # Add current temperature and index\n        if temp not in temp_to_indices:\n            temp_to_indices[temp] = []\n        temp_to_indices[temp].append(i)\n    \n    return result\n\n# Optimized version with early termination\ndef dailyTemperatures(temperatures):\n    stack = []\n    result = [0] * len(temperatures)\n    \n    for i in range(len(temperatures)):\n        # Process all temperatures that are cooler than current\n        while stack and temperatures[i] > temperatures[stack[-1]]:\n            prev_idx = stack.pop()\n            result[prev_idx] = i - prev_idx\n        \n        stack.append(i)\n    \n    # Remaining elements in stack have no warmer future day (already 0)\n    return result\n\n# Test cases\ntest_cases = [\n    [73, 74, 75, 71, 69, 72, 76, 73],\n    [30, 40, 50, 60],\n    [30, 60, 90],\n    [89, 62, 70, 58, 47, 47, 46, 76, 100, 70]\n]\n\nfor temps in test_cases:\n    result = dailyTemperatures(temps)\n    print(f\"Temperatures: {temps}\")\n    print(f\"Days to wait: {result}\\n\")",
          "timeComplexity": "• **Monotonic Stack**: O(n) each element is pushed and popped at most once\n• **Brute Force**: O(n²) for each element, check all following elements\n• **Backward Iteration**: O(n) amortized, but can be O(n²) worst case",
          "spaceComplexity": "• **Monotonic Stack**: O(n) for the stack in worst case (decreasing sequence)\n• **Brute Force**: O(1) only using constant extra space\n• **All approaches**: O(n) for the result array",
          "keyInsights": "• Monotonic stack is perfect for 'next greater element' type problems\n• Stack stores indices in decreasing order of their temperatures\n• When we find a warmer temperature, it resolves all cooler temperatures in the stack\n• This pattern applies to many problems involving finding next/previous greater/smaller elements\n• The key insight is that we don't need to check all previous elements, only those that haven't found their answer yet",
          "link": "https://leetcode.com/problems/daily-temperatures/"
        },
        {
          "id": "st_6",
          "title": "Car Fleet",
          "routeName": "car_fleet",
          "difficulty": "Medium",
          "leetcodeNumber": 853,
          "companies": ["Amazon", "Google", "Apple", "Tesla"],
          "tags": ["Array", "Stack", "Sorting", "Monotonic Stack"],
          "description": "There are n cars going to the same destination along a one-lane road. The destination is target miles away.",
          "detailedDescription": "There are n cars going to the same destination along a one-lane road. The destination is target miles away.\n\nYou are given two integer arrays position and speed, both of length n, where position[i] is the position of the ith car and speed[i] is the speed of the ith car (in miles per hour).\n\nA car can never pass another car, but it can catch up and drive bumper to bumper at the same speed.\n\nThe faster car will slow down to match the slower car's speed. The distance between these two cars is ignored (i.e., they are assumed to have the same position).\n\nA car fleet is formed by cars that drive bumper to bumper at the same speed. Note that a single car is also a car fleet.\n\nReturn the number of car fleets that will arrive at the destination.\n\nExample 1:\nInput: target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]\nOutput: 3\nExplanation:\n- The cars starting at 10 (speed 2) and 8 (speed 4) become a fleet, meeting each other at 12. The fleet forms at the target.\n- The car starting at 0 (speed 1) is a fleet by itself.\n- The cars starting at 5 (speed 1) and 3 (speed 3) become a fleet, meeting each other at 6. The fleet moves at speed 1 until it reaches the target.\n\nExample 2:\nInput: target = 10, position = [3], speed = [3]\nOutput: 1\nExplanation: There is only one car, hence there is only one fleet.\n\nExample 3:\nInput: target = 100, position = [0,2,4], speed = [4,2,1]\nOutput: 1\nExplanation:\n- The cars starting at 0 (speed 4) and 2 (speed 2) become a fleet, meeting each other at 4. The fleet moves at speed 2.\n- Then, the fleet (speed 2) and the car starting at 4 (speed 1) become a fleet, meeting each other at 6. The fleet moves at speed 1 until it reaches the target.\n\nConstraints:\n• n == position.length == speed.length\n• 1 <= n <= 10^5\n• 0 < target <= 10^6\n• 0 <= position[i] < target\n• All the values of position are unique.\n• 0 < speed[i] <= 10^6",
          "approach": "Multiple approaches to solve this problem:\n\n1. **Stack with Time Calculation**: Calculate time to reach target, use stack to track fleets.\n\n2. **Sorting with Fleet Tracking**: Sort by position and track fleet formation.\n\n3. **Greedy Approach**: Process cars from right to left, counting independent fleets.\n\n4. **Simulation**: Simulate the movement until all cars reach target.",
          "solution": "**Approach 1: Stack with Time Calculation (Most Common)**\nCalculate time for each car to reach target, use stack to merge fleets.\n\n**Approach 2: Greedy with Fleet Counting**\nSort cars by position and count fleets by comparing arrival times.\n\n**Key Insight**: Cars behind can only catch up if they have a shorter time to target.",
          "code": "# Approach 1: Stack with Time Calculation (Most Efficient)\ndef carFleet(target, position, speed):\n    # Pair positions with speeds and sort by position\n    cars = sorted(zip(position, speed))\n    \n    # Calculate time to reach target for each car\n    times = [(target - pos) / spd for pos, spd in cars]\n    \n    # Use stack to track fleet formation\n    stack = []\n    \n    # Process cars from right to left (closest to target first)\n    for time in reversed(times):\n        # If current car takes longer to reach target than the car ahead,\n        # it forms a new fleet\n        if not stack or time > stack[-1]:\n            stack.append(time)\n        # Otherwise, it catches up and joins the fleet ahead\n    \n    return len(stack)\n\n# Approach 2: Greedy without Stack\ndef carFleet(target, position, speed):\n    cars = sorted(zip(position, speed))\n    times = [(target - pos) / spd for pos, spd in cars]\n    \n    fleets = 0\n    current_time = 0\n    \n    # Process from rightmost car (closest to target)\n    for time in reversed(times):\n        if time > current_time:\n            fleets += 1\n            current_time = time\n    \n    return fleets\n\n# Approach 3: More Explicit Implementation\ndef carFleet(target, position, speed):\n    if not position:\n        return 0\n    \n    # Create list of (position, time_to_target)\n    cars = []\n    for i in range(len(position)):\n        time_to_target = (target - position[i]) / speed[i]\n        cars.append((position[i], time_to_target))\n    \n    # Sort by position (descending, closest to target first)\n    cars.sort(reverse=True)\n    \n    fleets = 0\n    prev_time = 0\n    \n    for pos, time in cars:\n        # If this car takes longer than previous, it starts a new fleet\n        if time > prev_time:\n            fleets += 1\n            prev_time = time\n    \n    return fleets\n\n# Approach 4: Using Stack with Detailed Logic\ndef carFleet(target, position, speed):\n    # Edge case\n    if not position:\n        return 0\n    \n    # Combine and sort by position\n    cars = list(zip(position, speed))\n    cars.sort()\n    \n    stack = []\n    \n    for pos, spd in cars:\n        # Calculate time to reach target\n        time = (target - pos) / spd\n        \n        # If stack is empty or current car is slower than the fleet ahead\n        if not stack or time > stack[-1]:\n            stack.append(time)\n        # Else, current car catches up with the fleet ahead\n    \n    return len(stack)\n\n# Approach 5: Simulation Approach (Less Efficient)\ndef carFleet(target, position, speed):\n    cars = list(zip(position, speed))\n    cars.sort()\n    \n    fleets = []\n    \n    for pos, spd in cars:\n        time = (target - pos) / spd\n        \n        # Check if this car can catch up with any existing fleet\n        caught_up = False\n        for i, fleet_time in enumerate(fleets):\n            if time <= fleet_time:\n                caught_up = True\n                break\n        \n        if not caught_up:\n            fleets.append(time)\n    \n    return len(fleets)\n\n# Approach 6: Dictionary-based Grouping\ndef carFleet(target, position, speed):\n    from collections import defaultdict\n    \n    # Group cars by their arrival time\n    time_groups = defaultdict(list)\n    \n    for pos, spd in zip(position, speed):\n        time = (target - pos) / spd\n        time_groups[time].append(pos)\n    \n    # Sort times in descending order\n    sorted_times = sorted(time_groups.keys(), reverse=True)\n    \n    fleets = 0\n    last_time = float('inf')\n    \n    for time in sorted_times:\n        if time < last_time:\n            fleets += 1\n            last_time = time\n    \n    return fleets\n\n# Test cases\ntest_cases = [\n    (12, [10, 8, 0, 5, 3], [2, 4, 1, 1, 3]),\n    (10, [3], [3]),\n    (100, [0, 2, 4], [4, 2, 1]),\n    (10, [6, 8], [3, 2]),\n    (13, [10, 2, 5, 7, 4, 6, 11], [7, 5, 10, 5, 9, 4, 1])\n]\n\nfor target, positions, speeds in test_cases:\n    result = carFleet(target, positions, speeds)\n    print(f\"Target: {target}, Positions: {positions}, Speeds: {speeds}\")\n    print(f\"Number of fleets: {result}\\n\")",
          "timeComplexity": "• **Stack approach**: O(n log n) for sorting + O(n) for processing = O(n log n)\n• **All approaches**: Dominated by sorting step which is O(n log n)",
          "spaceComplexity": "• **Stack approach**: O(n) for storing cars and times\n• **Greedy approach**: O(n) for storing car data\n• **All approaches**: O(n) space complexity",
          "keyInsights": "• Key insight: cars can only catch up if they have shorter time to reach target\n• Sorting by position is crucial to process cars in correct order\n• Stack naturally handles fleet merging - slower cars join faster fleets ahead\n• A car forms a new fleet only if it takes longer to reach target than the car/fleet ahead\n• This problem demonstrates how stack can model real-world scenarios with constraints",
          "link": "https://leetcode.com/problems/car-fleet/"
        },
        {
          "id": "st_7",
          "title": "Largest Rectangle in Histogram",
          "routeName": "largest_rectangle_in_histogram",
          "difficulty": "Hard",
          "leetcodeNumber": 84,
          "companies": ["Google", "Amazon", "Facebook", "Microsoft"],
          "tags": ["Array", "Stack", "Monotonic Stack"],
          "description": "Given an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.",
          "detailedDescription": "Given an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.\n\nExample 1:\nInput: heights = [2,1,5,6,2,3]\nOutput: 10\nExplanation: The above is a histogram where width of each bar is 1.\nThe largest rectangle is shown in the red area, which has an area = 10 units.\n\nExample 2:\nInput: heights = [2,4]\nOutput: 4\n\nConstraints:\n• 1 <= heights.length <= 10^5\n• 0 <= heights[i] <= 10^4",
          "approach": "Multiple approaches to solve this problem:\n\n1. **Monotonic Stack**: Use stack to find left and right boundaries for each bar.\n\n2. **Stack with Sentinel**: Add sentinel value to handle remaining stack elements.\n\n3. **Divide and Conquer**: Recursively find maximum in left and right subarrays.\n\n4. **Brute Force**: For each bar, find maximum rectangle with that bar as height.",
          "solution": "**Approach 1: Monotonic Stack (Optimal)**\nUse stack to maintain increasing heights and calculate area when popping.\n\n**Approach 2: Stack with Left/Right Arrays**\nPrecompute left and right boundaries for each bar.\n\n**Key Insight**: For each bar, find the maximum rectangle with that bar as the shortest bar.",
          "code": "# Approach 1: Monotonic Stack (Most Efficient)\ndef largestRectangleArea(heights):\n    stack = []\n    max_area = 0\n    \n    for i, height in enumerate(heights + [0]):  # Add sentinel\n        # While current height is smaller than stack top\n        while stack and heights[stack[-1]] > height:\n            h = heights[stack.pop()]  # Height of rectangle\n            \n            # Width calculation\n            w = i if not stack else i - stack[-1] - 1\n            \n            max_area = max(max_area, h * w)\n        \n        stack.append(i)\n    \n    return max_area\n\n# Approach 2: Stack without Sentinel\ndef largestRectangleArea(heights):\n    stack = []\n    max_area = 0\n    index = 0\n    \n    while index < len(heights):\n        # If current bar is higher than stack top, push it\n        if not stack or heights[index] >= heights[stack[-1]]:\n            stack.append(index)\n            index += 1\n        else:\n            # Pop the top and calculate area\n            top = stack.pop()\n            area = (heights[top] * \n                   ((index - stack[-1] - 1) if stack else index))\n            max_area = max(max_area, area)\n    \n    # Pop remaining bars from stack\n    while stack:\n        top = stack.pop()\n        area = (heights[top] * \n               ((index - stack[-1] - 1) if stack else index))\n        max_area = max(max_area, area)\n    \n    return max_area\n\n# Approach 3: Precompute Left and Right Boundaries\ndef largestRectangleArea(heights):\n    n = len(heights)\n    left = [0] * n   # left[i] = index of first bar to left with height < heights[i]\n    right = [0] * n  # right[i] = index of first bar to right with height < heights[i]\n    \n    # Fill left array\n    left[0] = -1\n    for i in range(1, n):\n        j = i - 1\n        while j >= 0 and heights[j] >= heights[i]:\n            j = left[j]\n        left[i] = j\n    \n    # Fill right array\n    right[n - 1] = n\n    for i in range(n - 2, -1, -1):\n        j = i + 1\n        while j < n and heights[j] >= heights[i]:\n            j = right[j]\n        right[i] = j\n    \n    # Calculate maximum area\n    max_area = 0\n    for i in range(n):\n        width = right[i] - left[i] - 1\n        area = heights[i] * width\n        max_area = max(max_area, area)\n    \n    return max_area\n\n# Approach 4: Divide and Conquer\ndef largestRectangleArea(heights):\n    def divide_conquer(left, right):\n        if left > right:\n            return 0\n        \n        # Find minimum height index in range\n        min_index = left\n        for i in range(left, right + 1):\n            if heights[i] < heights[min_index]:\n                min_index = i\n        \n        # Maximum area is max of:\n        # 1. Rectangle with min height spanning entire range\n        # 2. Max rectangle in left subarray\n        # 3. Max rectangle in right subarray\n        return max(\n            heights[min_index] * (right - left + 1),\n            divide_conquer(left, min_index - 1),\n            divide_conquer(min_index + 1, right)\n        )\n    \n    return divide_conquer(0, len(heights) - 1)\n\n# Approach 5: Brute Force (For Understanding)\ndef largestRectangleArea(heights):\n    max_area = 0\n    \n    for i in range(len(heights)):\n        min_height = heights[i]\n        for j in range(i, len(heights)):\n            min_height = min(min_height, heights[j])\n            width = j - i + 1\n            area = min_height * width\n            max_area = max(max_area, area)\n    \n    return max_area\n\n# Approach 6: Stack with Clear Logic\ndef largestRectangleArea(heights):\n    stack = [-1]  # Start with sentinel\n    max_area = 0\n    \n    for i in range(len(heights)):\n        # Maintain increasing stack\n        while stack[-1] != -1 and heights[stack[-1]] >= heights[i]:\n            height = heights[stack.pop()]\n            width = i - stack[-1] - 1\n            max_area = max(max_area, height * width)\n        \n        stack.append(i)\n    \n    # Process remaining elements\n    while stack[-1] != -1:\n        height = heights[stack.pop()]\n        width = len(heights) - stack[-1] - 1\n        max_area = max(max_area, height * width)\n    \n    return max_area\n\n# Approach 7: Using Deque\nfrom collections import deque\n\ndef largestRectangleArea(heights):\n    stack = deque()\n    max_area = 0\n    \n    for i, h in enumerate(heights + [0]):\n        while stack and heights[stack[-1]] > h:\n            height = heights[stack.pop()]\n            width = i if not stack else i - stack[-1] - 1\n            max_area = max(max_area, height * width)\n        stack.append(i)\n    \n    return max_area\n\n# Test cases\ntest_cases = [\n    [2, 1, 5, 6, 2, 3],\n    [2, 4],\n    [1, 1, 1, 1],\n    [2, 1, 2],\n    [5, 4, 1, 2],\n    [1],\n    [0, 0, 0]\n]\n\nfor heights in test_cases:\n    result = largestRectangleArea(heights)\n    print(f\"Heights: {heights} -> Largest area: {result}\")",
          "timeComplexity": "• **Monotonic Stack**: O(n) each element is pushed and popped at most once\n• **Precompute boundaries**: O(n) amortized for left/right array computation\n• **Divide and Conquer**: O(n log n) average, O(n²) worst case\n• **Brute Force**: O(n²) checking all possible rectangles",
          "spaceComplexity": "• **Monotonic Stack**: O(n) for the stack in worst case\n• **Precompute boundaries**: O(n) for left and right arrays\n• **Divide and Conquer**: O(log n) for recursion stack\n• **Brute Force**: O(1) only using variables",
          "keyInsights": "• Monotonic stack is perfect for finding nearest smaller/larger elements\n• For each bar, we want to find the maximum rectangle with that bar as the shortest\n• Stack maintains increasing heights; when we pop, we found the rectangle boundary\n• Adding sentinel value (0) at the end ensures all bars are processed\n• This is a classic application of monotonic stack for geometric problems",
          "link": "https://leetcode.com/problems/largest-rectangle-in-histogram/"
        }
      ]
    },
    {
      "id": "strings",
      "title": "Strings",
      "description": "String manipulation, pattern matching, and text processing problems",
      "questions": [
        {
          "id": "str_1",
          "title": "Reverse a String",
          "routeName": "reverse_a_string",
          "difficulty": "Easy",
          "companies": ["Google", "Microsoft", "Amazon"],
          "tags": ["String", "Two Pointers"],
          "description": "Write a function that reverses a string. You may assume the string consists of only lowercase English letters.",
          "detailedDescription": "Given a string s, reverse the string and return it. The reversal should be done in-place if possible, but you can also create a new string.\n\nExample 1:\nInput: s = \"hello\"\nOutput: \"olleh\"\n\nExample 2:\nInput: s = \"abcdef\"\nOutput: \"fedcba\"\n\nConstraints:\n• 1 <= s.length <= 10^5\n• s consists of printable ASCII characters",
          "approach": "Multiple approaches can be used:\n\n1. **Two Pointers Approach**: Use two pointers from start and end, swap characters while moving towards center.\n\n2. **Built-in Methods**: Use language built-in reverse methods (Python: s[::-1], Java: StringBuilder.reverse()).\n\n3. **Stack Approach**: Push all characters to stack and pop them to get reversed string.\n\n4. **Recursive Approach**: Recursively reverse substring and append first character at the end.",
          "solution": "**Approach 1: Two Pointers (In-place for mutable strings)**\n\nThis approach uses two pointers to swap characters from both ends moving towards the center.\n\n**Approach 2: Python Slicing (Most Pythonic)**\n\nPython's slicing feature provides the most concise solution.\n\n**Approach 3: Using Built-in Reverse**\n\nConvert to list, reverse, and join back to string.",
          "code": "# Approach 1: Two Pointers (if string was mutable)\ndef reverse_string_two_pointers(s):\n    chars = list(s)  # Convert to mutable list\n    left, right = 0, len(chars) - 1\n    \n    while left < right:\n        # Swap characters\n        chars[left], chars[right] = chars[right], chars[left]\n        left += 1\n        right -= 1\n    \n    return ''.join(chars)\n\n# Approach 2: Python Slicing (Most Pythonic)\ndef reverse_string_slicing(s):\n    return s[::-1]\n\n# Approach 3: Using Built-in Reverse\ndef reverse_string_builtin(s):\n    return ''.join(reversed(s))\n\n# Approach 4: Recursive\ndef reverse_string_recursive(s):\n    if len(s) <= 1:\n        return s\n    return reverse_string_recursive(s[1:]) + s[0]\n\n# Test the functions\ntest_cases = [\"hello\", \"abcdef\", \"a\", \"\"]\nfor test in test_cases:\n    print(f\"Input: '{test}' -> Output: '{reverse_string_slicing(test)}'\")",
          "timeComplexity": "O(n) where n is the length of the string. We need to process each character once.",
          "spaceComplexity": "• **Two Pointers**: O(n) for creating the character list\n• **Slicing**: O(n) for creating the new reversed string\n• **Built-in**: O(n) for the result string\n• **Recursive**: O(n) for recursion stack space",
          "keyInsights": "• String reversal is a fundamental operation in many algorithms\n• Two pointers technique is efficient for in-place operations\n• Python slicing ([::-1]) is the most concise and readable\n• Consider memory constraints when choosing between approaches\n• This pattern appears in palindrome problems and string manipulation",
          "link": ""
        },
        {
          "id": "str_2",
          "title": "Valid Anagram",
          "routeName": "valid_anagram",
          "difficulty": "Easy",
          "companies": ["Facebook", "Amazon", "Netflix"],
          "tags": ["String", "Hash Table", "Sorting"],
          "description": "Given two strings s and t, return true if t is an anagram of s, and false otherwise.",
          "detailedDescription": "An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n\nExample 1:\nInput: s = \"anagram\", t = \"nagaram\"\nOutput: true\n\nExample 2:\nInput: s = \"rat\", t = \"car\"\nOutput: false\n\nConstraints:\n• 1 <= s.length, t.length <= 5 * 10^4\n• s and t consist of lowercase English letters",
          "approach": "Several approaches to solve this problem:\n\n1. **Sorting Approach**: Sort both strings and compare if they are equal.\n\n2. **Hash Map/Counter**: Count frequency of each character in both strings and compare.\n\n3. **Array Counting**: Use array of size 26 for lowercase letters to count frequencies.\n\n4. **Character Cancellation**: Increment count for characters in first string, decrement for second string, check if all counts are zero.",
          "solution": "**Approach 1: Sorting**\nSort both strings and check if they are identical.\n\n**Approach 2: Hash Map (Counter)**\nCount character frequencies and compare the frequency maps.\n\n**Approach 3: Array Counting**\nUse a fixed-size array to count character frequencies for better space efficiency.\n\n**Approach 4: Single Pass with Counter**\nIncrement counter for first string, decrement for second string.",
          "code": "from collections import Counter\n\n# Approach 1: Sorting\ndef is_anagram_sorting(s, t):\n    if len(s) != len(t):\n        return False\n    return sorted(s) == sorted(t)\n\n# Approach 2: Hash Map (Counter)\ndef is_anagram_counter(s, t):\n    if len(s) != len(t):\n        return False\n    return Counter(s) == Counter(t)\n\n# Approach 3: Array Counting (most efficient)\ndef is_anagram_array(s, t):\n    if len(s) != len(t):\n        return False\n    \n    # Array for 26 lowercase letters\n    char_count = [0] * 26\n    \n    for i in range(len(s)):\n        char_count[ord(s[i]) - ord('a')] += 1\n        char_count[ord(t[i]) - ord('a')] -= 1\n    \n    return all(count == 0 for count in char_count)\n\n# Approach 4: Manual Counter\ndef is_anagram_manual(s, t):\n    if len(s) != len(t):\n        return False\n    \n    char_count = {}\n    \n    # Count characters in s\n    for char in s:\n        char_count[char] = char_count.get(char, 0) + 1\n    \n    # Subtract characters in t\n    for char in t:\n        if char not in char_count:\n            return False\n        char_count[char] -= 1\n        if char_count[char] == 0:\n            del char_count[char]\n    \n    return len(char_count) == 0\n\n# Test the functions\ntest_cases = [\n    (\"anagram\", \"nagaram\"),\n    (\"rat\", \"car\"),\n    (\"listen\", \"silent\"),\n    (\"a\", \"ab\")\n]\n\nfor s, t in test_cases:\n    result = is_anagram_array(s, t)\n    print(f\"'{s}' and '{t}': {result}\")",
          "timeComplexity": "• **Sorting**: O(n log n) where n is the length of the strings\n• **Hash Map**: O(n) to iterate through both strings\n• **Array Counting**: O(n) with better constants than hash map\n• **Manual Counter**: O(n) average case",
          "spaceComplexity": "• **Sorting**: O(1) if sorting in-place, O(n) otherwise\n• **Hash Map**: O(n) for storing character counts\n• **Array Counting**: O(1) since array size is fixed (26)\n• **Manual Counter**: O(n) in worst case for the hash map",
          "keyInsights": "• Anagram problems often involve character frequency analysis\n• Array counting is most efficient for lowercase English letters\n• Early termination (length check) can save computation\n• Hash maps provide flexibility for Unicode characters\n• This pattern is useful for grouping anagrams and string comparison problems",
          "link": ""
        },
        {
          "id": "str_3",
          "title": "Longest Substring Without Repeating Characters",
          "routeName": "longest_substring_without_repeating_characters",
          "difficulty": "Medium",
          "companies": ["Amazon", "Bloomberg", "Yelp"],
          "tags": ["String", "Sliding Window", "Hash Table"],
          "description": "Given a string s, find the length of the longest substring without repeating characters.",
          "detailedDescription": "Given a string s, find the length of the longest substring without repeating characters.\n\nExample 1:\nInput: s = \"abcabcbb\"\nOutput: 3\nExplanation: The answer is \"abc\", with the length of 3.\n\nExample 2:\nInput: s = \"bbbbb\"\nOutput: 1\nExplanation: The answer is \"b\", with the length of 1.\n\nExample 3:\nInput: s = \"pwwkew\"\nOutput: 3\nExplanation: The answer is \"wke\", with the length of 3.\n\nConstraints:\n• 0 <= s.length <= 5 * 10^4\n• s consists of English letters, digits, symbols and spaces",
          "approach": "This is a classic sliding window problem:\n\n1. **Sliding Window with Hash Set**: Use two pointers and a set to track characters in current window.\n\n2. **Sliding Window with Hash Map**: Store character positions to skip ahead when duplicate is found.\n\n3. **Optimized Sliding Window**: Use hash map to store the latest index of each character for efficient skipping.\n\n4. **Brute Force**: Check all possible substrings (not recommended for large inputs).",
          "solution": "**Sliding Window Technique**\n\nThe key insight is to use a sliding window that expands when no duplicates are found and contracts when a duplicate is encountered.\n\n**Approach 1: Sliding Window with Set**\nMaintain a set of characters in the current window and two pointers.\n\n**Approach 2: Optimized with Hash Map**\nStore the index of each character to jump directly to the position after the duplicate.",
          "code": "# Approach 1: Sliding Window with Set\ndef length_of_longest_substring_set(s):\n    if not s:\n        return 0\n    \n    char_set = set()\n    left = 0\n    max_length = 0\n    \n    for right in range(len(s)):\n        # Shrink window until no duplicate\n        while s[right] in char_set:\n            char_set.remove(s[left])\n            left += 1\n        \n        # Add current character and update max length\n        char_set.add(s[right])\n        max_length = max(max_length, right - left + 1)\n    \n    return max_length\n\n# Approach 2: Optimized Sliding Window with Hash Map\ndef length_of_longest_substring_map(s):\n    if not s:\n        return 0\n    \n    char_index = {}  # Maps character to its latest index\n    left = 0\n    max_length = 0\n    \n    for right in range(len(s)):\n        char = s[right]\n        \n        # If character is already in window, move left pointer\n        if char in char_index and char_index[char] >= left:\n            left = char_index[char] + 1\n        \n        # Update character's latest index\n        char_index[char] = right\n        \n        # Update max length\n        max_length = max(max_length, right - left + 1)\n    \n    return max_length\n\n# Approach 3: Clean implementation with defaultdict\nfrom collections import defaultdict\n\ndef length_of_longest_substring_clean(s):\n    char_index = defaultdict(lambda: -1)\n    left = 0\n    max_length = 0\n    \n    for right, char in enumerate(s):\n        # Move left pointer if character was seen in current window\n        left = max(left, char_index[char] + 1)\n        \n        # Update max length and character index\n        max_length = max(max_length, right - left + 1)\n        char_index[char] = right\n    \n    return max_length\n\n# Test the functions\ntest_cases = [\n    \"abcabcbb\",\n    \"bbbbb\", \n    \"pwwkew\",\n    \"\",\n    \"dvdf\",\n    \"anviaj\"\n]\n\nfor test in test_cases:\n    result = length_of_longest_substring_map(test)\n    print(f\"Input: '{test}' -> Length: {result}\")",
          "timeComplexity": "O(n) where n is the length of the string. Each character is visited at most twice (once by right pointer, once by left pointer).",
          "spaceComplexity": "• **Set approach**: O(min(m, n)) where m is the size of the character set\n• **Hash Map approach**: O(min(m, n)) for storing character indices\n• In practice, for ASCII characters, space is O(1) since there are at most 128 unique characters",
          "keyInsights": "• Sliding window is perfect for contiguous substring problems\n• Hash map optimization reduces time complexity by avoiding unnecessary character removal\n• The key insight is to jump the left pointer directly instead of moving it one by one\n• This pattern applies to many substring problems with constraints\n• Understanding when to expand vs contract the window is crucial",
          "link": ""
        },
        {
          "id": "str_4",
          "title": "Valid Palindrome",
          "routeName": "valid_palindrome",
          "difficulty": "Easy",
          "companies": ["Facebook", "Microsoft", "Apple"],
          "tags": ["String", "Two Pointers"],
          "description": "A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward.",
          "detailedDescription": "A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.\n\nGiven a string s, return true if it is a palindrome, or false otherwise.\n\nExample 1:\nInput: s = \"A man, a plan, a canal: Panama\"\nOutput: true\nExplanation: \"amanaplanacanalpanama\" is a palindrome.\n\nExample 2:\nInput: s = \"race a car\"\nOutput: false\nExplanation: \"raceacar\" is not a palindrome.\n\nExample 3:\nInput: s = \" \"\nOutput: true\nExplanation: s is an empty string \"\" after removing non-alphanumeric characters.\n\nConstraints:\n• 1 <= s.length <= 2 * 10^5\n• s consists only of printable ASCII characters",
          "approach": "Multiple approaches to solve this problem:\n\n1. **Two Pointers**: Clean the string first, then use two pointers from both ends.\n\n2. **Two Pointers with On-the-fly Cleaning**: Skip non-alphanumeric characters while comparing.\n\n3. **Reverse and Compare**: Clean the string, reverse it, and compare with original.\n\n4. **Recursive**: Clean the string and use recursion to check palindrome property.",
          "solution": "**Approach 1: Two Pointers with Preprocessing**\nFirst clean the string by removing non-alphanumeric characters and converting to lowercase, then use two pointers.\n\n**Approach 2: Two Pointers with On-the-fly Processing**\nUse two pointers and skip invalid characters during comparison.\n\n**Approach 3: Built-in Methods**\nUse Python's built-in methods for cleaning and comparison.",
          "code": "import re\n\n# Approach 1: Two Pointers with Preprocessing\ndef is_palindrome_preprocess(s):\n    # Clean the string: keep only alphanumeric and convert to lowercase\n    cleaned = ''.join(char.lower() for char in s if char.isalnum())\n    \n    # Two pointers approach\n    left, right = 0, len(cleaned) - 1\n    \n    while left < right:\n        if cleaned[left] != cleaned[right]:\n            return False\n        left += 1\n        right -= 1\n    \n    return True\n\n# Approach 2: Two Pointers with On-the-fly Processing (Most Efficient)\ndef is_palindrome_optimal(s):\n    left, right = 0, len(s) - 1\n    \n    while left < right:\n        # Skip non-alphanumeric characters from left\n        while left < right and not s[left].isalnum():\n            left += 1\n        \n        # Skip non-alphanumeric characters from right\n        while left < right and not s[right].isalnum():\n            right -= 1\n        \n        # Compare characters (case-insensitive)\n        if s[left].lower() != s[right].lower():\n            return False\n        \n        left += 1\n        right -= 1\n    \n    return True\n\n# Approach 3: Using Regular Expressions\ndef is_palindrome_regex(s):\n    # Remove non-alphanumeric characters and convert to lowercase\n    cleaned = re.sub(r'[^a-zA-Z0-9]', '', s).lower()\n    return cleaned == cleaned[::-1]\n\n# Approach 4: Functional Programming Style\ndef is_palindrome_functional(s):\n    chars = [char.lower() for char in s if char.isalnum()]\n    return chars == chars[::-1]\n\n# Approach 5: Using filter and join\ndef is_palindrome_filter(s):\n    alphanumeric = ''.join(filter(str.isalnum, s)).lower()\n    return alphanumeric == alphanumeric[::-1]\n\n# Test the functions\ntest_cases = [\n    \"A man, a plan, a canal: Panama\",\n    \"race a car\",\n    \" \",\n    \"Madam\",\n    \"No 'x' in Nixon\",\n    \"Was it a car or a cat I saw?\"\n]\n\nfor test in test_cases:\n    result = is_palindrome_optimal(test)\n    print(f\"'{test}' -> {result}\")",
          "timeComplexity": "• **Preprocessing approach**: O(n) for cleaning + O(n) for checking = O(n)\n• **On-the-fly approach**: O(n) single pass through the string\n• **Regex approach**: O(n) for regex processing + O(n) for comparison = O(n)\nwhere n is the length of the input string.",
          "spaceComplexity": "• **Preprocessing approach**: O(n) for storing the cleaned string\n• **On-the-fly approach**: O(1) only using two pointers\n• **Regex approach**: O(n) for storing cleaned string\n• **Functional approach**: O(n) for storing the character list",
          "keyInsights": "• Two pointers technique is ideal for palindrome problems\n• On-the-fly processing saves memory by avoiding string preprocessing\n• Case-insensitive comparison requires careful handling\n• Regular expressions provide clean but potentially slower solutions\n• The pattern of skipping invalid characters while maintaining two pointers is reusable\n• Consider memory constraints when choosing between preprocessing vs on-the-fly approaches",
          "link": ""
        }
      ]
    },
    {
      "id": "searching",
      "title": "Searching",
      "description": "Binary search, linear search, and search optimization techniques",
      "questions": [
        {
          "id": "search_1",
          "title": "Binary Search",
          "routeName": "binary_search",
          "difficulty": "Easy",
          "companies": ["Google", "Facebook", "Microsoft"],
          "tags": ["Array", "Binary Search"],
          "description": "Implement binary search algorithm.",
          "link": ""
        },
        {
          "id": "search_2",
          "title": "Search in Rotated Sorted Array",
          "routeName": "search_in_rotated_sorted_array",
          "difficulty": "Medium",
          "companies": ["Facebook", "Microsoft", "Amazon"],
          "tags": ["Array", "Binary Search"],
          "description": "Search for a target value in a rotated sorted array.",
          "link": ""
        },
        {
          "id": "search_3",
          "title": "Find First and Last Position",
          "routeName": "find_first_and_last_position",
          "difficulty": "Medium",
          "companies": ["Google", "Amazon", "Bloomberg"],
          "tags": ["Array", "Binary Search"],
          "description": "Find first and last position of element in sorted array.",
          "link": ""
        }
      ]
    },
    {
      "id": "sorting",
      "title": "Sorting",
      "description": "Sorting algorithms and related problems",
      "questions": [
        {
          "id": "sort_1",
          "title": "Merge Sort",
          "routeName": "merge_sort",
          "difficulty": "Medium",
          "companies": ["Microsoft", "Amazon", "Apple"],
          "tags": ["Array", "Divide and Conquer", "Sorting"],
          "description": "Implement merge sort algorithm.",
          "link": ""
        },
        {
          "id": "sort_2",
          "title": "Quick Sort",
          "routeName": "quick_sort",
          "difficulty": "Medium",
          "companies": ["Google", "Facebook", "Netflix"],
          "tags": ["Array", "Divide and Conquer", "Sorting"],
          "description": "Implement quick sort algorithm.",
          "link": ""
        },
        {
          "id": "sort_3",
          "title": "Sort Colors",
          "routeName": "sort_colors",
          "difficulty": "Medium",
          "companies": ["Microsoft", "Facebook", "Amazon"],
          "tags": ["Array", "Two Pointers", "Sorting"],
          "description": "Sort an array with 0s, 1s, and 2s.",
          "link": ""
        }
      ]
    },
    {
      "id": "loops",
      "title": "Loops",
      "description": "Loop optimization and iteration problems",
      "questions": [
        {
          "id": "loop_1",
          "title": "FizzBuzz",
          "routeName": "fizzbuzz",
          "difficulty": "Easy",
          "companies": ["Amazon", "Microsoft", "Apple"],
          "tags": ["Math", "String"],
          "description": "Print numbers 1 to n, but for multiples of 3 print Fizz, for multiples of 5 print Buzz.",
          "link": ""
        },
        {
          "id": "loop_2",
          "title": "Power of Two",
          "routeName": "power_of_two",
          "difficulty": "Easy",
          "companies": ["Google", "Amazon", "Adobe"],
          "tags": ["Math", "Bit Manipulation"],
          "description": "Determine if a number is a power of two.",
          "link": ""
        }
      ]
    },
    {
      "id": "2d-array",
      "title": "2D Arrays",
      "description": "Matrix operations and 2D array problems",
      "questions": [
        {
          "id": "2d_1",
          "title": "Rotate Image",
          "routeName": "rotate_image",
          "difficulty": "Medium",
          "companies": ["Amazon", "Apple", "Microsoft"],
          "tags": ["Array", "Math", "Matrix"],
          "description": "Rotate an n x n 2D matrix by 90 degrees clockwise.",
          "link": ""
        },
        {
          "id": "2d_2",
          "title": "Spiral Matrix",
          "routeName": "spiral_matrix",
          "difficulty": "Medium",
          "companies": ["Microsoft", "Amazon", "Facebook"],
          "tags": ["Array", "Matrix", "Simulation"],
          "description": "Return all elements of matrix in spiral order.",
          "link": ""
        },
        {
          "id": "2d_3",
          "title": "Set Matrix Zeroes",
          "routeName": "set_matrix_zeroes",
          "difficulty": "Medium",
          "companies": ["Microsoft", "Amazon", "Apple"],
          "tags": ["Array", "Hash Table", "Matrix"],
          "description": "Set entire row and column to 0 if an element is 0.",
          "link": ""
        }
      ]
    },
    {
      "id": "patterns",
      "title": "Patterns",
      "description": "Common algorithmic patterns and techniques",
      "questions": [
        {
          "id": "pattern_1",
          "title": "Sliding Window Maximum",
          "routeName": "sliding_window_maximum",
          "difficulty": "Hard",
          "companies": ["Amazon", "Google", "Facebook"],
          "tags": ["Array", "Queue", "Sliding Window", "Heap"],
          "description": "Find the maximum element in each sliding window of size k.",
          "link": ""
        },
        {
          "id": "pattern_2",
          "title": "Two Pointers Pattern",
          "routeName": "two_pointers_pattern",
          "difficulty": "Medium",
          "companies": ["Facebook", "Microsoft", "LinkedIn"],
          "tags": ["Array", "Two Pointers"],
          "description": "Master the two pointers technique.",
          "link": ""
        }
      ]
    },
    {
      "id": "recursion",
      "title": "Recursion",
      "description": "Recursive algorithms and backtracking problems",
      "questions": [
        {
          "id": "rec_1",
          "title": "Fibonacci Number",
          "routeName": "fibonacci_number",
          "difficulty": "Easy",
          "companies": ["Amazon", "Microsoft", "Adobe"],
          "tags": ["Math", "Dynamic Programming", "Recursion"],
          "description": "Calculate the nth Fibonacci number.",
          "link": ""
        },
        {
          "id": "rec_2",
          "title": "Generate Parentheses",
          "routeName": "generate_parentheses",
          "difficulty": "Medium",
          "companies": ["Google", "Amazon", "Facebook"],
          "tags": ["String", "Dynamic Programming", "Backtracking"],
          "description": "Generate all combinations of well-formed parentheses.",
          "link": ""
        },
        {
          "id": "rec_3",
          "title": "Permutations",
          "routeName": "permutations",
          "difficulty": "Medium",
          "companies": ["Microsoft", "Amazon", "LinkedIn"],
          "tags": ["Array", "Backtracking"],
          "description": "Generate all possible permutations of an array.",
          "link": ""
        }
      ]
    },
    {
      "id": "linked-list",
      "title": "Linked Lists",
      "description": "Linked list manipulation and algorithms",
      "questions": [
        {
          "id": "ll_1",
          "title": "Reverse Linked List",
          "routeName": "reverse_linked_list",
          "difficulty": "Easy",
          "companies": ["Amazon", "Microsoft", "Apple", "Facebook"],
          "tags": ["Linked List", "Recursion"],
          "description": "Reverse a singly linked list.",
          "link": ""
        },
        {
          "id": "ll_2",
          "title": "Merge Two Sorted Lists",
          "routeName": "merge_two_sorted_lists",
          "difficulty": "Easy",
          "companies": ["Amazon", "Google", "Apple"],
          "tags": ["Linked List", "Recursion"],
          "description": "Merge two sorted linked lists into one.",
          "link": ""
        },
        {
          "id": "ll_3",
          "title": "Linked List Cycle",
          "routeName": "linked_list_cycle",
          "difficulty": "Easy",
          "companies": ["Amazon", "Microsoft", "Yahoo"],
          "tags": ["Hash Table", "Linked List", "Two Pointers"],
          "description": "Determine if a linked list has a cycle.",
          "link": ""
        }
      ]
    },
    {
      "id": "stacks",
      "title": "Stacks",
      "description": "Stack data structure and related algorithms",
      "questions": [
        {
          "id": "stack_1",
          "title": "Valid Parentheses",
          "routeName": "valid_parentheses",
          "difficulty": "Easy",
          "companies": ["Amazon", "Google", "Microsoft", "Facebook"],
          "tags": ["String", "Stack"],
          "description": "Determine if parentheses are properly balanced.",
          "link": ""
        },
        {
          "id": "stack_2",
          "title": "Min Stack",
          "routeName": "min_stack",
          "difficulty": "Easy",
          "companies": ["Amazon", "Google", "Bloomberg"],
          "tags": ["Stack", "Design"],
          "description": "Design a stack that supports push, pop, top, and getMin in O(1).",
          "link": ""
        },
        {
          "id": "stack_3",
          "title": "Daily Temperatures",
          "routeName": "daily_temperatures",
          "difficulty": "Medium",
          "companies": ["Google", "Amazon", "Facebook"],
          "tags": ["Array", "Stack", "Monotonic Stack"],
          "description": "Find the number of days until a warmer temperature.",
          "link": ""
        }
      ]
    },
    {
      "id": "trees",
      "title": "Trees",
      "description": "Binary trees, tree traversals, and tree algorithms",
      "questions": [
        {
          "id": "tree_1",
          "title": "Maximum Depth of Binary Tree",
          "routeName": "maximum_depth_of_binary_tree",
          "difficulty": "Easy",
          "companies": ["LinkedIn", "Amazon", "Apple"],
          "tags": ["Tree", "Depth-First Search", "Breadth-First Search"],
          "description": "Find the maximum depth of a binary tree.",
          "link": ""
        },
        {
          "id": "tree_2",
          "title": "Invert Binary Tree",
          "routeName": "invert_binary_tree",
          "difficulty": "Easy",
          "companies": ["Google", "Amazon", "Facebook"],
          "tags": ["Tree", "Depth-First Search", "Breadth-First Search"],
          "description": "Invert a binary tree.",
          "link": ""
        },
        {
          "id": "tree_3",
          "title": "Binary Tree Level Order Traversal",
          "routeName": "binary_tree_level_order_traversal",
          "difficulty": "Medium",
          "companies": ["Facebook", "Amazon", "Microsoft"],
          "tags": ["Tree", "Breadth-First Search"],
          "description": "Return level order traversal of nodes' values.",
          "link": ""
        }
      ]
    },
    {
      "id": "bst",
      "title": "Binary Search Trees (BST)",
      "description": "Binary search tree operations and algorithms",
      "questions": [
        {
          "id": "bst_1",
          "title": "Validate Binary Search Tree",
          "routeName": "validate_binary_search_tree",
          "difficulty": "Medium",
          "companies": ["Amazon", "Microsoft", "Facebook"],
          "tags": ["Tree", "Depth-First Search", "Binary Search Tree"],
          "description": "Determine if a binary tree is a valid BST.",
          "link": ""
        },
        {
          "id": "bst_2",
          "title": "Lowest Common Ancestor of BST",
          "routeName": "lowest_common_ancestor_of_bst",
          "difficulty": "Easy",
          "companies": ["Amazon", "Microsoft", "Facebook"],
          "tags": ["Tree", "Depth-First Search", "Binary Search Tree"],
          "description": "Find the lowest common ancestor in a BST.",
          "link": ""
        },
        {
          "id": "bst_3",
          "title": "Kth Smallest Element in BST",
          "routeName": "kth_smallest_element_in_bst",
          "difficulty": "Medium",
          "companies": ["Google", "Amazon", "Uber"],
          "tags": ["Tree", "Depth-First Search", "Binary Search Tree"],
          "description": "Find the kth smallest element in a BST.",
          "link": ""
        }
      ]
    },
    {
      "id": "heap",
      "title": "Heap",
      "description": "Heap data structure and priority queue problems",
      "questions": [
        {
          "id": "heap_1",
          "title": "Kth Largest Element in Array",
          "routeName": "kth_largest_element_in_array",
          "difficulty": "Medium",
          "companies": ["Facebook", "Amazon", "Apple"],
          "tags": ["Array", "Divide and Conquer", "Sorting", "Heap"],
          "description": "Find the kth largest element in an unsorted array.",
          "link": ""
        },
        {
          "id": "heap_2",
          "title": "Top K Frequent Elements",
          "routeName": "top_k_frequent_elements",
          "difficulty": "Medium",
          "companies": ["Amazon", "Yelp", "Pocket Gems"],
          "tags": [
            "Array",
            "Hash Table",
            "Divide and Conquer",
            "Sorting",
            "Heap"
          ],
          "description": "Find k most frequent elements.",
          "link": ""
        },
        {
          "id": "heap_3",
          "title": "Merge k Sorted Lists",
          "routeName": "merge_k_sorted_lists",
          "difficulty": "Hard",
          "companies": ["Amazon", "Google", "Microsoft"],
          "tags": ["Linked List", "Divide and Conquer", "Heap"],
          "description": "Merge k sorted linked lists.",
          "link": ""
        }
      ]
    },
    {
      "id": "huffman-coding",
      "title": "Huffman Coding",
      "description": "Huffman coding algorithm and compression techniques",
      "questions": [
        {
          "id": "huff_1",
          "title": "Huffman Encoding",
          "routeName": "huffman_encoding",
          "difficulty": "Medium",
          "companies": ["Google", "Amazon", "Microsoft"],
          "tags": ["Greedy", "Heap", "Tree"],
          "description": "Implement Huffman encoding algorithm.",
          "link": ""
        },
        {
          "id": "huff_2",
          "title": "Huffman Decoding",
          "routeName": "huffman_decoding",
          "difficulty": "Medium",
          "companies": ["Facebook", "Netflix", "Adobe"],
          "tags": ["Tree", "Hash Table"],
          "description": "Decode a Huffman encoded string.",
          "link": ""
        }
      ]
    },
    {
      "id": "dynamic-programming",
      "title": "Dynamic Programming",
      "description": "Dynamic programming optimization and memoization",
      "questions": [
        {
          "id": "dp_1",
          "title": "Climbing Stairs",
          "routeName": "climbing_stairs",
          "difficulty": "Easy",
          "companies": ["Amazon", "Apple", "Adobe"],
          "tags": ["Math", "Dynamic Programming", "Memoization"],
          "description": "Count ways to climb n stairs taking 1 or 2 steps.",
          "link": ""
        },
        {
          "id": "dp_2",
          "title": "House Robber",
          "routeName": "house_robber",
          "difficulty": "Medium",
          "companies": ["Amazon", "Microsoft", "Goldman Sachs"],
          "tags": ["Array", "Dynamic Programming"],
          "description": "Rob houses without robbing adjacent ones.",
          "link": ""
        },
        {
          "id": "dp_3",
          "title": "Coin Change",
          "routeName": "coin_change",
          "difficulty": "Medium",
          "companies": ["Amazon", "Google", "Microsoft"],
          "tags": ["Array", "Dynamic Programming", "Breadth-First Search"],
          "description": "Find minimum coins needed to make amount.",
          "link": ""
        },
        {
          "id": "dp_4",
          "title": "Longest Increasing Subsequence",
          "routeName": "longest_increasing_subsequence",
          "difficulty": "Medium",
          "companies": ["Microsoft", "Amazon", "Google"],
          "tags": ["Array", "Binary Search", "Dynamic Programming"],
          "description": "Find length of longest increasing subsequence.",
          "link": ""
        }
      ]
    },
    {
      "id": "graphs",
      "title": "Graphs",
      "description": "Graph algorithms, BFS, DFS, and shortest path problems",
      "questions": [
        {
          "id": "graph_1",
          "title": "Number of Islands",
          "routeName": "number_of_islands",
          "difficulty": "Medium",
          "companies": ["Amazon", "Microsoft", "Facebook"],
          "tags": ["Array", "Depth-First Search", "Breadth-First Search"],
          "description": "Count the number of islands in a 2D grid.",
          "link": ""
        },
        {
          "id": "graph_2",
          "title": "Clone Graph",
          "routeName": "clone_graph",
          "difficulty": "Medium",
          "companies": ["Amazon", "Google", "Facebook"],
          "tags": ["Hash Table", "Depth-First Search", "Breadth-First Search"],
          "description": "Clone an undirected graph.",
          "link": ""
        },
        {
          "id": "graph_3",
          "title": "Course Schedule",
          "routeName": "course_schedule",
          "difficulty": "Medium",
          "companies": ["Amazon", "Microsoft", "Zenefits"],
          "tags": [
            "Depth-First Search",
            "Breadth-First Search",
            "Topological Sort"
          ],
          "description": "Determine if you can finish all courses.",
          "link": ""
        }
      ]
    },
    {
      "id": "oops-python",
      "title": "OOPs in Python",
      "description": "Object-oriented programming concepts and design patterns in Python",
      "questions": [
        {
          "id": "oop_1",
          "title": "Class Design",
          "routeName": "class_design",
          "difficulty": "Medium",
          "companies": ["Google", "Amazon", "Microsoft"],
          "tags": ["Design", "Object-Oriented Programming"],
          "description": "Design a class hierarchy for a vehicle system.",
          "link": ""
        },
        {
          "id": "oop_2",
          "title": "Inheritance and Polymorphism",
          "routeName": "inheritance_and_polymorphism",
          "difficulty": "Medium",
          "companies": ["Facebook", "Netflix", "Uber"],
          "tags": ["Design", "Object-Oriented Programming"],
          "description": "Implement inheritance and polymorphism concepts.",
          "link": ""
        },
        {
          "id": "oop_3",
          "title": "Design Patterns",
          "routeName": "design_patterns",
          "difficulty": "Hard",
          "companies": ["Amazon", "Google", "Microsoft"],
          "tags": ["Design", "Object-Oriented Programming", "Design Patterns"],
          "description": "Implement common design patterns in Python.",
          "link": ""
        }
      ]
    }
  ]
}
